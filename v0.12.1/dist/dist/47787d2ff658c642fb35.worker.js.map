{"version":3,"sources":["webpack://Hls/webpack/bootstrap","webpack://Hls/./node_modules/events/events.js","webpack://Hls/./src/events.js","webpack://Hls/./src/errors.js","webpack://Hls/./src/crypt/aes-crypto.js","webpack://Hls/./src/crypt/fast-aes-key.js","webpack://Hls/./src/crypt/aes-decryptor.js","webpack://Hls/./src/utils/get-self-scope.js","webpack://Hls/./src/utils/logger.js","webpack://Hls/./src/crypt/decrypter.js","webpack://Hls/./src/polyfills/number-isFinite.js","webpack://Hls/./src/demux/adts.js","webpack://Hls/./src/demux/id3.js","webpack://Hls/./src/demux/aacdemuxer.js","webpack://Hls/./src/demux/mp4demuxer.js","webpack://Hls/./src/demux/mpegaudio.js","webpack://Hls/./src/demux/exp-golomb.js","webpack://Hls/./src/demux/sample-aes.js","webpack://Hls/./src/demux/tsdemuxer.js","webpack://Hls/./src/demux/mp3demuxer.js","webpack://Hls/./src/remux/aac-helper.js","webpack://Hls/./src/remux/mp4-generator.js","webpack://Hls/./src/remux/mp4-remuxer.js","webpack://Hls/./src/remux/passthrough-remuxer.js","webpack://Hls/./src/demux/demuxer-inline.js","webpack://Hls/./src/demux/demuxer-worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EventEmitter","this","_events","_maxListeners","undefined","isFunction","arg","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNumber","isNaN","TypeError","emit","type","er","handler","len","args","listeners","error","length","arguments","Error","err","context","Array","slice","apply","addListener","listener","newListener","push","warned","console","trace","on","once","fired","g","removeListener","list","position","splice","removeAllListeners","listenerCount","evlistener","emitter","HlsEvents","MEDIA_ATTACHING","MEDIA_ATTACHED","MEDIA_DETACHING","MEDIA_DETACHED","BUFFER_RESET","BUFFER_CODECS","BUFFER_CREATED","BUFFER_APPENDING","BUFFER_APPENDED","BUFFER_EOS","BUFFER_FLUSHING","BUFFER_FLUSHED","MANIFEST_LOADING","MANIFEST_LOADED","MANIFEST_PARSED","LEVEL_SWITCHING","LEVEL_SWITCHED","LEVEL_LOADING","LEVEL_LOADED","LEVEL_UPDATED","LEVEL_PTS_UPDATED","LEVELS_UPDATED","AUDIO_TRACKS_UPDATED","AUDIO_TRACK_SWITCHING","AUDIO_TRACK_SWITCHED","AUDIO_TRACK_LOADING","AUDIO_TRACK_LOADED","SUBTITLE_TRACKS_UPDATED","SUBTITLE_TRACKS_CLEARED","SUBTITLE_TRACK_SWITCH","SUBTITLE_TRACK_LOADING","SUBTITLE_TRACK_LOADED","SUBTITLE_FRAG_PROCESSED","CUES_PARSED","NON_NATIVE_TEXT_TRACKS_FOUND","INIT_PTS_FOUND","FRAG_LOADING","FRAG_LOAD_PROGRESS","FRAG_LOAD_EMERGENCY_ABORTED","FRAG_LOADED","FRAG_DECRYPTED","FRAG_PARSING_INIT_SEGMENT","FRAG_PARSING_USERDATA","FRAG_PARSING_METADATA","FRAG_PARSING_DATA","FRAG_PARSED","FRAG_BUFFERED","FRAG_CHANGED","FPS_DROP","FPS_DROP_LEVEL_CAPPING","ERROR","DESTROYING","KEY_LOADING","KEY_LOADED","STREAM_STATE_TRANSITION","ErrorTypes","NETWORK_ERROR","MEDIA_ERROR","KEY_SYSTEM_ERROR","MUX_ERROR","OTHER_ERROR","ErrorDetails","KEY_SYSTEM_NO_KEYS","KEY_SYSTEM_NO_ACCESS","KEY_SYSTEM_NO_SESSION","KEY_SYSTEM_LICENSE_REQUEST_FAILED","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","MANIFEST_PARSING_ERROR","MANIFEST_INCOMPATIBLE_CODECS_ERROR","LEVEL_EMPTY_ERROR","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","LEVEL_SWITCH_ERROR","AUDIO_TRACK_LOAD_ERROR","AUDIO_TRACK_LOAD_TIMEOUT","FRAG_LOAD_ERROR","FRAG_LOAD_TIMEOUT","FRAG_DECRYPT_ERROR","FRAG_PARSING_ERROR","REMUX_ALLOC_ERROR","KEY_LOAD_ERROR","KEY_LOAD_TIMEOUT","BUFFER_ADD_CODEC_ERROR","BUFFER_APPEND_ERROR","BUFFER_APPENDING_ERROR","BUFFER_STALLED_ERROR","BUFFER_FULL_ERROR","BUFFER_SEEK_OVER_HOLE","BUFFER_NUDGE_ON_STALL","INTERNAL_EXCEPTION","AESCrypto","subtle","iv","_classCallCheck","aesIV","decrypt","data","FastAESKey","fast_aes_key_classCallCheck","expandKey","importKey","AESDecryptor","aes_decryptor_classCallCheck","rcon","subMix","Uint32Array","invSubMix","sBox","invSBox","initTable","uint8ArrayToUint32Array_","arrayBuffer","view","DataView","newArray","getUint32","subMix0","subMix1","subMix2","subMix3","invSubMix0","invSubMix1","invSubMix2","invSubMix3","x","xi","sx","x2","x4","x8","keyBuffer","sameKey","offset","keySize","ksRows","ksRow","invKsRow","keySchedule","invKeySchedule","sbox","prev","networkToHostOrderSwap","word","inputArrayBuffer","removePKCS7Padding","nRounds","invSBOX","initVector","initVector0","initVector1","initVector2","initVector3","inputInt32","Int32Array","outputInt32","t0","t1","t2","t3","s0","s1","s2","s3","inputWords0","inputWords1","inputWords2","inputWords3","swapWord","buffer","outputBytes","byteLength","paddingBytes","getUint8","removePadding","destroy","getSelfScope","window","self","noop","fakeLogger","debug","log","warn","info","exportedLogger","global","exportLoggerFunctions","debugConfig","_len2","functions","_key2","forEach","func","_len","_key","msg","formatMsg","consolePrintFn","logger","Decrypter","observer","config","_ref$removePKCS7Paddi","decrypter_classCallCheck","logEnabled","browserCrypto","crypto","webkitSubtle","e","disableWebCrypto","isSync","enableSoftwareAES","callback","_this","decryptor","fastAesKey","then","aesKey","catch","onWebCryptoError","result","message","trigger","Event","details","fatal","reason","isFiniteNumber","Number","isFinite","isHeaderPattern","getHeaderLength","getFullFrameLength","isHeader","probe","frameLength","newOffset","initTrackConfig","track","audioCodec","samplerate","adtsSampleingIndex","adtsObjectType","adtsExtensionSampleingIndex","adtsChanelConfig","userAgent","navigator","toLowerCase","manifestCodec","adtsSampleingRates","test","indexOf","channelCount","codec","getAudioConfig","getFrameDuration","appendFrame","pts","frameIndex","header","frameDuration","headerLength","stamp","parseFrameHeader","aacSample","unit","subarray","dts","samples","sample","ID3","isFooter","getID3Data","front","_readSize","size","getTimeStamp","frames","getID3Frames","frame","isTimeStampFrame","_readTimeStamp","_getFrameData","String","fromCharCode","id3Data","end","frameData","_decodeFrame","_decodePrivFrame","_decodeTextFrame","_decodeURLFrame","timeStampFrame","Uint8Array","pts33Bit","timestamp","Math","round","owner","_utf8ArrayToStr","privateData","index","description","text","url","array","exitOnNull","char2","char3","out","AACDemuxer","remuxer","aacdemuxer_classCallCheck","resetInitSegment","initSegment","videoCodec","duration","_audioTrack","container","id","sequenceNumber","isAAC","inputTimeScale","resetTimeStamp","ADTS","append","timeOffset","contiguous","accurateTimeOffset","id3Samples","remux","UINT32_MAX","pow","MP4Demuxer","mp4demuxer_classCallCheck","initPTS","initData","parseInitSegment","tracks","audio","video","audiovideo","findBox","start","min","bin2str","readUint16","val","readUint32","writeUint32","path","results","subresults","endbox","concat","parseSegmentIndex","moov","moovEndOffset","sidx","references","version","timescale","startByte","referencesCount","referenceIndex","referenceInfo","referenceSize","subsegmentDuration","earliestPresentationTime","trak","tkhd","trackId","mdhd","hdlr","soun","vide","codecBox","codecType","getStartDTS","fragment","baseTimes","trafs","map","traf","tfhd","scale","tfdt","offsetStartDTS","baseMediaDecodeTime","max","upper","floor","lower","startDTS","MpegAudio","BitratesMap","SamplingRateMap","SamplesCoefficients","BytesInSlot","parseHeader","samplesPerFrame","sampleRate","headerB","headerC","headerE","headerF","headerG","columnInBitrates","bitRate","columnInSampleRates","sampleCoefficient","bytesInSlot","parseInt","ExpGolomb","exp_golomb_classCallCheck","bytesAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","set","skipBits","count","skipBytes","readBits","bits","valu","skipLZ","leadingZeroCount","skipUEG","skipEG","readUEG","clz","readEG","readBoolean","readUByte","readUShort","readUInt","skipScalingList","lastScale","nextScale","j","readSPS","profileIdc","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","numRefFramesInPicOrderCntCycle","scalingListCount","chromaFormatIdc","picOrderCntType","pixelRatio","width","ceil","height","readSliceType","SampleAesDecrypter","decryptdata","discardEPB","sample_aes_classCallCheck","decrypter","decryptBuffer","encryptedData","decryptAacSample","sampleIndex","sync","curUnit","encryptedBuffer","byteOffset","localthis","decryptedData","decryptAacSamples","getAvcEncryptedData","decodedData","encryptedDataLen","Int8Array","outputPos","inputPos","getAvcDecryptedUnit","decryptAvcSample","unitIndex","decryptAvcSamples","curUnits","units","RemuxerTrackIdConfig","id3","TSDemuxer","typeSupported","tsdemuxer_classCallCheck","sampleAes","setDecryptData","method","syncOffset","_syncOffset","scanwindow","createTrack","pid","dropped","pmtParsed","_pmtId","_avcTrack","_id3Track","_txtTrack","aacOverFlow","aacLastPTS","avcSample","_duration","stt","pes","unknownPIDs","avcTrack","audioTrack","id3Track","avcId","audioId","id3Id","pmtId","avcData","pesData","audioData","parsePAT","_parsePAT","parsePMT","_parsePMT","parsePES","_parsePES","parseAVCPES","_parseAVCPES","parseAACPES","_parseAACPES","parseMPEGPES","_parseMPEGPES","parseID3PES","_parseID3PES","parsedPIDs","mpeg","mp3","avc","decryptAndRemux","videoTrack","textTrack","decryptAndRemuxAvc","_initPTS","_initDTS","mpegSupported","isSampleAes","tableEnd","stream","frag","pesFlags","pesLen","pesHdrLen","pesPts","pesDts","payloadStartOffset","newData","dataLen","pushAccesUnit","nbSamples","forceKeyFrameOnDiscontinuity","sps","last","_parseAVCNALu","expGolombDecoder","spsfound","createAVCSample","audFound","sliceType","payloadType","payloadSize","endOfCaptions","b","firstByte","totalCCs","byteArray","_insertSampleInOrder","bytes","codecarray","codecstring","h","toString","pps","arr","pos","_getLastNalUnit","lastUnit","overflow","state","naluState","lastState","lastUnitStart","lastUnitType","tmp","newLength","EPBPositions","sourceIndex","shift","newPTS","abs","MP3Demuxer","mp3demuxer_classCallCheck","AAC","getSilentFrame","MP4","init","types","avc1","avcC","btrt","dinf","dref","esds","ftyp","mdat","mdia","mfhd","minf","moof","mp4a",".mp3","mvex","mvhd","pasp","sdtp","stbl","stco","stsc","stsd","stsz","stts","trun","trex","vmhd","smhd","charCodeAt","videoHdlr","audioHdlr","HDLR_TYPES","STTS","STSC","STCO","STSZ","VMHD","SMHD","STSD","majorBrand","avc1Brand","minorVersion","FTYP","box","DINF","payload","upperWordDuration","lowerWordDuration","sn","boxes","flags","dependsOn","isDependedOn","hasRedundancy","avcc","hSpacing","vSpacing","configlen","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","arraylen","cts","isLeading","paddingValue","isNonSync","degradPrio","movie","MP4Remuxer","vendor","mp4_remuxer_classCallCheck","isSafari","match","ISGenerated","defaultTimeStamp","generateIS","nbAudioSamples","nbVideoSamples","audioTimeOffset","videoTimeOffset","audiovideoDeltaDts","remuxAudio","audioTrackLength","endPTS","startPTS","remuxVideo","videoData","remuxEmptyAudio","remuxID3","remuxText","audioSamples","videoSamples","computePTSDTS","initDTS","Infinity","metadata","keys","lastPTS","lastDTS","timeScale","mp4SampleDuration","firstPTS","firstDTS","inputSamples","outputSamples","ptsNormalize","_PTSNormalize","nextAvcDts","sort","a","deltadts","deltapts","PTSDTSshift","reduce","curr","delta","nbNalu","naluLen","nbUnits","sampleLen","mdatSize","setUint32","avcSampleUnits","mp4SampleLength","compositionTimeOffset","unitData","unitDataLen","lastFrameDuration","stretchShortVideoTrack","maxBufferHole","gapTolerance","deltaToFrameEnd","nextAudioPts","data1","data2","endDTS","hasAudio","hasVideo","nb","mp4timeScale","scaleFactor","inputSampleDuration","rawMPEG","mp4Sample","fillFrame","filter","maxAudioFramesDrift","nextPts","toFixed","missing","newStamp","audioSample","numMissingFrames","unitLen","lastSampleDuration","silentFrame","reference","PassThroughRemuxer","passthrough_remuxer_classCallCheck","rawData","streamType","performance","DemuxerInline","demuxer_inline_classCallCheck","demuxer","discontinuity","trackSwitch","defaultInitPTS","startTime","now","Date","endTime","stats","tstart","tdecrypt","pushDecrypted","muxConfig","demux","mux","__webpack_exports__","events_default","event","off","forwardMessage","ev","postMessage","addEventListener","cmd","JSON","parse","demuxer_inline","_typeof","enableLogs","events","transferable"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,SAIAlC,IAAAmC,EAAA,mBC7DA,SAAAC,IACAC,KAAAC,QAAAD,KAAAC,YACAD,KAAAE,cAAAF,KAAAE,oBAAAC,EAwQA,SAAAC,EAAAC,GACA,yBAAAA,EAOA,SAAAC,EAAAD,GACA,uBAAAA,GAAA,OAAAA,EAGA,SAAAE,EAAAF,GACA,gBAAAA,EAnRAvC,EAAAD,QAAAkC,EAGAA,iBAEAA,EAAAJ,UAAAM,aAAAE,EACAJ,EAAAJ,UAAAO,mBAAAC,EAIAJ,EAAAS,oBAAA,GAIAT,EAAAJ,UAAAc,gBAAA,SAAAjB,GACA,IA2PA,SAAAa,GACA,uBAAAA,EA5PAK,CAAAlB,MAAA,GAAAmB,MAAAnB,GACA,MAAAoB,UAAA,+BAEA,OADAZ,KAAAE,cAAAV,EACAQ,MAGAD,EAAAJ,UAAAkB,KAAA,SAAAC,GACA,IAAAC,EAAAC,EAAAC,EAAAC,EAAAnD,EAAAoD,EAMA,GAJAnB,KAAAC,UACAD,KAAAC,YAGA,UAAAa,KACAd,KAAAC,QAAAmB,OACAd,EAAAN,KAAAC,QAAAmB,SAAApB,KAAAC,QAAAmB,MAAAC,QAAA,CAEA,IADAN,EAAAO,UAAA,cACAC,MACA,MAAAR,EAGA,IAAAS,EAAA,IAAAD,MAAA,yCAAAR,EAAA,KAEA,MADAS,EAAAC,QAAAV,EACAS,EAOA,GAAAjB,EAFAS,EAAAhB,KAAAC,QAAAa,IAGA,SAEA,GAAAV,EAAAY,GACA,OAAAM,UAAAD,QAEA,OACAL,EAAA9C,KAAA8B,MACA,MACA,OACAgB,EAAA9C,KAAA8B,KAAAsB,UAAA,IACA,MACA,OACAN,EAAA9C,KAAA8B,KAAAsB,UAAA,GAAAA,UAAA,IACA,MAEA,QACAJ,EAAAQ,MAAA/B,UAAAgC,MAAAzD,KAAAoD,UAAA,GACAN,EAAAY,MAAA5B,KAAAkB,QAEG,GAAAZ,EAAAU,GAIH,IAHAE,EAAAQ,MAAA/B,UAAAgC,MAAAzD,KAAAoD,UAAA,GAEAL,GADAE,EAAAH,EAAAW,SACAN,OACAtD,EAAA,EAAeA,EAAAkD,EAASlD,IACxBoD,EAAApD,GAAA6D,MAAA5B,KAAAkB,GAGA,UAGAnB,EAAAJ,UAAAkC,YAAA,SAAAf,EAAAgB,GACA,IAAA3D,EAEA,IAAAiC,EAAA0B,GACA,MAAAlB,UAAA,+BA2CA,OAzCAZ,KAAAC,UACAD,KAAAC,YAIAD,KAAAC,QAAA8B,aACA/B,KAAAa,KAAA,cAAAC,EACAV,EAAA0B,YACAA,cAEA9B,KAAAC,QAAAa,GAGAR,EAAAN,KAAAC,QAAAa,IAEAd,KAAAC,QAAAa,GAAAkB,KAAAF,GAGA9B,KAAAC,QAAAa,IAAAd,KAAAC,QAAAa,GAAAgB,GANA9B,KAAAC,QAAAa,GAAAgB,EASAxB,EAAAN,KAAAC,QAAAa,MAAAd,KAAAC,QAAAa,GAAAmB,SAIA9D,EAHAoC,EAAAP,KAAAE,eAGAH,EAAAS,oBAFAR,KAAAE,gBAKA/B,EAAA,GAAA6B,KAAAC,QAAAa,GAAAO,OAAAlD,IACA6B,KAAAC,QAAAa,GAAAmB,QAAA,EACAC,QAAAd,MAAA,mIAGApB,KAAAC,QAAAa,GAAAO,QACA,mBAAAa,QAAAC,OAEAD,QAAAC,SAKAnC,MAGAD,EAAAJ,UAAAyC,GAAArC,EAAAJ,UAAAkC,YAEA9B,EAAAJ,UAAA0C,KAAA,SAAAvB,EAAAgB,GACA,IAAA1B,EAAA0B,GACA,MAAAlB,UAAA,+BAEA,IAAA0B,GAAA,EAEA,SAAAC,IACAvC,KAAAwC,eAAA1B,EAAAyB,GAEAD,IACAA,GAAA,EACAR,EAAAF,MAAA5B,KAAAsB,YAOA,OAHAiB,EAAAT,WACA9B,KAAAoC,GAAAtB,EAAAyB,GAEAvC,MAIAD,EAAAJ,UAAA6C,eAAA,SAAA1B,EAAAgB,GACA,IAAAW,EAAAC,EAAArB,EAAAtD,EAEA,IAAAqC,EAAA0B,GACA,MAAAlB,UAAA,+BAEA,IAAAZ,KAAAC,UAAAD,KAAAC,QAAAa,GACA,OAAAd,KAMA,GAHAqB,GADAoB,EAAAzC,KAAAC,QAAAa,IACAO,OACAqB,GAAA,EAEAD,IAAAX,GACA1B,EAAAqC,EAAAX,WAAAW,EAAAX,oBACA9B,KAAAC,QAAAa,GACAd,KAAAC,QAAAuC,gBACAxC,KAAAa,KAAA,iBAAAC,EAAAgB,QAEG,GAAAxB,EAAAmC,GAAA,CACH,IAAA1E,EAAAsD,EAAoBtD,KAAA,GACpB,GAAA0E,EAAA1E,KAAA+D,GACAW,EAAA1E,GAAA+D,UAAAW,EAAA1E,GAAA+D,aAAA,CACAY,EAAA3E,EACA,MAIA,GAAA2E,EAAA,EACA,OAAA1C,KAEA,IAAAyC,EAAApB,QACAoB,EAAApB,OAAA,SACArB,KAAAC,QAAAa,IAEA2B,EAAAE,OAAAD,EAAA,GAGA1C,KAAAC,QAAAuC,gBACAxC,KAAAa,KAAA,iBAAAC,EAAAgB,GAGA,OAAA9B,MAGAD,EAAAJ,UAAAiD,mBAAA,SAAA9B,GACA,IAAAxB,EAAA6B,EAEA,IAAAnB,KAAAC,QACA,OAAAD,KAGA,IAAAA,KAAAC,QAAAuC,eAKA,OAJA,IAAAlB,UAAAD,OACArB,KAAAC,WACAD,KAAAC,QAAAa,WACAd,KAAAC,QAAAa,GACAd,KAIA,OAAAsB,UAAAD,OAAA,CACA,IAAA/B,KAAAU,KAAAC,QACA,mBAAAX,GACAU,KAAA4C,mBAAAtD,GAIA,OAFAU,KAAA4C,mBAAA,kBACA5C,KAAAC,WACAD,KAKA,GAAAI,EAFAe,EAAAnB,KAAAC,QAAAa,IAGAd,KAAAwC,eAAA1B,EAAAK,QACG,GAAAA,EAEH,KAAAA,EAAAE,QACArB,KAAAwC,eAAA1B,EAAAK,IAAAE,OAAA,IAIA,cAFArB,KAAAC,QAAAa,GAEAd,MAGAD,EAAAJ,UAAAwB,UAAA,SAAAL,GAQA,OANAd,KAAAC,SAAAD,KAAAC,QAAAa,GAEAV,EAAAJ,KAAAC,QAAAa,KACAd,KAAAC,QAAAa,IAEAd,KAAAC,QAAAa,GAAAa,YAIA5B,EAAAJ,UAAAkD,cAAA,SAAA/B,GACA,GAAAd,KAAAC,QAAA,CACA,IAAA6C,EAAA9C,KAAAC,QAAAa,GAEA,GAAAV,EAAA0C,GACA,SACA,GAAAA,EACA,OAAAA,EAAAzB,OAEA,UAGAtB,EAAA8C,cAAA,SAAAE,EAAAjC,GACA,OAAAiC,EAAAF,cAAA/B,yCCxRA,IAiHekC,GA/GbC,gBAAiB,oBAEjBC,eAAgB,mBAEhBC,gBAAiB,oBAEjBC,eAAgB,mBAEhBC,aAAc,iBAEdC,cAAe,kBAEfC,eAAgB,mBAEhBC,iBAAkB,qBAElBC,gBAAiB,oBAEjBC,WAAY,eAEZC,gBAAiB,oBAEjBC,eAAgB,mBAEhBC,iBAAkB,qBAElBC,gBAAiB,oBAEjBC,gBAAiB,oBAEjBC,gBAAiB,oBAEjBC,eAAgB,mBAEhBC,cAAe,kBAEfC,aAAc,iBAEdC,cAAe,kBAEfC,kBAAmB,qBAEnBC,eAAgB,mBAEhBC,qBAAsB,wBAEtBC,sBAAuB,yBAEvBC,qBAAsB,wBAEtBC,oBAAqB,uBAErBC,mBAAoB,sBAEpBC,wBAAyB,2BAEzBC,wBAAyB,2BAEzBC,sBAAuB,yBAEvBC,uBAAwB,0BAExBC,sBAAuB,yBAEvBC,wBAAyB,2BAEzBC,YAAa,gBAEbC,6BAA8B,8BAE9BC,eAAgB,kBAEhBC,aAAc,iBAEdC,mBAAoB,sBAEpBC,4BAA6B,8BAE7BC,YAAa,gBAEbC,eAAgB,mBAEhBC,0BAA2B,4BAE3BC,sBAAuB,yBAEvBC,sBAAuB,yBAEvBC,kBAAmB,qBAEnBC,YAAa,gBAEbC,cAAe,kBAEfC,aAAc,iBAEdC,SAAU,aAEVC,uBAAwB,yBAExBC,MAAO,WAEPC,WAAY,gBAEZC,YAAa,gBAEbC,WAAY,eAEZC,wBAAyB,4BClHdC,GAEXC,cAAe,eAEfC,YAAa,aAEbC,iBAAkB,iBAElBC,UAAW,WAEXC,YAAa,cAOFC,GACXC,mBAAoB,kBACpBC,qBAAsB,oBACtBC,sBAAuB,qBACvBC,kCAAmC,gCAEnCC,oBAAqB,oBAErBC,sBAAuB,sBAEvBC,uBAAwB,uBAExBC,mCAAoC,kCAEpCC,kBAAmB,kBAEnBC,iBAAkB,iBAElBC,mBAAoB,mBAEpBC,mBAAoB,mBAEpBC,uBAAwB,sBAExBC,yBAA0B,wBAE1BC,gBAAiB,gBAEjBC,kBAAmB,kBAEnBC,mBAAoB,mBAGpBC,mBAAoB,mBAEpBC,kBAAmB,kBAEnBC,eAAgB,eAEhBC,iBAAkB,iBAElBC,uBAAwB,sBAExBC,oBAAqB,oBAErBC,uBAAwB,uBAExBC,qBAAsB,qBAEtBC,kBAAmB,kBAEnBC,sBAAuB,qBAEvBC,sBAAuB,qBAEvBC,mBAAoB,yBCxEDC,aACnB,SAAAA,EAAaC,EAAQC,gGAAIC,CAAA/I,KAAA4I,GACvB5I,KAAK6I,OAASA,EACd7I,KAAKgJ,MAAQF,qBAGfG,iBAASC,EAAM5J,GACb,OAAOU,KAAK6I,OAAOI,SAAU3K,KAAM,UAAWwK,GAAI9I,KAAKgJ,OAAS1J,EAAK4J,aCI1DC,aAVb,SAAAA,EAAaN,EAAQvJ,gGAAK8J,CAAApJ,KAAAmJ,GACxBnJ,KAAK6I,OAASA,EACd7I,KAAKV,IAAMA,qBAGb+J,qBACE,OAAOrJ,KAAK6I,OAAOS,UAAU,MAAOtJ,KAAKV,KAAOhB,KAAM,YAAa,GAAQ,UAAW,sBCkR3EiL,aA7Qb,SAAAA,iGAAeC,CAAAxJ,KAAAuJ,GAEbvJ,KAAKyJ,MAAQ,EAAK,EAAK,EAAK,EAAK,EAAK,GAAM,GAAM,GAAM,IAAM,GAAM,IACpEzJ,KAAK0J,QAAU,IAAIC,YAAY,KAAM,IAAIA,YAAY,KAAM,IAAIA,YAAY,KAAM,IAAIA,YAAY,MACjG3J,KAAK4J,WAAa,IAAID,YAAY,KAAM,IAAIA,YAAY,KAAM,IAAIA,YAAY,KAAM,IAAIA,YAAY,MACpG3J,KAAK6J,KAAO,IAAIF,YAAY,KAC5B3J,KAAK8J,QAAU,IAAIH,YAAY,KAG/B3J,KAAKV,IAAM,IAAIqK,YAAY,GAE3B3J,KAAK+J,+BAIPC,kCAA0BC,GAGxB,IAFA,IAAIC,EAAO,IAAIC,SAASF,GACpBG,EAAW,IAAIT,YAAY,GACtB5L,EAAI,EAAGA,EAAI,EAAGA,IACrBqM,EAASrM,GAAKmM,EAAKG,UAAc,EAAJtM,GAG/B,OAAOqM,eAGTL,qBACE,IAAIF,EAAO7J,KAAK6J,KACZC,EAAU9J,KAAK8J,QACfJ,EAAS1J,KAAK0J,OACdY,EAAUZ,EAAO,GACjBa,EAAUb,EAAO,GACjBc,EAAUd,EAAO,GACjBe,EAAUf,EAAO,GACjBE,EAAY5J,KAAK4J,UACjBc,EAAad,EAAU,GACvBe,EAAaf,EAAU,GACvBgB,EAAahB,EAAU,GACvBiB,EAAajB,EAAU,GAEvBvL,EAAI,IAAIsL,YAAY,KACpBmB,EAAI,EACJC,EAAK,EACLhN,EAAI,EACR,IAAKA,EAAI,EAAGA,EAAI,IAAKA,IAEjBM,EAAEN,GADAA,EAAI,IACCA,GAAK,EAEJA,GAAK,EAAK,IAItB,IAAKA,EAAI,EAAGA,EAAI,IAAKA,IAAK,CACxB,IAAIiN,EAAKD,EAAMA,GAAM,EAAMA,GAAM,EAAMA,GAAM,EAAMA,GAAM,EACzDC,EAAMA,IAAO,EAAW,IAALA,EAAa,GAChCnB,EAAKiB,GAAKE,EACVlB,EAAQkB,GAAMF,EAGd,IAAIG,EAAK5M,EAAEyM,GACPI,EAAK7M,EAAE4M,GACPE,EAAK9M,EAAE6M,GAGPjM,EAAa,IAARZ,EAAE2M,GAAqB,SAALA,EAC3BV,EAAQQ,GAAM7L,GAAK,GAAOA,IAAM,EAChCsL,EAAQO,GAAM7L,GAAK,GAAOA,IAAM,GAChCuL,EAAQM,GAAM7L,GAAK,EAAMA,IAAM,GAC/BwL,EAAQK,GAAK7L,EAGbA,EAAU,SAALkM,EAAwB,MAALD,EAAsB,IAALD,EAAmB,SAAJH,EACxDJ,EAAWM,GAAO/L,GAAK,GAAOA,IAAM,EACpC0L,EAAWK,GAAO/L,GAAK,GAAOA,IAAM,GACpC2L,EAAWI,GAAO/L,GAAK,EAAMA,IAAM,GACnC4L,EAAWG,GAAM/L,EAGZ6L,GAGHA,EAAIG,EAAK5M,EAAEA,EAAEA,EAAE8M,EAAKF,KACpBF,GAAM1M,EAAEA,EAAE0M,KAHVD,EAAIC,EAAK,gBAQf1B,mBAAW+B,GAMT,IAJA,IAAI9L,EAAMU,KAAKgK,yBAAyBoB,GACpCC,GAAU,EACVC,EAAS,EAENA,EAAShM,EAAI+B,QAAUgK,GAC5BA,EAAW/L,EAAIgM,KAAYtL,KAAKV,IAAIgM,GACpCA,IAGF,IAAID,EAAJ,CAIArL,KAAKV,IAAMA,EACX,IAAIiM,EAAUvL,KAAKuL,QAAUjM,EAAI+B,OAEjC,GAAgB,IAAZkK,GAA6B,IAAZA,GAA6B,IAAZA,EACpC,MAAM,IAAIhK,MAAM,wBAA0BgK,GAG5C,IAAIC,EAASxL,KAAKwL,OAA6B,GAAnBD,EAAU,EAAI,GACtCE,SACAC,SAEAC,EAAc3L,KAAK2L,YAAc,IAAIhC,YAAY6B,GACjDI,EAAiB5L,KAAK4L,eAAiB,IAAIjC,YAAY6B,GACvDK,EAAO7L,KAAK6J,KACZJ,EAAOzJ,KAAKyJ,KAEZG,EAAY5J,KAAK4J,UACjBc,EAAad,EAAU,GACvBe,EAAaf,EAAU,GACvBgB,EAAahB,EAAU,GACvBiB,EAAajB,EAAU,GAEvBkC,SACA7M,SAEJ,IAAKwM,EAAQ,EAAGA,EAAQD,EAAQC,IAC1BA,EAAQF,EACVO,EAAOH,EAAYF,GAASnM,EAAImM,IAGlCxM,EAAI6M,EAEAL,EAAQF,GAAY,GAKtBtM,EAAK4M,GAHL5M,EAAKA,GAAK,EAAMA,IAAM,MAGN,KAAO,GAAO4M,EAAM5M,IAAM,GAAM,MAAS,GAAO4M,EAAM5M,IAAM,EAAK,MAAS,EAAK4M,EAAS,IAAJ5M,GAGpGA,GAAKwK,EAAMgC,EAAQF,EAAW,IAAM,IAC3BA,EAAU,GAAKE,EAAQF,GAAY,IAE5CtM,EAAK4M,EAAK5M,IAAM,KAAO,GAAO4M,EAAM5M,IAAM,GAAM,MAAS,GAAO4M,EAAM5M,IAAM,EAAK,MAAS,EAAK4M,EAAS,IAAJ5M,IAGtG0M,EAAYF,GAASK,GAAQH,EAAYF,EAAQF,GAAWtM,KAAO,GAGrE,IAAKyM,EAAW,EAAGA,EAAWF,EAAQE,IACpCD,EAAQD,EAASE,EAEfzM,EADa,EAAXyM,EACEC,EAAYF,GAEZE,EAAYF,EAAQ,GAIxBG,EAAeF,GADbA,EAAW,GAAKD,GAAS,EACAxM,EAEAyL,EAAWmB,EAAK5M,IAAM,KAAO0L,EAAWkB,EAAM5M,IAAM,GAAM,MAAS2L,EAAWiB,EAAM5M,IAAM,EAAK,MAAS4L,EAAWgB,EAAS,IAAJ5M,IAGrJ2M,EAAeF,GAAYE,EAAeF,KAAc,gBAK5DK,gCAAwBC,GACtB,OAAQA,GAAQ,IAAe,MAAPA,IAAkB,GAAc,SAAPA,IAAoB,EAAMA,IAAS,gBAGtF/C,iBAASgD,EAAkBX,EAAQtC,EAAOkD,GA2BxC,IA1BA,IAAIC,EAAUnM,KAAKuL,QAAU,EACzBK,EAAiB5L,KAAK4L,eACtBQ,EAAUpM,KAAK8J,QAEfF,EAAY5J,KAAK4J,UACjBc,EAAad,EAAU,GACvBe,EAAaf,EAAU,GACvBgB,EAAahB,EAAU,GACvBiB,EAAajB,EAAU,GAEvByC,EAAarM,KAAKgK,yBAAyBhB,GAC3CsD,EAAcD,EAAW,GACzBE,EAAcF,EAAW,GACzBG,EAAcH,EAAW,GACzBI,EAAcJ,EAAW,GAEzBK,EAAa,IAAIC,WAAWV,GAC5BW,EAAc,IAAID,WAAWD,EAAWrL,QAExCwL,SAAIC,SAAIC,SAAIC,SACZC,SAAIC,SAAIC,SAAIC,SACZC,SAAaC,SAAaC,SAAaC,SAEvC/B,SAAO1N,SACP0P,EAAWzN,KAAK+L,uBAEbT,EAASoB,EAAWrL,QAAQ,CAcjC,IAbAgM,EAAcI,EAASf,EAAWpB,IAClCgC,EAAcG,EAASf,EAAWpB,EAAS,IAC3CiC,EAAcE,EAASf,EAAWpB,EAAS,IAC3CkC,EAAcC,EAASf,EAAWpB,EAAS,IAE3C2B,EAAKI,EAAczB,EAAe,GAClCsB,EAAKM,EAAc5B,EAAe,GAClCuB,EAAKI,EAAc3B,EAAe,GAClCwB,EAAKE,EAAc1B,EAAe,GAElCH,EAAQ,EAGH1N,EAAI,EAAGA,EAAIoO,EAASpO,IACvB8O,EAAKnC,EAAWuC,IAAO,IAAMtC,EAAYuC,GAAM,GAAM,KAAQtC,EAAYuC,GAAM,EAAK,KAAQtC,EAAgB,IAALuC,GAAaxB,EAAeH,GACnIqB,EAAKpC,EAAWwC,IAAO,IAAMvC,EAAYwC,GAAM,GAAM,KAAQvC,EAAYwC,GAAM,EAAK,KAAQvC,EAAgB,IAALoC,GAAarB,EAAeH,EAAQ,GAC3IsB,EAAKrC,EAAWyC,IAAO,IAAMxC,EAAYyC,GAAM,GAAM,KAAQxC,EAAYqC,GAAM,EAAK,KAAQpC,EAAgB,IAALqC,GAAatB,EAAeH,EAAQ,GAC3IuB,EAAKtC,EAAW0C,IAAO,IAAMzC,EAAYsC,GAAM,GAAM,KAAQrC,EAAYsC,GAAM,EAAK,KAAQrC,EAAgB,IAALsC,GAAavB,EAAeH,EAAQ,GAE3IwB,EAAKJ,EACLK,EAAKJ,EACLK,EAAKJ,EACLK,EAAKJ,EAELvB,GAAgB,EAIlBoB,EAAOT,EAAQa,IAAO,KAAO,GAAOb,EAASc,GAAM,GAAM,MAAS,GAAOd,EAASe,GAAM,EAAK,MAAS,EAAKf,EAAa,IAALgB,GAAcxB,EAAeH,GAChJqB,EAAOV,EAAQc,IAAO,KAAO,GAAOd,EAASe,GAAM,GAAM,MAAS,GAAOf,EAASgB,GAAM,EAAK,MAAS,EAAKhB,EAAa,IAALa,GAAcrB,EAAeH,EAAQ,GACxJsB,EAAOX,EAAQe,IAAO,KAAO,GAAOf,EAASgB,GAAM,GAAM,MAAS,GAAOhB,EAASa,GAAM,EAAK,MAAS,EAAKb,EAAa,IAALc,GAActB,EAAeH,EAAQ,GACxJuB,EAAOZ,EAAQgB,IAAO,KAAO,GAAOhB,EAASa,GAAM,GAAM,MAAS,GAAOb,EAASc,GAAM,EAAK,MAAS,EAAKd,EAAa,IAALe,GAAcvB,EAAeH,EAAQ,GACxJA,GAAgB,EAGhBmB,EAAYtB,GAAUmC,EAASZ,EAAKP,GACpCM,EAAYtB,EAAS,GAAKmC,EAAST,EAAKT,GACxCK,EAAYtB,EAAS,GAAKmC,EAASV,EAAKP,GACxCI,EAAYtB,EAAS,GAAKmC,EAASX,EAAKL,GAGxCH,EAAce,EACdd,EAAce,EACdd,EAAce,EACdd,EAAce,EAEdlC,GAAkB,EAGpB,OAAOY,EArQJ,SAAwBwB,GAC7B,IAAMC,EAAcD,EAAOE,WACrBC,EAAeF,GAAgB,IAAIxD,SAASuD,GAASI,SAASH,EAAc,GAClF,OAAIE,EACKH,EAAO/L,MAAM,EAAGgM,EAAcE,GAE9BH,EA+PqBK,CAAcnB,EAAYc,QAAUd,EAAYc,oBAG9EM,mBACEhO,KAAKV,SAAMa,EACXH,KAAKuL,aAAUpL,EACfH,KAAKwL,YAASrL,EAEdH,KAAK6J,UAAO1J,EACZH,KAAK8J,aAAU3J,EACfH,KAAK0J,YAASvJ,EACdH,KAAK4J,eAAYzJ,EACjBH,KAAK2L,iBAAcxL,EACnBH,KAAK4L,oBAAiBzL,EAEtBH,KAAKyJ,UAAOtJ,QCrRT,SAAS8N,IAEd,MAAsB,oBAAXC,OAEFC,KAEAD,uNCJX,SAASE,KAET,IAAMC,GACJlM,MAAOiM,EACPE,MAAOF,EACPG,IAAKH,EACLI,KAAMJ,EACNK,KAAML,EACNhN,MAAOgN,GAGLM,EAAiBL,EAgBrB,IAAMM,EAASV,IAgBf,SAASW,EAAuBC,GAA2B,QAAAC,EAAAxN,UAAAD,OAAX0N,EAAWrN,MAAAoN,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAXD,EAAWC,EAAA,GAAA1N,UAAA0N,GACzDD,EAAUE,QAAQ,SAAUnO,GAC1B4N,EAAe5N,GAAQ+N,EAAY/N,GAAQ+N,EAAY/N,GAAMvB,KAAKsP,GAhBtE,SAAyB/N,GACvB,IAAMoO,EAAOP,EAAOzM,QAAQpB,GAC5B,OAAIoO,EACK,WAAmB,QAAAC,EAAA7N,UAAAD,OAANH,EAAMQ,MAAAyN,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANlO,EAAMkO,GAAA9N,UAAA8N,GACpBlO,EAAK,KACPA,EAAK,GAZb,SAAoBJ,EAAMuO,GAExB,OADAA,EAAM,IAAMvO,EAAO,OAASuO,EAWZC,CAAUxO,EAAMI,EAAK,KAGjCgO,EAAKtN,MAAM+M,EAAOzM,QAAShB,IAGxBkN,EAK4EmB,CAAezO,KAI7F,IAuBI0O,EAASd,EC9DpB,IAAMC,EAASV,IAuFAwB,aApFb,SAAAA,EAAaC,EAAUC,GAA4C,IAAAC,GAAAtO,UAAAD,OAAA,QAAAlB,IAAAmB,UAAA,GAAAA,UAAA,OAAlC4K,0BAAkC/L,IAAAyP,KAMjE,+FANiEC,CAAA7P,KAAAyP,GACjEzP,KAAK8P,YAAa,EAClB9P,KAAK0P,SAAWA,EAChB1P,KAAK2P,OAASA,EACd3P,KAAKkM,mBAAqBA,EAEtBA,EACF,IACE,IAAM6D,EAAgBpB,EAAOqB,OACzBD,IACF/P,KAAK6I,OAASkH,EAAclH,QAAUkH,EAAcE,cAEtD,MAAOC,IAEXlQ,KAAKmQ,kBAAoBnQ,KAAK6I,0BAGhCuH,kBACE,OAAQpQ,KAAKmQ,kBAAoBnQ,KAAK2P,OAAOU,+BAG/CpH,iBAASC,EAAM5J,EAAKwJ,EAAIwH,GAAU,IAAAC,EAAAvQ,KAChC,GAAIA,KAAKmQ,kBAAoBnQ,KAAK2P,OAAOU,kBAAmB,CACtDrQ,KAAK8P,aACPN,EAAOjB,IAAI,kBACXvO,KAAK8P,YAAa,GAEpB,IAAIU,EAAYxQ,KAAKwQ,UAChBA,IACHxQ,KAAKwQ,UAAYA,EAAY,IAAIjH,GAGnCiH,EAAUnH,UAAU/J,GACpBgR,EAASE,EAAUvH,QAAQC,EAAM,EAAGJ,EAAI9I,KAAKkM,yBACxC,CACDlM,KAAK8P,aACPN,EAAOjB,IAAI,yBACXvO,KAAK8P,YAAa,GAEpB,IAAMjH,EAAS7I,KAAK6I,OAChB7I,KAAKV,MAAQA,IACfU,KAAKV,IAAMA,EACXU,KAAKyQ,WAAa,IAAItH,EAAWN,EAAQvJ,IAG3CU,KAAKyQ,WAAWpH,YACbqH,KAAK,SAACC,GAEQ,IAAI/H,EAAUC,EAAQC,GAC5BG,QAAQC,EAAMyH,GAClBC,MAAM,SAACpP,GACN+O,EAAKM,iBAAiBrP,EAAK0H,EAAM5J,EAAKwJ,EAAIwH,KAE3CI,KAAK,SAACI,GACLR,EAASQ,OAGdF,MAAM,SAACpP,GACN+O,EAAKM,iBAAiBrP,EAAK0H,EAAM5J,EAAKwJ,EAAIwH,mBAKlDO,0BAAkBrP,EAAK0H,EAAM5J,EAAKwJ,EAAIwH,GAChCtQ,KAAK2P,OAAOU,mBACdb,EAAOjB,IAAI,0CACXvO,KAAKmQ,kBAAmB,EACxBnQ,KAAK8P,YAAa,EAClB9P,KAAKiJ,QAAQC,EAAM5J,EAAKwJ,EAAIwH,KAE5Bd,EAAOpO,MAAP,sBAAmCI,EAAIuP,SACvC/Q,KAAK0P,SAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWE,YAAawK,QAASpK,EAAaiB,mBAAoBoJ,OAAO,EAAMC,OAAQ5P,EAAIuP,wBAI1I/C,mBACE,IAAIwC,EAAYxQ,KAAKwQ,UACjBA,IACFA,EAAUxC,UACVhO,KAAKwQ,eAAYrQ,SC9FVkR,EAAiBC,OAAOC,UAAY,SAAUvS,GACzD,MAAwB,iBAAVA,GAAsBuS,SAASvS,ICqIxC,SAASwS,EAAiBtI,EAAMoC,GACrC,OAAwB,MAAjBpC,EAAKoC,IAAkD,MAAV,IAAnBpC,EAAKoC,EAAS,IAG1C,SAASmG,EAAiBvI,EAAMoC,GACrC,OAA2B,EAAnBpC,EAAKoC,EAAS,GAAY,EAAI,EAGjC,SAASoG,EAAoBxI,EAAMoC,GACxC,OAA4B,EAAnBpC,EAAKoC,EAAS,KAAc,GAClCpC,EAAKoC,EAAS,IAAM,GACA,IAAnBpC,EAAKoC,EAAS,MAAe,EAG5B,SAASqG,EAAUzI,EAAMoC,GAI9B,SAAIA,EAAS,EAAIpC,EAAK7H,QAAUmQ,EAAgBtI,EAAMoC,IAOjD,SAASsG,EAAO1I,EAAMoC,GAG3B,GAAIA,EAAS,EAAIpC,EAAK7H,QAAUmQ,EAAgBtI,EAAMoC,GAAS,CAE7D,IAEIuG,EAFeJ,EAAgBvI,EAAMoC,GAGrCA,EAAS,EAAIpC,EAAK7H,SACpBwQ,EAAcH,EAAmBxI,EAAMoC,IAGzC,IAAIwG,EAAYxG,EAASuG,EACzB,GAAIC,IAAc5I,EAAK7H,QAAWyQ,EAAY,EAAI5I,EAAK7H,QAAUmQ,EAAgBtI,EAAM4I,GACrF,OAAO,EAGX,OAAO,EAGF,SAASC,EAAiBC,EAAOtC,EAAUxG,EAAMoC,EAAQ2G,GAC9D,IAAKD,EAAME,WAAY,CACrB,IAAIvC,EA3KD,SAAyBD,EAAUxG,EAAMoC,EAAQ2G,GACtD,IACEE,EADEC,SAEFC,SACAC,SACA3C,SACA4C,EAAYC,UAAUD,UAAUE,cAChCC,EAAgBT,EAChBU,GACE,KAAO,MACP,KAAO,KACP,MAAO,KACP,KAAO,MACP,KAAO,KACP,MAAO,IACP,MAIJ,GAFAP,EAAqD,IAAf,IAAnBlJ,EAAKoC,EAAS,MAAe,MAChD6G,GAA0C,GAAnBjJ,EAAKoC,EAAS,MAAe,GAC3BqH,EAAmBtR,OAAS,GAsGrD,OAlGAiR,GAAwC,EAAnBpJ,EAAKoC,EAAS,KAAc,EAEjDgH,IAAyC,IAAnBpJ,EAAKoC,EAAS,MAAe,EACnDkE,EAAOjB,IAAP,kBAA6B0D,EAA7B,mBAA0DG,EAA1D,mBAA2FD,EAA3F,IAAiHQ,EAAmBR,GAApI,qBAA4KG,GAExK,WAAWM,KAAKL,GACdJ,GAAsB,GACxBC,EAAiB,EACjBzC,EAAS,IAAIjO,MAAM,GAInB2Q,EAA8BF,EAAqB,IAEnDC,EAAiB,EACjBzC,EAAS,IAAIjO,MAAM,GACnB2Q,EAA8BF,IAGW,IAAlCI,EAAUM,QAAQ,YAC3BT,EAAiB,EACjBzC,EAAS,IAAIjO,MAAM,GACnB2Q,EAA8BF,IAK9BC,EAAiB,EACjBzC,EAAS,IAAIjO,MAAM,GAEduQ,KAAsD,IAAtCA,EAAWY,QAAQ,gBACA,IAArCZ,EAAWY,QAAQ,gBAClBZ,GAAcE,GAAsB,EAItCE,EAA8BF,EAAqB,IAI/CF,IAAmD,IAArCA,EAAWY,QAAQ,eAAyBV,GAAsB,GAA0B,IAArBG,GACnF,WAAWM,KAAKL,MAClBN,GAAmC,IAArBK,KAChBF,EAAiB,EACjBzC,EAAS,IAAIjO,MAAM,IAErB2Q,EAA8BF,IAqClCxC,EAAO,GAAKyC,GAAkB,EAE9BzC,EAAO,KAA4B,GAArBwC,IAA8B,EAC5CxC,EAAO,KAA4B,EAArBwC,IAA8B,EAE5CxC,EAAO,IAAM2C,GAAoB,EACV,IAAnBF,IAEFzC,EAAO,KAAqC,GAA9B0C,IAAuC,EACrD1C,EAAO,IAAoC,EAA9B0C,IAAuC,EAGpD1C,EAAO,IAAM,EACbA,EAAO,GAAK,IAELA,OAAQA,EAAQuC,WAAYS,EAAmBR,GAAqBW,aAAcR,EAAkBS,MAAQ,WAAaX,EAAiBM,cAAeA,GArGhKhD,EAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWE,YAAawK,QAASpK,EAAakB,mBAAoBmJ,OAAO,EAAMC,sCAAuCe,IAuJ/Ia,CAAetD,EAAUxG,EAAMoC,EAAQ2G,GACpDD,EAAMrC,OAASA,EAAOA,OACtBqC,EAAME,WAAavC,EAAOuC,WAC1BF,EAAMc,aAAenD,EAAOmD,aAC5Bd,EAAMe,MAAQpD,EAAOoD,MACrBf,EAAMU,cAAgB/C,EAAO+C,cAC7BlD,EAAOjB,IAAP,gBAA2ByD,EAAMe,MAAjC,SAA+CpD,EAAOuC,WAAtD,eAA+EvC,EAAOmD,eAInF,SAASG,EAAkBf,GAChC,OAAO,OAAeA,EAsBjB,SAASgB,EAAalB,EAAO9I,EAAMoC,EAAQ6H,EAAKC,GACrD,IACIC,EArBC,SAA2BnK,EAAMoC,EAAQ6H,EAAKC,EAAYE,GAC/D,IAAIC,EAAc1B,SACdxQ,EAAS6H,EAAK7H,OAQlB,GALAkS,EAAe9B,EAAgBvI,EAAMoC,GAErCuG,EAAcH,EAAmBxI,EAAMoC,IACvCuG,GAAe0B,GAEI,GAAQjI,EAASiI,EAAe1B,GAAgBxQ,EAGjE,OAASkS,eAAc1B,cAAa2B,MAF5BL,EAAMC,EAAaE,GAUhBG,CAAiBvK,EAAMoC,EAAQ6H,EAAKC,EAD7BH,EAAiBjB,EAAME,aAE3C,GAAImB,EAAQ,CACV,IAAIG,EAAQH,EAAOG,MACfD,EAAeF,EAAOE,aACtB1B,EAAcwB,EAAOxB,YAGrB6B,GACFC,KAAMzK,EAAK0K,SAAStI,EAASiI,EAAcjI,EAASiI,EAAe1B,GACnEsB,IAAKK,EACLK,IAAKL,GAMP,OAHAxB,EAAM8B,QAAQ9R,KAAK0R,GACnB1B,EAAM/Q,KAAO4Q,GAEJkC,OAAQL,EAAWrS,OAAQwQ,EAAc0B,QCrOhDS,yIAOGrC,kBAAUzI,EAAMoC,GAcrB,OAAIA,EAAS,IAAMpC,EAAK7H,QAED,KAAjB6H,EAAKoC,IAAyC,KAArBpC,EAAKoC,EAAS,IAAoC,KAArBpC,EAAKoC,EAAS,IAElEpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,KAE5CpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,OAgBzG2I,kBAAU/K,EAAMoC,GAIrB,OAAIA,EAAS,IAAMpC,EAAK7H,QAED,KAAjB6H,EAAKoC,IAAyC,KAArBpC,EAAKoC,EAAS,IAAoC,KAArBpC,EAAKoC,EAAS,IAElEpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,KAE5CpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,KAAQpC,EAAKoC,EAAS,GAAK,OAgBzG4I,oBAAYhL,EAAMoC,GAIvB,IAHA,IAAM6I,EAAQ7I,EACVjK,EAAS,EAEN2S,EAAIrC,SAASzI,EAAMoC,IAAS,CAEjCjK,GAAU,GAGVA,GADa2S,EAAII,UAAUlL,EAAMoC,EAAS,GAGtC0I,EAAIC,SAAS/K,EAAMoC,EAAS,MAE9BjK,GAAU,IAGZiK,GAAUjK,EAGZ,GAAIA,EAAS,EACX,OAAO6H,EAAK0K,SAASO,EAAOA,EAAQ9S,MAMjC+S,mBAAWlL,EAAMoC,GACtB,IAAI+I,EAAO,EAKX,OAJAA,GAAwB,IAAfnL,EAAKoC,KAAmB,GACjC+I,IAA6B,IAAnBnL,EAAKoC,EAAS,KAAc,GACtC+I,IAA6B,IAAnBnL,EAAKoC,EAAS,KAAc,EACtC+I,GAA4B,IAAnBnL,EAAKoC,EAAS,MASlBgJ,sBAAcpL,GAEnB,IADA,IAAMqL,EAASP,EAAIQ,aAAatL,GACvBnL,EAAI,EAAGA,EAAIwW,EAAOlT,OAAQtD,IAAK,CACtC,IAAM0W,EAAQF,EAAOxW,GACrB,GAAIiW,EAAIU,iBAAiBD,GACvB,OAAOT,EAAIW,eAAeF,OAWzBC,0BAAkBD,GACvB,OAAQA,GAAuB,SAAdA,EAAMnV,KAAiC,iDAAfmV,EAAMhG,QAG1CmG,uBAAe1L,GAMpB,IAAMpI,EAAO+T,OAAOC,aAAa5L,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAC3DmL,EAAOL,EAAII,UAAUlL,EAAM,GAKjC,OAASpI,OAAMuT,OAAMnL,KAAMA,EAAK0K,SAFnB,MAE6CS,OAQrDG,sBAAcO,GAInB,IAHA,IAAIzJ,EAAS,EACPiJ,KAECP,EAAIrC,SAASoD,EAASzJ,IAAS,CAMpC,IALA,IAAM+I,EAAOL,EAAII,UAAUW,EAASzJ,EAAS,GAGvC0J,GADN1J,GAAU,IACW+I,EAEd/I,EAAS,EAAI0J,GAAK,CACvB,IAAMC,EAAYjB,EAAIY,cAAcG,EAAQnB,SAAStI,IAC/CmJ,EAAQT,EAAIkB,aAAaD,GAC3BR,GACFF,EAAOvS,KAAKyS,GAIdnJ,GAAU2J,EAAUZ,KAAO,GAGzBL,EAAIC,SAASc,EAASzJ,KACxBA,GAAU,IAId,OAAOiJ,KAGFW,sBAAcT,GACnB,MAAmB,SAAfA,EAAM3T,KACDkT,EAAImB,iBAAiBV,GACD,MAAlBA,EAAM3T,KAAK,GACbkT,EAAIoB,iBAAiBX,GACD,MAAlBA,EAAM3T,KAAK,GACbkT,EAAIqB,gBAAgBZ,QADtB,KAOFE,wBAAgBW,GACrB,GAAuC,IAAnCA,EAAepM,KAAK0E,WAAkB,CACxC,IAAM1E,EAAO,IAAIqM,WAAWD,EAAepM,MAGrCsM,EAAqB,EAAVtM,EAAK,GAClBuM,GAAavM,EAAK,IAAM,KACXA,EAAK,IAAM,KACXA,EAAK,IAAM,GACXA,EAAK,GAOtB,OANAuM,GAAa,GAETD,IACFC,GAAa,aAGRC,KAAKC,MAAMF,OAMfN,0BAAkBV,GAIvB,KAAIA,EAAMJ,KAAO,GAAjB,CAIA,IAAMuB,EAAQ5B,EAAI6B,gBAAgBpB,EAAMvL,MAAM,GACxC4M,EAAc,IAAIP,WAAWd,EAAMvL,KAAK0K,SAASgC,EAAMvU,OAAS,IAEtE,OAAS/B,IAAKmV,EAAM3T,KAAM2N,KAAMmH,EAAO1M,KAAM4M,EAAYpI,YAGpD0H,0BAAkBX,GACvB,KAAIA,EAAMJ,KAAO,GAAjB,CAIA,GAAmB,SAAfI,EAAM3T,KAAiB,CAMzB,IAAIiV,EAAQ,EACNC,EAAchC,EAAI6B,gBAAgBpB,EAAMvL,KAAK0K,SAASmC,IAE5DA,GAASC,EAAY3U,OAAS,EAC9B,IAAMrC,EAAQgV,EAAI6B,gBAAgBpB,EAAMvL,KAAK0K,SAASmC,IAEtD,OAASzW,IAAKmV,EAAM3T,KAAM2N,KAAMuH,EAAa9M,KAAMlK,GAOnD,IAAMiX,EAAOjC,EAAI6B,gBAAgBpB,EAAMvL,KAAK0K,SAAS,IACrD,OAAStU,IAAKmV,EAAM3T,KAAMoI,KAAM+M,OAI7BZ,yBAAiBZ,GACtB,GAAmB,SAAfA,EAAM3T,KAAiB,CAMzB,GAAI2T,EAAMJ,KAAO,EACf,OAGF,IAAI0B,EAAQ,EACNC,EAAchC,EAAI6B,gBAAgBpB,EAAMvL,KAAK0K,SAASmC,IAE5DA,GAASC,EAAY3U,OAAS,EAC9B,IAAMrC,EAAQgV,EAAI6B,gBAAgBpB,EAAMvL,KAAK0K,SAASmC,IAEtD,OAASzW,IAAKmV,EAAM3T,KAAM2N,KAAMuH,EAAa9M,KAAMlK,GAMnD,IAAMkX,EAAMlC,EAAI6B,gBAAgBpB,EAAMvL,MACtC,OAAS5J,IAAKmV,EAAM3T,KAAMoI,KAAMgN,MAa7BL,yBAAiBM,GAOtB,IAPiD,IAApBC,EAAoB9U,UAAAD,OAAA,QAAAlB,IAAAmB,UAAA,IAAAA,UAAA,GAC3CL,EAAMkV,EAAM9U,OACdjD,SACAiY,SACAC,SACAC,EAAM,GACNxY,EAAI,EACDA,EAAIkD,GAAK,CAEd,GAAU,KADV7C,EAAI+X,EAAMpY,OACQqY,EAChB,OAAOG,EACF,GAAU,IAANnY,GAAoB,IAANA,EAIzB,OAAQA,GAAK,GACb,KAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,EAE3DmY,GAAO1B,OAAOC,aAAa1W,GAC3B,MACF,KAAK,GAAI,KAAK,GAEZiY,EAAQF,EAAMpY,KACdwY,GAAO1B,OAAOC,cAAmB,GAAJ1W,IAAa,EAAc,GAARiY,GAChD,MACF,KAAK,GAEHA,EAAQF,EAAMpY,KACduY,EAAQH,EAAMpY,KACdwY,GAAO1B,OAAOC,cAAmB,GAAJ1W,IAAa,IACpB,GAARiY,IAAiB,GACT,GAARC,IAAiB,IAKnC,OAAOC,QAMIvC,GAFQA,EAAI6B,gBAEZ7B,OCtPAwC,aAnFb,SAAAA,EAAa9G,EAAU+G,EAAS9G,gGAAQ+G,CAAA1W,KAAAwW,GACtCxW,KAAK0P,SAAWA,EAChB1P,KAAK2P,OAASA,EACd3P,KAAKyW,QAAUA,qBAGjBE,0BAAkBC,EAAa3E,EAAY4E,EAAYC,GACrD9W,KAAK+W,aAAgBC,UAAW,aAAclW,KAAM,QAASmW,GAAI,EAAGC,eAAgB,EAAGC,OAAO,EAAMrD,WAAa7S,IAAK,EAAGyR,cAAeT,EAAY6E,SAAUA,EAAUM,eAAgB,kBAG1LC,8BAIOzF,eAAO1I,GACZ,IAAKA,EACH,OAAO,EAUT,IAHA,IACIoC,GADY0I,EAAIE,WAAWhL,EAAM,QAChB7H,OAEZA,EAAS6H,EAAK7H,OAAQiK,EAASjK,EAAQiK,IAC9C,GAAIgM,EAAWpO,EAAMoC,GAEnB,OADAkE,EAAOjB,IAAI,2BACJ,EAGX,OAAO,eAITgJ,gBAAQrO,EAAMsO,EAAYC,EAAYC,GAYpC,IAXA,IAAI1F,EAAQhS,KAAK+W,YACbhC,EAAUf,EAAIE,WAAWhL,EAAM,OAC/BuM,EAAYzB,EAAIM,aAAaS,GAC7B5B,EAAM9B,EAAgBoE,GAAyB,GAAZA,EAA8B,IAAb+B,EACpDpE,EAAa,EACbI,EAAQL,EACR9R,EAAS6H,EAAK7H,OACdiK,EAASyJ,EAAQ1T,OAEjBsW,IAAgBxE,IAAKK,EAAOK,IAAKL,EAAOtK,KAAM6L,IAE3CzJ,EAASjK,EAAS,GACvB,GAAIiW,EAAcpO,EAAMoC,IAAYA,EAAS,EAAKjK,EAAQ,CACxDiW,EAAqBtF,EAAOhS,KAAK0P,SAAUxG,EAAMoC,EAAQ0G,EAAMU,eAC/D,IAAI+B,EAAQ6C,EAAiBtF,EAAO9I,EAAMoC,EAAQ6H,EAAKC,GACvD,IAAIqB,EAIG,CACLjF,EAAOjB,IAAI,6BACX,MALAjD,GAAUmJ,EAAMpT,OAChBmS,EAAQiB,EAAMV,OAAOZ,IACrBC,SAKOY,EAAIrC,SAASzI,EAAMoC,IAC5ByJ,EAAUf,EAAIE,WAAWhL,EAAMoC,GAC/BqM,EAAW3V,MAAOmR,IAAKK,EAAOK,IAAKL,EAAOtK,KAAM6L,IAChDzJ,GAAUyJ,EAAQ1T,QAGlBiK,IAIJtL,KAAKyW,QAAQmB,MAAM5F,GACf8B,aACAA,QAAS6D,EAAYP,eAAgB,MACrCtD,YACF0D,EACAC,EACAC,gBAGJ1J,0BCjFF,IAAM6J,EAAanC,KAAKoC,IAAI,EAAG,IAAM,EAwYtBC,aArYb,SAAAA,EAAarI,EAAU+G,gGAASuB,CAAAhY,KAAA+X,GAC9B/X,KAAK0P,SAAWA,EAChB1P,KAAKyW,QAAUA,qBAGjBY,wBAAgBY,GACdjY,KAAKiY,QAAUA,eAGjBtB,0BAAkBC,EAAa3E,EAAY4E,EAAYC,GAErD,GAAIF,GAAeA,EAAYhJ,WAAY,CACzC,IAAMsK,EAAWlY,KAAKkY,SAAWH,EAAWI,iBAAiBvB,GAI3C,MAAd3E,IACFA,EAAa,aAGG,MAAd4E,IACFA,EAAa,eAGf,IAAMuB,KACFF,EAASG,OAASH,EAASI,MAC7BF,EAAOG,YAAevB,UAAW,YAAajE,MAAOd,EAAa,IAAM4E,EAAYD,YAAaE,EAAWF,EAAc,OAEtHsB,EAASG,QACXD,EAAOC,OAAUrB,UAAW,YAAajE,MAAOd,EAAY2E,YAAaE,EAAWF,EAAc,OAGhGsB,EAASI,QACXF,EAAOE,OAAUtB,UAAW,YAAajE,MAAO8D,EAAYD,YAAaE,EAAWF,EAAc,QAGtG5W,KAAK0P,SAASsB,QAAQC,EAAMvL,2BAA6B0S,gBAErDnG,IACFjS,KAAKiS,WAAaA,GAGhB4E,IACF7W,KAAK6W,WAAaA,MAKjBjF,eAAO1I,GAEZ,OAAO6O,EAAWS,SAAUtP,KAAMA,EAAMuP,MAAO,EAAGzD,IAAKU,KAAKgD,IAAIxP,EAAK7H,OAAQ,SAAW,SAASA,OAAS,KAGrGsX,iBAASjL,GACd,OAAOmH,OAAOC,aAAalT,MAAM,KAAM8L,MAGlCkL,oBAAYlL,EAAQpC,GACrBoC,EAAOxE,OACToC,GAAUoC,EAAO+K,MACjB/K,EAASA,EAAOxE,MAGlB,IAAM2P,EAAMnL,EAAOpC,IAAW,EAClBoC,EAAOpC,EAAS,GAE5B,OAAOuN,EAAM,EAAI,MAAQA,EAAMA,KAG1BC,oBAAYpL,EAAQpC,GACrBoC,EAAOxE,OACToC,GAAUoC,EAAO+K,MACjB/K,EAASA,EAAOxE,MAGlB,IAAM2P,EAAMnL,EAAOpC,IAAW,GAClBoC,EAAOpC,EAAS,IAAM,GACtBoC,EAAOpC,EAAS,IAAM,EACtBoC,EAAOpC,EAAS,GAC5B,OAAOuN,EAAM,EAAI,WAAaA,EAAMA,KAG/BE,qBAAarL,EAAQpC,EAAQtM,GAC9B0O,EAAOxE,OACToC,GAAUoC,EAAO+K,MACjB/K,EAASA,EAAOxE,MAElBwE,EAAOpC,GAAUtM,GAAS,GAC1B0O,EAAOpC,EAAS,GAAMtM,GAAS,GAAM,IACrC0O,EAAOpC,EAAS,GAAMtM,GAAS,EAAK,IACpC0O,EAAOpC,EAAS,GAAa,IAARtM,KAIhBwZ,iBAAStP,EAAM8P,GACpB,IAAIC,KACFlb,SAAGsW,SAAMvT,SAAMkU,SAAKkE,SAAYT,SAAOU,SAWzC,GATIjQ,EAAKA,MACPuP,EAAQvP,EAAKuP,MACbzD,EAAM9L,EAAK8L,IACX9L,EAAOA,EAAKA,OAEZuP,EAAQ,EACRzD,EAAM9L,EAAK0E,aAGRoL,EAAK3X,OAER,OAAO,KAGT,IAAKtD,EAAI0a,EAAO1a,EAAIiX,GAClBX,EAAO0D,EAAWe,WAAW5P,EAAMnL,GACnC+C,EAAOiX,EAAWY,QAAQzP,EAAK0K,SAAS7V,EAAI,EAAGA,EAAI,IACnDob,EAAS9E,EAAO,EAAItW,EAAIsW,EAAOW,EAE3BlU,IAASkY,EAAK,KACI,IAAhBA,EAAK3X,OAGP4X,EAAQjX,MAAOkH,KAAMA,EAAMuP,MAAO1a,EAAI,EAAGiX,IAAKmE,KAG9CD,EAAanB,EAAWS,SAAUtP,KAAMA,EAAMuP,MAAO1a,EAAI,EAAGiX,IAAKmE,GAAUH,EAAKrX,MAAM,KACvEN,SACb4X,EAAUA,EAAQG,OAAOF,KAI/Bnb,EAAIob,EAIN,OAAOF,KAGFI,2BAAmBzC,GACxB,IAAM0C,EAAOvB,EAAWS,QAAQ5B,GAAc,SAAS,GACjD2C,EAAgBD,EAAOA,EAAKtE,IAAM,KAEpCe,EAAQ,EACRyD,EAAOzB,EAAWS,QAAQ5B,GAAc,SACxC6C,SAEJ,IAAKD,IAASA,EAAK,GACjB,OAAO,KAGTC,KAGA,IAAMC,GAFNF,EAAOA,EAAK,IAEStQ,KAAK,GAG1B6M,EAAoB,IAAZ2D,EAAgB,EAAI,GAE5B,IAAMC,EAAY5B,EAAWe,WAAWU,EAAMzD,GAC9CA,GAAS,EAQPA,GADc,IAAZ2D,EACO,EAEA,GAIX3D,GAAS,EAET,IAAI6D,EAAYJ,EAAKxE,IAXH,EAaZ6E,EAAkB9B,EAAWa,WAAWY,EAAMzD,GACpDA,GAAS,EAET,IAAK,IAAIhY,EAAI,EAAGA,EAAI8b,EAAiB9b,IAAK,CACxC,IAAI+b,EAAiB/D,EAEfgE,EAAgBhC,EAAWe,WAAWU,EAAMM,GAClDA,GAAkB,EAElB,IAAME,EAAgC,WAAhBD,EAGtB,GAAsB,KAFiB,WAAhBA,KAAgC,GAIrD,YADA7X,QAAQsM,KAAK,oDAIf,IAAMyL,EAAqBlC,EAAWe,WAAWU,EAAMM,GACvDA,GAAkB,EAElBL,EAAWzX,MACTgY,gBACAC,qBACAxL,MACEqI,SAAUmD,EAAqBN,EAC/BlB,MAAOmB,EACP5E,IAAK4E,EAAYI,EAAgB,KAIrCJ,GAAaI,EAObjE,EAHA+D,GAAkB,EAMpB,OACEI,yBAvD6B,EAwD7BP,YACAD,UACAG,kBACAJ,aACAF,oBAuBGpB,0BAAkBvB,GACvB,IAAI9F,KAmCJ,OAlCYiH,EAAWS,QAAQ5B,GAAc,OAAQ,SAE/C3H,QAAQ,SAAAkL,GACZ,IAAMC,EAAOrC,EAAWS,QAAQ2B,GAAO,SAAS,GAChD,GAAIC,EAAM,CACR,IAAIV,EAAUU,EAAKlR,KAAKkR,EAAK3B,OACzB1C,EAAoB,IAAZ2D,EAAgB,GAAK,GAC7BW,EAAUtC,EAAWe,WAAWsB,EAAMrE,GAEpCuE,EAAOvC,EAAWS,QAAQ2B,GAAO,OAAQ,SAAS,GACxD,GAAIG,EAAM,CAERvE,EAAoB,KADpB2D,EAAUY,EAAKpR,KAAKoR,EAAK7B,QACD,GAAK,GAC7B,IAAMkB,EAAY5B,EAAWe,WAAWwB,EAAMvE,GAExCwE,EAAOxC,EAAWS,QAAQ2B,GAAO,OAAQ,SAAS,GACxD,GAAII,EAAM,CACR,IACIzZ,GAAS0Z,KAAQ,QAASC,KAAQ,SADrB1C,EAAWY,QAAQ4B,EAAKrR,KAAK0K,SAAS2G,EAAK9B,MAAQ,EAAG8B,EAAK9B,MAAQ,MAEpF,GAAI3X,EAAM,CAER,IAAI4Z,EAAW3C,EAAWS,QAAQ2B,GAAO,OAAQ,OAAQ,OAAQ,SACjE,GAAIO,EAASrZ,OAAQ,CACnBqZ,EAAWA,EAAS,GACpB,IAAIC,EAAY5C,EAAWY,QAAQ+B,EAASxR,KAAK0K,SAAS8G,EAASjC,MAAQ,GAAIiC,EAASjC,MAAQ,KAChGjJ,EAAOjB,IAAP,cAAyBzN,EAAzB,IAAiC6Z,EAAjC,UAEF7J,EAAOuJ,IAAaV,UAAWA,EAAW7Y,KAAMA,GAChDgQ,EAAOhQ,IAAU6Y,UAAWA,EAAW1C,GAAIoD,SAM9CvJ,KAmBF8J,qBAAa1C,EAAU2C,GAC5B,IAAWC,EAAWhK,EAAlBiK,SAmCJ,OAhCAA,EAAQhD,EAAWS,QAAQqC,GAAW,OAAQ,SAG9CC,KAAe1B,OAAOxX,SAAUmZ,EAAMC,IAAI,SAAUC,GAClD,OAAOlD,EAAWS,QAAQyC,GAAO,SAASD,IAAI,SAAUE,GACtD,IAAIjE,EAAIkE,EAqBR,OAlBAlE,EAAKc,EAAWe,WAAWoC,EAAM,GAEjCC,EAAQjD,EAASjB,GAAI0C,WAAa,IAGvB5B,EAAWS,QAAQyC,GAAO,SAASD,IAAI,SAAUI,GAC1D,IAAI1B,EAAS5I,SASb,OAPA4I,EAAU0B,EAAKlS,KAAKkS,EAAK3C,OACzB3H,EAASiH,EAAWe,WAAWsC,EAAM,GACrB,IAAZ1B,IACF5I,GAAU4E,KAAKoC,IAAI,EAAG,IAEtBhH,GAAUiH,EAAWe,WAAWsC,EAAM,IAEjCtK,IACN,GAEeqK,OAKtBrK,EAAS4E,KAAKgD,IAAI9W,MAAM,KAAMkZ,GACvBvJ,SAAST,GAAUA,EAAS,KAG9BuK,wBAAgBnD,EAAU2C,EAAUrD,GACzCO,EAAWS,QAAQqC,GAAW,OAAQ,SAASG,IAAI,SAAUC,GAC3D,OAAOlD,EAAWS,QAAQyC,GAAO,SAASD,IAAI,SAAUE,GAEtD,IAAIjE,EAAKc,EAAWe,WAAWoC,EAAM,GAEjCvB,EAAYzB,EAASjB,GAAI0C,WAAa,IAG1C5B,EAAWS,QAAQyC,GAAO,SAASD,IAAI,SAAUI,GAC/C,IAAI1B,EAAU0B,EAAKlS,KAAKkS,EAAK3C,OACzB6C,EAAsBvD,EAAWe,WAAWsC,EAAM,GACtD,GAAgB,IAAZ1B,EACF3B,EAAWgB,YAAYqC,EAAM,EAAGE,EAAsB9D,EAAamC,OAC9D,CACL2B,GAAuB5F,KAAKoC,IAAI,EAAG,IACnCwD,GAAuBvD,EAAWe,WAAWsC,EAAM,GACnDE,GAAuB9D,EAAamC,EACpC2B,EAAsB5F,KAAK6F,IAAID,EAAqB,GACpD,IAAME,EAAQ9F,KAAK+F,MAAMH,GAAuBzD,EAAa,IACvD6D,EAAQhG,KAAK+F,MAAMH,GAAuBzD,EAAa,IAC7DE,EAAWgB,YAAYqC,EAAM,EAAGI,GAChCzD,EAAWgB,YAAYqC,EAAM,EAAGM,uBAQ1CnE,gBAAQrO,EAAMsO,EAAYC,EAAYC,GACpC,IAAIQ,EAAWlY,KAAKkY,SACfA,IACHlY,KAAK2W,iBAAiBzN,EAAMlJ,KAAKiS,WAAYjS,KAAK6W,YAAY,GAC9DqB,EAAWlY,KAAKkY,UAElB,IAAIyD,EAAU1D,EAAUjY,KAAKiY,QAC7B,QAAgB9X,IAAZ8X,EAAuB,CACzB,IAAI0D,EAAW5D,EAAW6C,YAAY1C,EAAUhP,GAChDlJ,KAAKiY,QAAUA,EAAU0D,EAAWnE,EACpCxX,KAAK0P,SAASsB,QAAQC,EAAM7L,gBAAkB6S,QAASA,IAEzDF,EAAWsD,eAAenD,EAAUhP,EAAM+O,GAC1C0D,EAAW5D,EAAW6C,YAAY1C,EAAUhP,GAC5ClJ,KAAKyW,QAAQmB,MAAMM,EAASG,MAAOH,EAASI,MAAO,KAAM,KAAMqD,EAAUlE,EAAYC,EAAoBxO,gBAG3G8E,0BCvYI4N,GAEJC,aACE,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC9D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC3D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC1D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC3D,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,KAExDC,iBAAkB,MAAO,KAAO,KAAO,MAAO,KAAO,KAAO,MAAO,KAAO,KAE1EC,sBAGI,EACA,GACA,IACA,KAIA,EACA,EACA,EACA,IAIA,EACA,GACA,IACA,KAIA,EACA,IACA,IACA,KAIJC,aACE,EACA,EACA,EACA,GAGF9I,YAAa,SAAUlB,EAAO9I,EAAMoC,EAAQ6H,EAAKC,GAE/C,KAAI9H,EAAS,GAAKpC,EAAK7H,QAAvB,CAIA,IAAIgS,EAASrT,KAAKic,YAAY/S,EAAMoC,GACpC,GAAI+H,GAAU/H,EAAS+H,EAAOxB,aAAe3I,EAAK7H,OAAQ,CACxD,IACImS,EAAQL,EAAMC,GAD2B,IAAzBC,EAAO6I,gBAA0B7I,EAAO8I,YAExDpI,GAAWJ,KAAMzK,EAAK0K,SAAStI,EAAQA,EAAS+H,EAAOxB,aAAcsB,IAAKK,EAAOK,IAAKL,GAQ1F,OANAxB,EAAMrC,UACNqC,EAAMc,aAAeO,EAAOP,aAC5Bd,EAAME,WAAamB,EAAO8I,WAC1BnK,EAAM8B,QAAQ9R,KAAK+R,GACnB/B,EAAM/Q,KAAOoS,EAAOxB,aAEXkC,SAAQ1S,OAAQgS,EAAOxB,gBAMpCoK,YAAa,SAAU/S,EAAMoC,GAC3B,IAAI8Q,EAAWlT,EAAKoC,EAAS,IAAM,EAAK,EACpC+Q,EAAWnT,EAAKoC,EAAS,IAAM,EAAK,EACpCgR,EAAWpT,EAAKoC,EAAS,IAAM,EAAK,GACpCiR,EAAWrT,EAAKoC,EAAS,IAAM,EAAK,EACpCkR,EAAWtT,EAAKoC,EAAS,IAAM,EAAK,EACxC,GAAgB,IAAZ8Q,GAA6B,IAAZE,GAA6B,KAAZA,GAA8B,IAAZC,EAAe,CACrE,IAAIE,EAA+B,IAAZL,EAAiB,EAAIC,EAAwB,IAAZA,EAAgB,EAAI,EACxEK,EAAuE,IAA7Dd,EAAUC,YAA+B,GAAnBY,EAAwBH,EAAU,GAClEK,EAAkC,IAAZP,EAAgB,EAAgB,IAAZA,EAAgB,EAAI,EAC9DD,EAAaP,EAAUE,gBAAsC,EAAtBa,EAA0BJ,GACjEzJ,EAAe5J,EAAKoC,EAAS,IAAM,GAAM,EAAI,EAAI,EACjDsR,EAAoBhB,EAAUG,oBAAoBK,GAASC,GAC3DQ,EAAcjB,EAAUI,YAAYK,GACpCH,EAAsC,EAApBU,EAAwBC,EAG9C,OAASV,aAAYrJ,eAAcjB,YAFjBiL,SAASF,EAAoBF,EAAUP,EAAaK,EAAS,IAAMK,EAErCX,qBAMpD1K,gBAAiB,SAAUtI,EAAMoC,GAC/B,OAAwB,MAAjBpC,EAAKoC,IAAkD,MAAV,IAAnBpC,EAAKoC,EAAS,KAAqD,IAAV,EAAnBpC,EAAKoC,EAAS,KAGvFqG,SAAU,SAAUzI,EAAMoC,GAIxB,SAAIA,EAAS,EAAIpC,EAAK7H,QAAUrB,KAAKwR,gBAAgBtI,EAAMoC,KAO7DsG,MAAO,SAAU1I,EAAMoC,GAGrB,GAAIA,EAAS,EAAIpC,EAAK7H,QAAUrB,KAAKwR,gBAAgBtI,EAAMoC,GAAS,CAElE,IAEI+H,EAASrT,KAAKic,YAAY/S,EAAMoC,GAChCuG,EAHe,EAIfwB,GAAUA,EAAOxB,cACnBA,EAAcwB,EAAOxB,aAGvB,IAAIC,EAAYxG,EAASuG,EACzB,GAAIC,IAAc5I,EAAK7H,QAAWyQ,EAAY,EAAI5I,EAAK7H,QAAUrB,KAAKwR,gBAAgBtI,EAAM4I,GAC1F,OAAO,EAGX,OAAO,IAII8J,QCwKAmB,aA1Sb,SAAAA,EAAa7T,gGAAM8T,CAAAhd,KAAA+c,GACjB/c,KAAKkJ,KAAOA,EAEZlJ,KAAKid,eAAiB/T,EAAK0E,WAE3B5N,KAAKgM,KAAO,EAEZhM,KAAKkd,cAAgB,qBAIvBC,oBACE,IACEjU,EAAOlJ,KAAKkJ,KACZ+T,EAAiBjd,KAAKid,eACtBva,EAAWwG,EAAK0E,WAAaqP,EAC7BG,EAAe,IAAI7H,WAAW,GAC9B8H,EAAiB3H,KAAKgD,IAAI,EAAGuE,GAC/B,GAAuB,IAAnBI,EACF,MAAM,IAAI9b,MAAM,sBAGlB6b,EAAaE,IAAIpU,EAAK0K,SAASlR,EAAUA,EAAW2a,IACpDrd,KAAKgM,KAAO,IAAI7B,SAASiT,EAAa1P,QAAQrD,UAAU,GAExDrK,KAAKkd,cAAiC,EAAjBG,EACrBrd,KAAKid,gBAAkBI,eAIzBE,kBAAUC,GACR,IAAIC,SACAzd,KAAKkd,cAAgBM,GACvBxd,KAAKgM,OAASwR,EACdxd,KAAKkd,eAAiBM,IAEtBA,GAASxd,KAAKkd,cAEdM,IADAC,EAAYD,GAAS,IACE,EACvBxd,KAAKid,gBAAkBQ,EACvBzd,KAAKmd,WACLnd,KAAKgM,OAASwR,EACdxd,KAAKkd,eAAiBM,gBAK1BE,kBAAUrJ,GACR,IACEsJ,EAAOjI,KAAKgD,IAAI1Y,KAAKkd,cAAe7I,GACpCuJ,EAAO5d,KAAKgM,OAAU,GAAK2R,EAa7B,OAZItJ,EAAO,IACT7E,EAAOpO,MAAM,2CAGfpB,KAAKkd,eAAiBS,EAClB3d,KAAKkd,cAAgB,EACvBld,KAAKgM,OAAS2R,EACL3d,KAAKid,eAAiB,GAC/Bjd,KAAKmd,YAGPQ,EAAOtJ,EAAOsJ,GACH,GAAK3d,KAAKkd,cACZU,GAAQD,EAAO3d,KAAK0d,SAASC,GAE7BC,eAKXC,kBACE,IAAIC,SACJ,IAAKA,EAAmB,EAAGA,EAAmB9d,KAAKkd,gBAAiBY,EAClE,GAAwD,IAAnD9d,KAAKgM,KAAQ,aAAe8R,GAI/B,OAFA9d,KAAKgM,OAAS8R,EACd9d,KAAKkd,eAAiBY,EACfA,EAKX,OADA9d,KAAKmd,WACEW,EAAmB9d,KAAK6d,sBAIjCE,mBACE/d,KAAKud,SAAS,EAAIvd,KAAK6d,uBAIzBG,kBACEhe,KAAKud,SAAS,EAAIvd,KAAK6d,uBAIzBI,mBACE,IAAIC,EAAMle,KAAK6d,SACf,OAAO7d,KAAK0d,SAASQ,EAAM,GAAK,eAIlCC,kBACE,IAAIP,EAAO5d,KAAKie,UAChB,OAAI,EAAOL,EAED,EAAIA,IAAU,GAEd,GAAKA,IAAS,gBAM1BQ,uBACE,OAA4B,IAArBpe,KAAK0d,SAAS,gBAIvBW,qBACE,OAAOre,KAAK0d,SAAS,gBAIvBY,sBACE,OAAOte,KAAK0d,SAAS,iBAGvBa,oBACE,OAAOve,KAAK0d,SAAS,iBAUvBc,yBAAiBhB,GACf,IACEiB,EAAY,EACZC,EAAY,EACZC,SAEF,IAAKA,EAAI,EAAGA,EAAInB,EAAOmB,IACH,IAAdD,IAEFA,GAAaD,EADAze,KAAKme,SACoB,KAAO,KAE/CM,EAA2B,IAAdC,EAAmBD,EAAYC,eAahDE,mBACE,IAKEC,EACgCC,EAChCC,EACAC,EAPAC,EAAsB,EACtBC,EAAuB,EACvBC,EAAqB,EACrBC,EAAwB,EAExBC,SAGAC,SACAvhB,SACAsgB,EAAYre,KAAKqe,UAAU9e,KAAKS,MAChC0d,EAAW1d,KAAK0d,SAASne,KAAKS,MAC9Bie,EAAUje,KAAKie,QAAQ1e,KAAKS,MAC5Boe,EAAcpe,KAAKoe,YAAY7e,KAAKS,MACpCud,EAAWvd,KAAKud,SAAShe,KAAKS,MAC9Bge,EAAShe,KAAKge,OAAOze,KAAKS,MAC1B+d,EAAU/d,KAAK+d,QAAQxe,KAAKS,MAC5Bwe,EAAkBxe,KAAKwe,gBAAgBjf,KAAKS,MAS9C,GAPAqe,IACAQ,EAAaR,IACGX,EAAS,GACzBH,EAAS,GACEc,IACXN,IAEmB,MAAfc,GACe,MAAfA,GACe,MAAfA,GACe,MAAfA,GACe,KAAfA,GACe,KAAfA,GACe,KAAfA,GACe,MAAfA,GACe,MAAfA,EAAoB,CACtB,IAAIU,EAAkBtB,IAQtB,GAPwB,IAApBsB,GACFhC,EAAS,GAGXQ,IACAA,IACAR,EAAS,GACLa,IAEF,IADAkB,EAAwC,IAApBC,EAAyB,EAAI,GAC5CxhB,EAAI,EAAGA,EAAIuhB,EAAkBvhB,IAC5BqgB,KAEAI,EADEzgB,EAAI,EACU,GAEA,IAM1BggB,IACA,IAAIyB,EAAkBvB,IACtB,GAAwB,IAApBuB,EACFvB,SACK,GAAwB,IAApBuB,EAKT,IAJAjC,EAAS,GACTS,IACAA,IACAqB,EAAiCpB,IAC5BlgB,EAAI,EAAGA,EAAIshB,EAAgCthB,IAC9CigB,IAGJD,IACAR,EAAS,GACTuB,EAAsBb,IACtBc,EAA4Bd,IAEH,KADzBe,EAAmBtB,EAAS,KAE1BH,EAAS,GAGXA,EAAS,GACLa,MACFa,EAAsBhB,IACtBiB,EAAuBjB,IACvBkB,EAAqBlB,IACrBmB,EAAwBnB,KAE1B,IAAIwB,GAAc,EAAG,GACrB,GAAIrB,KAEEA,IAGF,OADuBC,KAEvB,KAAK,EAAGoB,GAAc,EAAG,GAAI,MAC7B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,EAAGA,GAAc,GAAI,IAAK,MAC/B,KAAK,GAAIA,GAAc,GAAI,IAAK,MAChC,KAAK,GAAIA,GAAc,GAAI,IAAK,MAChC,KAAK,GAAIA,GAAc,GAAI,IAAK,MAChC,KAAK,GAAIA,GAAc,IAAK,IAAK,MACjC,KAAK,GAAIA,GAAc,EAAG,GAAI,MAC9B,KAAK,GAAIA,GAAc,EAAG,GAAI,MAC9B,KAAK,GAAIA,GAAc,EAAG,GAAI,MAC9B,KAAK,IACHA,GAAcpB,KAAe,EAAIA,IAAaA,KAAe,EAAIA,KAMvE,OACEqB,MAAOhK,KAAKiK,KAAmC,IAA3Bb,EAAsB,GAAiC,EAAtBG,EAAiD,EAAvBC,GAC/EU,QAAU,EAAIZ,IAAqBD,EAA4B,GAAK,IAAQC,EAAmB,EAAI,IAAMG,EAAqBC,GAC9HK,WAAYA,gBAIhBI,yBAME,OAJA7f,KAAKqe,YAELre,KAAKie,UAEEje,KAAKie,oBClLD6B,aApHb,SAAAA,EAAapQ,EAAUC,EAAQoQ,EAAaC,gGAAYC,CAAAjgB,KAAA8f,GACtD9f,KAAK+f,YAAcA,EACnB/f,KAAKggB,WAAaA,EAClBhgB,KAAKkgB,UAAY,IAAIzQ,EAAUC,EAAUC,GAAUzD,oBAAoB,uBAGzEiU,uBAAeC,EAAe9P,GAC5BtQ,KAAKkgB,UAAUjX,QAAQmX,EAAepgB,KAAK+f,YAAYzgB,IAAIoO,OAAQ1N,KAAK+f,YAAYjX,GAAG4E,OAAQ4C,gBAIjG+P,0BAAkBvM,EAASwM,EAAahQ,EAAUiQ,GAChD,IAAIC,EAAU1M,EAAQwM,GAAa3M,KAC/ByM,EAAgBI,EAAQ5M,SAAS,GAAI4M,EAAQnf,OAASmf,EAAQnf,OAAS,IACvEof,EAAkBL,EAAc1S,OAAO/L,MACzCye,EAAcM,WACdN,EAAcM,WAAaN,EAAc/e,QAEvCsf,EAAY3gB,KAChBA,KAAKmgB,cAAcM,EAAiB,SAAUG,GAC5CA,EAAgB,IAAIrL,WAAWqL,GAC/BJ,EAAQlD,IAAIsD,EAAe,IAEtBL,GACHI,EAAUE,kBAAkB/M,EAASwM,EAAc,EAAGhQ,kBAK5DuQ,2BAAmB/M,EAASwM,EAAahQ,GACvC,MAAQgQ,IAAe,CACrB,GAAIA,GAAexM,EAAQzS,OAEzB,YADAiP,IAIF,KAAIwD,EAAQwM,GAAa3M,KAAKtS,OAAS,IAAvC,CAIA,IAAIkf,EAAOvgB,KAAKkgB,UAAU9P,SAI1B,GAFApQ,KAAKqgB,iBAAiBvM,EAASwM,EAAahQ,EAAUiQ,IAEjDA,EACH,sBAMNO,6BAAqBC,GAInB,IAHA,IAAIC,EAAiE,GAA9CtL,KAAK+F,OAAOsF,EAAY1f,OAAS,IAAM,KAAY,GACtE+e,EAAgB,IAAIa,UAAUD,GAC9BE,EAAY,EACPC,EAAW,GAAIA,GAAYJ,EAAY1f,OAAS,GAAI8f,GAAY,IAAKD,GAAa,GACzFd,EAAc9C,IAAIyD,EAAYnN,SAASuN,EAAUA,EAAW,IAAKD,GAGnE,OAAOd,eAGTgB,6BAAqBL,EAAaH,GAChCA,EAAgB,IAAIrL,WAAWqL,GAE/B,IADA,IAAIO,EAAW,EACND,EAAY,GAAIA,GAAaH,EAAY1f,OAAS,GAAI6f,GAAa,IAAKC,GAAY,GAC3FJ,EAAYzD,IAAIsD,EAAchN,SAASuN,EAAUA,EAAW,IAAKD,GAGnE,OAAOH,eAGTM,0BAAkBvN,EAASwM,EAAagB,EAAWhR,EAAUkQ,EAASD,GACpE,IAAIQ,EAAc/gB,KAAKggB,WAAWQ,EAAQtX,MACtCkX,EAAgBpgB,KAAK8gB,oBAAoBC,GACzCJ,EAAY3gB,KAEhBA,KAAKmgB,cAAcC,EAAc1S,OAAQ,SAAUkT,GACjDJ,EAAQtX,KAAOyX,EAAUS,oBAAoBL,EAAaH,GAErDL,GACHI,EAAUY,kBAAkBzN,EAASwM,EAAagB,EAAY,EAAGhR,kBAKvEiR,2BAAmBzN,EAASwM,EAAagB,EAAWhR,GAClD,MAAQgQ,IAAegB,EAAY,EAAG,CACpC,GAAIhB,GAAexM,EAAQzS,OAEzB,YADAiP,IAKF,IADA,IAAIkR,EAAW1N,EAAQwM,GAAamB,QAE9BH,GAAaE,EAASngB,QADpBigB,IAAa,CAKnB,IAAId,EAAUgB,EAASF,GACvB,KAAId,EAAQnf,QAAU,IAAwB,IAAjBmf,EAAQ1f,MAA+B,IAAjB0f,EAAQ1f,MAA3D,CAIA,IAAIyf,EAAOvgB,KAAKkgB,UAAU9P,SAI1B,GAFApQ,KAAKqhB,iBAAiBvN,EAASwM,EAAagB,EAAWhR,EAAUkQ,EAASD,IAErEA,EACH,gBCxFV,IAAMmB,GACJpJ,MAAO,EACPD,MAAO,EACPsJ,IAAK,EACL1L,KAAM,GA8/BO2L,aA1/Bb,SAAAA,EAAalS,EAAU+G,EAAS9G,EAAQkS,gGAAeC,CAAA9hB,KAAA4hB,GACrD5hB,KAAK0P,SAAWA,EAChB1P,KAAK2P,OAASA,EACd3P,KAAK6hB,cAAgBA,EACrB7hB,KAAKyW,QAAUA,EACfzW,KAAK+hB,UAAY,wBAGnBC,wBAAgBjC,GACM,MAAfA,GAA4C,MAAnBA,EAAYzgB,KAAwC,eAAvBygB,EAAYkC,OACrEjiB,KAAK+hB,UAAY,IAAIjC,EAAmB9f,KAAK0P,SAAU1P,KAAK2P,OAAQoQ,EAAa/f,KAAKggB,YAEtFhgB,KAAK+hB,UAAY,QAIdnQ,eAAO1I,GACZ,IAAMgZ,EAAaN,EAAUO,YAAYjZ,GACzC,QAAIgZ,EAAa,KAGXA,GACF1S,EAAOhB,KAAP,wDAAoE0T,EAApE,mBAGK,MAIJC,qBAAajZ,GAIlB,IAFA,IAAMkZ,EAAa1M,KAAKgD,IAAI,IAAMxP,EAAK7H,OAAS,KAC5CtD,EAAI,EACDA,EAAIqkB,GAAY,CAErB,GAAgB,KAAZlZ,EAAKnL,IAAiC,KAAlBmL,EAAKnL,EAAI,MAAuC,KAAtBmL,EAAKnL,EAAI,KACzD,OAAOA,EAEPA,IAGJ,OAAQ,KAUHskB,qBAAavhB,EAAMgW,GACxB,OACEE,UAAoB,UAATlW,GAA6B,UAATA,EAAmB,kBAAeX,EACjEW,OACAmW,GAAIyK,EAAqB5gB,GACzBwhB,KAAM,EACNlL,eAAgB,IAChBF,eAAgB,EAChBpD,WACA7S,IAAK,EACLshB,QAAkB,UAATzhB,EAAmB,OAAIX,EAChCgX,MAAgB,UAATrW,QAA0BX,EACjC2W,SAAmB,UAAThW,EAAmBgW,OAAW3W,gBAc5CwW,0BAAkBC,EAAa3E,EAAY4E,EAAYC,GACrD9W,KAAKwiB,WAAY,EACjBxiB,KAAKyiB,QAAU,EAEfziB,KAAK0iB,UAAYd,EAAUS,YAAY,QAASvL,GAChD9W,KAAK+W,YAAc6K,EAAUS,YAAY,QAASvL,GAClD9W,KAAK2iB,UAAYf,EAAUS,YAAY,MAAOvL,GAC9C9W,KAAK4iB,UAAYhB,EAAUS,YAAY,OAAQvL,GAG/C9W,KAAK6iB,YAAc,KACnB7iB,KAAK8iB,WAAa,KAClB9iB,KAAK+iB,UAAY,KACjB/iB,KAAKiS,WAAaA,EAClBjS,KAAK6W,WAAaA,EAClB7W,KAAKgjB,UAAYlM,eAOnBO,wCAGAE,gBAAQrO,EAAMsO,EAAYC,EAAYC,GACpC,IAAIe,SAAOxX,EAAMiI,EAAK7H,OAAQ4hB,SAAKX,SAAUhX,SAAQ4X,SACnDC,GAAc,EAChBnjB,KAAKyX,WAAaA,EAClB,IAAI+K,EAAYxiB,KAAKwiB,UACnBY,EAAWpjB,KAAK0iB,UAChBW,EAAarjB,KAAK+W,YAClBuM,EAAWtjB,KAAK2iB,UAChBY,EAAQH,EAASd,IACjBkB,EAAUH,EAAWf,IACrBmB,EAAQH,EAAShB,IACjBoB,EAAQ1jB,KAAKyiB,OACbkB,EAAUP,EAASQ,QACnBC,EAAYR,EAAWO,QACvB7O,EAAUuO,EAASM,QACnBE,EAAW9jB,KAAK+jB,UAChBC,EAAWhkB,KAAKikB,UAChBC,EAAWlkB,KAAKmkB,UAChBC,EAAcpkB,KAAKqkB,aAAa9kB,KAAKS,MACrCskB,EAActkB,KAAKukB,aAAahlB,KAAKS,MACrCwkB,EAAexkB,KAAKykB,cAAcllB,KAAKS,MACvC0kB,EAAc1kB,KAAK2kB,aAAaplB,KAAKS,MAEjCkiB,EAAaN,EAAUO,YAAYjZ,GAMzC,IAHAjI,IAAQA,EAAMihB,GAAc,IAGvBzJ,EAAQyJ,EAAYzJ,EAAQxX,EAAKwX,GAAS,IAC7C,GAAoB,KAAhBvP,EAAKuP,GAAiB,CAMxB,GALAwK,KAA2B,GAAlB/Z,EAAKuP,EAAQ,IAEtB6J,IAA0B,GAAlBpZ,EAAKuP,EAAQ,KAAc,GAAKvP,EAAKuP,EAAQ,IAC5B,GAAlBvP,EAAKuP,EAAQ,KAAc,EAExB,GAGR,IAFAnN,EAASmN,EAAQ,EAAIvP,EAAKuP,EAAQ,MAElBA,EAAQ,IACtB,cAGFnN,EAASmN,EAAQ,EAEnB,OAAQ6J,GACR,KAAKiB,EACCN,IACEU,IAAYT,EAAMgB,EAASP,UAAyBxjB,IAAZ+iB,EAAI/P,KAC9CiR,EAAYlB,GAAK,GAGnBS,GAAYza,QAAUmL,KAAM,IAE1BsP,IACFA,EAAQza,KAAKlH,KAAKkH,EAAK0K,SAAStI,EAAQmN,EAAQ,MAChDkL,EAAQtP,MAAQoE,EAAQ,IAAMnN,GAEhC,MACF,KAAKkY,EACCP,IACEY,IAAcX,EAAMgB,EAASL,UAA2B1jB,IAAZ+iB,EAAI/P,MAC9CkQ,EAAWlM,MACbmN,EAAYpB,GAEZsB,EAAatB,IAGjBW,GAAc3a,QAAUmL,KAAM,IAE5BwP,IACFA,EAAU3a,KAAKlH,KAAKkH,EAAK0K,SAAStI,EAAQmN,EAAQ,MAClDoL,EAAUxP,MAAQoE,EAAQ,IAAMnN,GAElC,MACF,KAAKmY,EACCR,IACElO,IAAYmO,EAAMgB,EAASnP,UAAyB5U,IAAZ+iB,EAAI/P,KAC9CuR,EAAYxB,GAGdnO,GAAY7L,QAAUmL,KAAM,IAE1BU,IACFA,EAAQ7L,KAAKlH,KAAKkH,EAAK0K,SAAStI,EAAQmN,EAAQ,MAChD1D,EAAQV,MAAQoE,EAAQ,IAAMnN,GAEhC,MACF,KAAK,EACC2X,IACF3X,GAAUpC,EAAKoC,GAAU,GAG3BoY,EAAQ1jB,KAAKyiB,OAASqB,EAAS5a,EAAMoC,GACrC,MACF,KAAKoY,EACCT,IACF3X,GAAUpC,EAAKoC,GAAU,GAG3B,IAAIsZ,EAAaZ,EAAS9a,EAAMoC,GAAoC,IAA5BtL,KAAK6hB,cAAcgD,OAA4C,IAA3B7kB,KAAK6hB,cAAciD,IAAgC,MAAlB9kB,KAAK+hB,YAQlHwB,EAAQqB,EAAWG,KACP,IACV3B,EAASd,IAAMiB,IAGjBC,EAAUoB,EAAWvM,OACP,IACZgL,EAAWf,IAAMkB,EACjBH,EAAWlM,MAAQyN,EAAWzN,QAEhCsM,EAAQmB,EAAWjD,KACP,IACV2B,EAAShB,IAAMmB,GAGbN,IAAgBX,IAClBhT,EAAOjB,IAAI,0BACX4U,GAAc,EAEd1K,EAAQyJ,EAAa,KAEvBM,EAAYxiB,KAAKwiB,WAAY,EAC7B,MACF,KAAK,GACL,KAAK,KACH,MACF,QACEW,GAAc,QAIhBnjB,KAAK0P,SAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWE,YAAawK,QAASpK,EAAakB,mBAAoBmJ,OAAO,EAAOC,OAAQ,sCAInIuS,IAAYT,EAAMgB,EAASP,UAAyBxjB,IAAZ+iB,EAAI/P,KAC9CiR,EAAYlB,GAAK,GACjBE,EAASQ,QAAU,MAGnBR,EAASQ,QAAUD,EAGjBE,IAAcX,EAAMgB,EAASL,UAA2B1jB,IAAZ+iB,EAAI/P,KAC9CkQ,EAAWlM,MACbmN,EAAYpB,GAEZsB,EAAatB,GAGfG,EAAWO,QAAU,OAEjBC,GAAaA,EAAUxP,MACzB7E,EAAOjB,IAAI,iEAIb8U,EAAWO,QAAUC,GAGnB9O,IAAYmO,EAAMgB,EAASnP,UAAyB5U,IAAZ+iB,EAAI/P,KAC9CuR,EAAYxB,GACZI,EAASM,QAAU,MAGnBN,EAASM,QAAU7O,EAGC,MAAlB/U,KAAK+hB,UACP/hB,KAAKyW,QAAQmB,MAAMyL,EAAYD,EAAUE,EAAUtjB,KAAK4iB,UAAWpL,EAAYC,EAAYC,GAE3F1X,KAAKglB,gBAAgB3B,EAAYD,EAAUE,EAAUtjB,KAAK4iB,UAAWpL,EAAYC,EAAYC,gBAIjGsN,yBAAiB3B,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,GACpF,GAAI2L,EAAWvP,SAAWuP,EAAWlM,MAAO,CAC1C,IAAIwJ,EAAY3gB,KAChBA,KAAK+hB,UAAUlB,kBAAkBwC,EAAWvP,QAAS,EAAG,WACtD6M,EAAUwE,mBAAmB9B,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,UAGpG1X,KAAKmlB,mBAAmB9B,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,gBAIjGyN,4BAAoB9B,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,GACvF,GAAIuN,EAAWnR,QAAS,CACtB,IAAI6M,EAAY3gB,KAChBA,KAAK+hB,UAAUR,kBAAkB0D,EAAWnR,QAAS,EAAG,EAAG,WACzD6M,EAAUlK,QAAQmB,MAAMyL,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,UAG/F1X,KAAKyW,QAAQmB,MAAMyL,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,gBAI5F1J,mBACEhO,KAAKolB,SAAWplB,KAAKqlB,cAAWllB,EAChCH,KAAKgjB,UAAY,eAGnBe,mBAAW7a,EAAMoC,GAEf,OAA4B,GAApBpC,EAAKoC,EAAS,MAAe,EAAIpC,EAAKoC,EAAS,iBAIzD2Y,mBAAW/a,EAAMoC,EAAQga,EAAeC,GACtC,IAAmBC,EAA6BlD,SAAKxR,GAAWuH,OAAQ,EAAG0M,KAAM,EAAGpD,KAAM,EAAGxK,OAAO,GAQpG,IANAqO,EAAWla,EAAS,IADgB,GAAnBpC,EAAKoC,EAAS,KAAc,EAAIpC,EAAKoC,EAAS,IACvB,EAKxCA,GAAU,KAF+B,GAApBpC,EAAKoC,EAAS,MAAe,EAAIpC,EAAKoC,EAAS,KAG7DA,EAASka,GAAU,CAExB,OADAlD,GAA0B,GAAnBpZ,EAAKoC,EAAS,KAAc,EAAIpC,EAAKoC,EAAS,GAC7CpC,EAAKoC,IACb,KAAK,IACH,IAAKia,EAAa,CAChB/V,EAAOjB,IAAI,sBAAwBrF,EAAKoC,IACxC,MAKJ,KAAK,IAEmB,IAAlBwF,EAAOuH,QACTvH,EAAOuH,MAAQiK,GAGjB,MAGF,KAAK,IAEiB,IAAhBxR,EAAO6Q,MACT7Q,EAAO6Q,IAAMW,GAGf,MAEF,KAAK,IACH,IAAKiD,EAAa,CAChB/V,EAAOjB,IAAI,sBAAwBrF,EAAKoC,IACxC,MAKJ,KAAK,IAEiB,IAAhBwF,EAAOiU,MACTjU,EAAOiU,IAAMzC,GAGf,MAIF,KAAK,EACL,KAAK,EAEEgD,GAEwB,IAAlBxU,EAAOuH,QAChBvH,EAAOuH,MAAQiK,EACfxR,EAAOqG,OAAQ,GAHf3H,EAAOjB,IAAI,2DAKb,MAEF,KAAK,GACHiB,EAAOhB,KAAK,iDACZ,MAEF,QACEgB,EAAOjB,IAAI,sBAAwBrF,EAAKoC,IAK1CA,GAAgE,IAAjC,GAAnBpC,EAAKoC,EAAS,KAAc,EAAIpC,EAAKoC,EAAS,IAE5D,OAAOwF,eAGTqT,mBAAWsB,GACT,IAAI1nB,EAAI,EAAG2nB,SAAMC,SAAqBC,SAAQC,SAAWjC,SAASkC,SAAQC,SAAQC,SAAoB9c,EAAOuc,EAAOvc,KAEpH,IAAKuc,GAA0B,IAAhBA,EAAOpR,KACpB,OAAO,KAMT,KAAOnL,EAAK,GAAG7H,OAAS,IAAM6H,EAAK7H,OAAS,GAAG,CAC7C,IAAI4kB,EAAU,IAAI1Q,WAAWrM,EAAK,GAAG7H,OAAS6H,EAAK,GAAG7H,QACtD4kB,EAAQ3I,IAAIpU,EAAK,IACjB+c,EAAQ3I,IAAIpU,EAAK,GAAIA,EAAK,GAAG7H,QAC7B6H,EAAK,GAAK+c,EACV/c,EAAKvG,OAAO,EAAG,GAKjB,GAAkB,MAFlB+iB,EAAOxc,EAAK,IACM,IAAM,KAAOwc,EAAK,IAAM,GAAKA,EAAK,GAC/B,CAInB,IAHAE,GAAUF,EAAK,IAAM,GAAKA,EAAK,KAGjBE,EAASH,EAAOpR,KAAO,EACnC,OAAO,KAIM,KADfsR,EAAWD,EAAK,OAKdI,EAA4B,WAAR,GAAVJ,EAAK,IACO,SAAR,IAAXA,EAAK,KACc,OAAR,IAAXA,EAAK,KACc,KAAR,IAAXA,EAAK,MACM,IAAXA,EAAK,KAAc,GAET,aAEXI,GAAU,YAEG,GAAXH,IACFI,EAA6B,WAAR,GAAXL,EAAK,KACO,SAAR,IAAXA,EAAK,KACc,OAAR,IAAXA,EAAK,KACc,KAAR,IAAXA,EAAK,MACM,IAAXA,EAAK,KAAc,GAET,aAEXK,GAAU,YAERD,EAASC,EAAS,OACpBvW,EAAOhB,KAAQkH,KAAKC,OAAOmQ,EAASC,GAAU,KAA9C,2CACAD,EAASC,IAGXA,EAASD,GAKbE,GAFAH,EAAYH,EAAK,IAEgB,EAEjCD,EAAOpR,MAAQ2R,EAEfpC,EAAU,IAAIrO,WAAWkQ,EAAOpR,MAChC,IAAK,IAAIsK,EAAI,EAAGuH,EAAUhd,EAAK7H,OAAQsd,EAAIuH,EAASvH,IAAK,CAEvD,IAAI1d,GADJykB,EAAOxc,EAAKyV,IACG/Q,WACf,GAAIoY,EAAoB,CACtB,GAAIA,EAAqB/kB,EAAK,CAE5B+kB,GAAsB/kB,EACtB,SAGAykB,EAAOA,EAAK9R,SAASoS,GACrB/kB,GAAO+kB,EACPA,EAAqB,EAGzBpC,EAAQtG,IAAIoI,EAAM3nB,GAClBA,GAAKkD,EAMP,OAJI2kB,IAEFA,GAAUC,EAAY,IAEf3c,KAAM0a,EAASzQ,IAAK2S,EAAQjS,IAAKkS,EAAQ9kB,IAAK2kB,GAEvD,OAAO,kBAIXO,uBAAepD,EAAWK,GACxB,GAAIL,EAAUtB,MAAMpgB,QAAU0hB,EAAUtO,MAAO,CAC7C,IAAMX,EAAUsP,EAAStP,QACnBsS,EAAYtS,EAAQzS,QAKrBrB,KAAK2P,OAAO0W,+BACK,IAAlBtD,EAAUzjB,KACT8jB,EAASkD,MAAQF,GAAapmB,KAAKyX,aACtCsL,EAAU9L,GAAKmP,EACftS,EAAQ9R,KAAK+gB,IAGbK,EAASb,UAGTQ,EAAUzU,MAAMjN,QAClBmO,EAAOjB,IAAIwU,EAAU5P,IAAM,IAAM4P,EAAUlP,IAAM,IAAMkP,EAAUzU,oBAIrE+V,sBAAcnB,EAAKqD,GAAM,IAAAhW,EAAAvQ,KAEnBgS,EAAQhS,KAAK0iB,UACfjB,EAAQzhB,KAAKwmB,cAActD,EAAIha,MAE/Bud,SACA1D,EAAY/iB,KAAK+iB,UACjB/gB,SACA0kB,GAAW,EACX3oB,SACAooB,EAAgBnmB,KAAKmmB,cAAc5mB,KAAKS,MACxC2mB,EAAkB,SAAUrnB,EAAK6T,EAAKU,EAAKvF,GACzC,OAAShP,IAAKA,EAAK6T,IAAKA,EAAKU,IAAKA,EAAK4N,SAAWnT,MAAOA,IAG7D4U,EAAIha,KAAO,KAIP6Z,GAAatB,EAAMpgB,SAAW2Q,EAAM4U,WACtCT,EAAcpD,EAAW/Q,GACzB+Q,EAAY/iB,KAAK+iB,UAAY4D,GAAgB,EAAOzD,EAAI/P,IAAK+P,EAAIrP,IAAK,KAGxE4N,EAAMxS,QAAQ,SAAA0E,GACZ,OAAQA,EAAK7S,MAEb,KAAK,EACHkB,GAAO,EACF+gB,IACHA,EAAYxS,EAAKwS,UAAY4D,GAAgB,EAAMzD,EAAI/P,IAAK+P,EAAIrP,IAAK,KAOvEkP,EAAUtO,OAAQ,EAClB,IAAIvL,EAAOyK,EAAKzK,KAEhB,GAAIwd,GAAYxd,EAAK7H,OAAS,EAAG,CAE/B,IAAIwlB,EAAY,IAAI9J,EAAU7T,GAAM2W,gBAMlB,IAAdgH,GAAiC,IAAdA,GAAiC,IAAdA,GAAiC,IAAdA,IAC3D9D,EAAUzjB,KAAM,GAGpB,MAEF,KAAK,EACH0C,GAAO,EAEF+gB,IACHA,EAAYxS,EAAKwS,UAAY4D,GAAgB,EAAMzD,EAAI/P,IAAK+P,EAAIrP,IAAK,KAOvEkP,EAAUzjB,KAAM,EAChByjB,EAAUtO,OAAQ,EAClB,MAEF,KAAK,EACHzS,GAAO,GAKPykB,EAAmB,IAAI1J,EAAUxM,EAAKyP,WAAWrM,EAAKzK,QAGrCmV,YAOjB,IALA,IAAIyI,EAAc,EACdC,EAAc,EACdC,GAAgB,EAChBC,EAAI,GAEAD,GAAiBP,EAAiBxJ,eAAiB,GAAG,CAC5D6J,EAAc,EACd,GAEEA,GADAG,EAAIR,EAAiBpI,kBAER,MAAN4I,GAGTF,EAAc,EACd,GAEEA,GADAE,EAAIR,EAAiBpI,kBAER,MAAN4I,GAIT,GAAoB,IAAhBH,GAAyD,IAApCL,EAAiBxJ,gBAKxC,GAJA+J,GAAgB,EAII,MAFFP,EAAiBpI,YAKjC,GAAqB,KAFFoI,EAAiBnI,aAKlC,GAAsB,aAFFmI,EAAiBlI,WAMnC,GAAqB,IAHFkI,EAAiBpI,YAGZ,CACtB,IAAI6I,EAAYT,EAAiBpI,YAG7B8I,EAAW,GAAKD,EAChBE,GAAaF,EAHAT,EAAiBpI,aAKlC,IAAKtgB,EAAI,EAAGA,EAAIopB,EAAUppB,IAExBqpB,EAAUplB,KAAKykB,EAAiBpI,aAChC+I,EAAUplB,KAAKykB,EAAiBpI,aAChC+I,EAAUplB,KAAKykB,EAAiBpI,aAGlC9N,EAAK8W,qBAAqB9W,EAAKqS,UAAU9O,SAAWhT,KAAM,EAAGqS,IAAK+P,EAAI/P,IAAKmU,MAAOF,UAKrF,GAAIL,EAAcN,EAAiBxJ,eACxC,IAAKlf,EAAI,EAAGA,EAAIgpB,EAAahpB,IAC3B0oB,EAAiBpI,YAIvB,MAEF,KAAK,EAOH,GANArc,GAAO,EACP0kB,GAAW,GAKN1U,EAAMsU,IAAK,CAEd,IAAI3W,GADJ8W,EAAmB,IAAI1J,EAAUpJ,EAAKzK,OACR0V,UAC9B5M,EAAM0N,MAAQ/P,EAAO+P,MACrB1N,EAAM4N,OAASjQ,EAAOiQ,OACtB5N,EAAMyN,WAAa9P,EAAO8P,WAC1BzN,EAAMsU,KAAO3S,EAAKzK,MAClB8I,EAAM8E,SAAWvG,EAAKyS,UACtB,IAAIuE,EAAa5T,EAAKzK,KAAK0K,SAAS,EAAG,GACnC4T,EAAc,QAClB,IAAKzpB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACtB,IAAI0pB,EAAIF,EAAWxpB,GAAG2pB,SAAS,IAC3BD,EAAEpmB,OAAS,IACbomB,EAAI,IAAMA,GAGZD,GAAeC,EAEjBzV,EAAMe,MAAQyU,EAEhB,MAEF,KAAK,EACHxlB,GAAO,EAKFgQ,EAAM2V,MACT3V,EAAM2V,KAAOhU,EAAKzK,OAGpB,MAEF,KAAK,EACHlH,GAAO,EACPgQ,EAAM4U,UAAW,EACb7D,GACFoD,EAAcpD,EAAW/Q,GAG3B+Q,EAAYxS,EAAKwS,UAAY4D,GAAgB,EAAOzD,EAAI/P,IAAK+P,EAAIrP,IAAsB,IACvF,MAEF,KAAK,GACH7R,GAAO,EACP,MACF,QACEA,GAAO,EACH+gB,IACFA,EAAUzU,OAAS,eAAiBqF,EAAK7S,KAAO,KAKhDiiB,GAAa/gB,GACH+gB,EAAUtB,MAChBzf,KAAK2R,KAIX4S,GAAQxD,IACVoD,EAAcpD,EAAW/Q,GACzBhS,KAAK+iB,UAAY,mBAIrBsE,8BAAsBO,EAAK1e,GACzB,IAAIjI,EAAM2mB,EAAIvmB,OACd,GAAIJ,EAAM,GACR,GAAIiI,EAAKiK,KAAOyU,EAAI3mB,EAAM,GAAGkS,IAC3ByU,EAAI5lB,KAAKkH,QAET,IAAK,IAAI2e,EAAM5mB,EAAM,EAAG4mB,GAAO,EAAGA,IAChC,GAAI3e,EAAKiK,IAAMyU,EAAIC,GAAK1U,IAAK,CAC3ByU,EAAIjlB,OAAOklB,EAAK,EAAG3e,GACnB,YAKN0e,EAAI5lB,KAAKkH,gBAIb4e,2BACE,IAAI/E,EAAY/iB,KAAK+iB,UAAWgF,SAEhC,IAAKhF,GAAwC,IAA3BA,EAAUtB,MAAMpgB,OAAc,CAC9C,IAA4ByS,EAAhB9T,KAAK0iB,UAA2B5O,QAC5CiP,EAAYjP,EAAQA,EAAQzS,OAAS,GAEvC,GAAI0hB,EAAW,CACb,IAAItB,EAAQsB,EAAUtB,MACtBsG,EAAWtG,EAAMA,EAAMpgB,OAAS,GAElC,OAAO0mB,eAGTvB,uBAAerQ,GACb,IAAIpY,EAAI,EAAGkD,EAAMkV,EAAMvI,WAAY5O,SAAOgpB,SAAUhW,EAAQhS,KAAK0iB,UAAWuF,EAAQjW,EAAMkW,WAAa,EAAGC,EAAYF,EAClHxG,KAAY9N,SAAgByU,GAAiB,EAAGC,SAYpD,KATe,IAAXJ,IAEFG,EAAgB,EAEhBC,EAA0B,GAAXlS,EAAM,GACrB8R,EAAQ,EACRlqB,EAAI,GAGCA,EAAIkD,GAGT,GAFAjC,EAAQmX,EAAMpY,KAETkqB,EAIL,GAAc,IAAVA,EAKJ,GAAKjpB,EAEE,GAAc,IAAVA,EAAa,CACtB,GAAIopB,GAAiB,EACnBzU,GAASzK,KAAMiN,EAAMvC,SAASwU,EAAerqB,EAAIkqB,EAAQ,GAAInnB,KAAMunB,GAEnE5G,EAAMzf,KAAK2R,OACN,CAKL,IAAIoU,EAAW/nB,KAAK8nB,kBACpB,GAAIC,IACEI,GAAcpqB,GAAK,EAAIoqB,GAIrBJ,EAASE,QAEXF,EAAS7e,KAAO6e,EAAS7e,KAAK0K,SAAS,EAAGmU,EAAS7e,KAAK0E,WAAaua,KAIzEH,EAAWjqB,EAAIkqB,EAAQ,GACR,GAAG,CAEhB,IAAIK,EAAM,IAAI/S,WAAWwS,EAAS7e,KAAK0E,WAAaoa,GACpDM,EAAIhL,IAAIyK,EAAS7e,KAAM,GACvBof,EAAIhL,IAAInH,EAAMvC,SAAS,EAAGoU,GAAWD,EAAS7e,KAAK0E,YACnDma,EAAS7e,KAAOof,GAKlBvqB,EAAIkD,GAGNmnB,EAAgBrqB,EAChBsqB,EAHsB,GAAXlS,EAAMpY,GAIjBkqB,EAAQ,GAGRA,GAAS,OAGXA,EAAQ,OA7CRA,EAAQ,OALRA,EAAQjpB,EAAQ,EAAI,OAJpBipB,EAAQjpB,EAAQ,EAAI,EA+DxB,GANIopB,GAAiB,GAAKH,GAAS,IACjCtU,GAASzK,KAAMiN,EAAMvC,SAASwU,EAAennB,GAAMH,KAAMunB,EAAcJ,MAAOA,GAC9ExG,EAAMzf,KAAK2R,IAIQ,IAAjB8N,EAAMpgB,OAAc,CAEtB,IAAI0mB,EAAW/nB,KAAK8nB,kBACpB,GAAIC,EAAU,CACZ,IAAIO,EAAM,IAAI/S,WAAWwS,EAAS7e,KAAK0E,WAAauI,EAAMvI,YAC1D0a,EAAIhL,IAAIyK,EAAS7e,KAAM,GACvBof,EAAIhL,IAAInH,EAAO4R,EAAS7e,KAAK0E,YAC7Bma,EAAS7e,KAAOof,GAIpB,OADAtW,EAAMkW,UAAYD,EACXxG,eAMTzB,oBAAY9W,GAOV,IANA,IAGEqf,EAHElnB,EAAS6H,EAAK0E,WAChB4a,KACAzqB,EAAI,EACOkoB,SAGNloB,EAAIsD,EAAS,GACF,IAAZ6H,EAAKnL,IACW,IAAhBmL,EAAKnL,EAAI,IACO,IAAhBmL,EAAKnL,EAAI,IACXyqB,EAAaxmB,KAAKjE,EAAI,GACtBA,GAAK,GAELA,IAMJ,GAA4B,IAAxByqB,EAAannB,OACf,OAAO6H,EAITqf,EAAYlnB,EAASmnB,EAAannB,OAClC4kB,EAAU,IAAI1Q,WAAWgT,GACzB,IAAIE,EAAc,EAElB,IAAK1qB,EAAI,EAAGA,EAAIwqB,EAAWE,IAAe1qB,IACpC0qB,IAAgBD,EAAa,KAE/BC,IAEAD,EAAaE,SAEfzC,EAAQloB,GAAKmL,EAAKuf,GAEpB,OAAOxC,eAGT1B,sBAAcrB,GACZ,IAME5P,EAA0CrS,EANxC+Q,EAAQhS,KAAK+W,YACf7N,EAAOga,EAAIha,KACXiK,EAAM+P,EAAI/P,IAEV0P,EAAc7iB,KAAK6iB,YACnBC,EAAa9iB,KAAK8iB,WACH1P,SAAY9H,SAAQkI,SACrC,GAAIqP,EAAa,CACf,IAAIyF,EAAM,IAAI/S,WAAWsN,EAAYjV,WAAa1E,EAAK0E,YACvD0a,EAAIhL,IAAIuF,EAAa,GACrByF,EAAIhL,IAAIpU,EAAM2Z,EAAYjV,YAE1B1E,EAAOof,EAGT,IAAKhd,EAZW,EAYWrK,EAAMiI,EAAK7H,OAAQiK,EAASrK,EAAM,IACvDqW,EAAcpO,EAAMoC,GADsCA,KAMhE,GAAIA,EAAQ,CACV,IAAI8F,SAAQD,SAUZ,GATI7F,EAASrK,EAAM,GACjBmQ,mDAA0D9F,EAC1D6F,GAAQ,IAERC,EAAS,kCACTD,GAAQ,GAEV3B,EAAOhB,KAAP,iBAA6B4C,GAC7BpR,KAAK0P,SAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWE,YAAawK,QAASpK,EAAakB,mBAAoBmJ,MAAOA,EAAOC,OAAQA,IAC/HD,EACF,OAUJ,GANAmG,EAAqBtF,EAAOhS,KAAK0P,SAAUxG,EAAMoC,EAAQtL,KAAKiS,YAC9DmB,EAAa,EACbE,EAAgBgE,EAAsBtF,EAAME,YAIxC2Q,GAAeC,EAAY,CAC7B,IAAI6F,EAAS7F,EAAaxP,EACtBoC,KAAKkT,IAAID,EAASxV,GAAO,IAC3B3D,EAAOjB,IAAP,4CAAuDmH,KAAKC,OAAOgT,EAASxV,GAAO,KACnFA,EAAMwV,GAKV,KAAOrd,EAASrK,GACd,GAAIqW,EAAcpO,EAAMoC,IAAYA,EAAS,EAAKrK,EAAK,CACrD,IAAIwT,EAAQ6C,EAAiBtF,EAAO9I,EAAMoC,EAAQ6H,EAAKC,GACvD,IAAIqB,EAOF,MALAnJ,GAAUmJ,EAAMpT,OAChBmS,EAAQiB,EAAMV,OAAOZ,IACrBC,SAOF9H,IAKFuX,EADEvX,EAASrK,EACGiI,EAAK0K,SAAStI,EAAQrK,GAGtB,KAGhBjB,KAAK6iB,YAAcA,EACnB7iB,KAAK8iB,WAAatP,eAGpBiR,uBAAevB,GAOb,IANA,IAAIha,EAAOga,EAAIha,KACX7H,EAAS6H,EAAK7H,OACd+R,EAAa,EACb9H,EAAS,EACT6H,EAAM+P,EAAI/P,IAEP7H,EAASjK,GACd,GAAIua,EAAUjK,SAASzI,EAAMoC,GAAS,CACpC,IAAImJ,EAAQmH,EAAU1I,YAAYlT,KAAK+W,YAAa7N,EAAMoC,EAAQ6H,EAAKC,GACvE,IAAIqB,EAKF,MAJAnJ,GAAUmJ,EAAMpT,OAChB+R,SAOF9H,iBAKNqZ,sBAAczB,GACZljB,KAAK2iB,UAAU7O,QAAQ9R,KAAKkhB,aCr8BjB2F,aA7Eb,SAAAA,EAAanZ,EAAU+G,EAAS9G,gGAAQmZ,CAAA9oB,KAAA6oB,GACtC7oB,KAAK0P,SAAWA,EAChB1P,KAAK2P,OAASA,EACd3P,KAAKyW,QAAUA,qBAGjBE,0BAAkBC,EAAa3E,EAAY4E,EAAYC,GACrD9W,KAAK+W,aAAgBC,UAAW,aAAclW,KAAM,QAASmW,IAAK,EAAGC,eAAgB,EAAGC,OAAO,EAAOrD,WAAa7S,IAAK,EAAGyR,cAAeT,EAAY6E,SAAUA,EAAUM,eAAgB,kBAG5LC,8BAGOzF,eAAO1I,GAEZ,IAAIoC,SAAQjK,SACR0T,EAAUf,EAAIE,WAAWhL,EAAM,GACnC,GAAI6L,QAAyC5U,IAA9B6T,EAAIM,aAAaS,GAI9B,IAAKzJ,EAASyJ,EAAQ1T,OAAQA,EAASqU,KAAKgD,IAAIxP,EAAK7H,OAAS,EAAGiK,EAAS,KAAMA,EAASjK,EAAQiK,IAC/F,GAAIsQ,EAAUhK,MAAM1I,EAAMoC,GAExB,OADAkE,EAAOjB,IAAI,iCACJ,EAIb,OAAO,eAITgJ,gBAAQrO,EAAMsO,EAAYC,EAAYC,GAWpC,IAVA,IAAI3C,EAAUf,EAAIE,WAAWhL,EAAM,GAC/BuM,EAAYzB,EAAIM,aAAaS,GAC7B5B,EAAMsC,EAAY,GAAKA,EAAyB,IAAb+B,EACnClM,EAASyJ,EAAQ1T,OACjBA,EAAS6H,EAAK7H,OACd+R,EAAa,EAAGI,EAAQ,EACxBxB,EAAQhS,KAAK+W,YAEbY,IAAgBxE,IAAKA,EAAKU,IAAKV,EAAKjK,KAAM6L,IAEvCzJ,EAASjK,GACd,GAAIua,EAAUjK,SAASzI,EAAMoC,GAAS,CACpC,IAAImJ,EAAQmH,EAAU1I,YAAYlB,EAAO9I,EAAMoC,EAAQ6H,EAAKC,GAC5D,IAAIqB,EAMF,MALAnJ,GAAUmJ,EAAMpT,OAChBmS,EAAQiB,EAAMV,OAAOZ,IACrBC,SAKOY,EAAIrC,SAASzI,EAAMoC,IAC5ByJ,EAAUf,EAAIE,WAAWhL,EAAMoC,GAC/BqM,EAAW3V,MAAOmR,IAAKK,EAAOK,IAAKL,EAAOtK,KAAM6L,IAChDzJ,GAAUyJ,EAAQ1T,QAGlBiK,IAIJtL,KAAKyW,QAAQmB,MAAM5F,GACf8B,aACAA,QAAS6D,EAAYP,eAAgB,MACrCtD,YACF0D,EACAC,EACAC,gBAGJ1J,8BCxCa+a,yIApCNC,wBAAgBjW,EAAOD,GAC5B,OAAQC,GACR,IAAK,YACH,GAAqB,IAAjBD,EACF,OAAO,IAAIyC,YAAY,EAAM,IAAM,EAAM,IAAM,GAAM,MAChD,GAAqB,IAAjBzC,EACT,OAAO,IAAIyC,YAAY,GAAM,EAAM,GAAM,IAAM,EAAM,GAAM,EAAM,GAAM,MAClE,GAAqB,IAAjBzC,EACT,OAAO,IAAIyC,YAAY,EAAM,IAAM,EAAM,IAAM,GAAM,IAAM,EAAM,GAAM,GAAM,EAAM,IAAM,EAAM,MAC1F,GAAqB,IAAjBzC,EACT,OAAO,IAAIyC,YAAY,EAAM,IAAM,EAAM,IAAM,GAAM,IAAM,EAAM,GAAM,GAAM,EAAM,IAAM,EAAM,IAAM,GAAM,IAAM,EAAM,EAAM,KACxH,GAAqB,IAAjBzC,EACT,OAAO,IAAIyC,YAAY,EAAM,IAAM,EAAM,IAAM,GAAM,IAAM,EAAM,GAAM,GAAM,EAAM,IAAM,EAAM,IAAM,GAAM,EAAM,IAAM,EAAM,GAAM,IAAM,EAAM,KAC1I,GAAqB,IAAjBzC,EACT,OAAO,IAAIyC,YAAY,EAAM,IAAM,EAAM,IAAM,GAAM,IAAM,EAAM,GAAM,GAAM,EAAM,IAAM,EAAM,IAAM,GAAM,EAAM,IAAM,EAAM,GAAM,IAAM,EAAM,EAAM,IAAM,EAAM,GAAM,EAAM,MAG/K,MAEF,QACE,GAAqB,IAAjBzC,EAEF,OAAO,IAAIyC,YAAY,EAAK,GAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,EAAK,EAAK,EAAK,EAAK,GAAM,EAAK,IAAM,IAAM,GAAK,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,KACvW,GAAqB,IAAjBzC,EAET,OAAO,IAAIyC,YAAY,EAAK,GAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,EAAK,EAAK,EAAK,EAAK,EAAK,IAAM,EAAK,EAAK,IAAM,IAAM,GAAK,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,KACrW,GAAqB,IAAjBzC,EAET,OAAO,IAAIyC,YAAY,EAAK,GAAM,GAAM,IAAM,IAAM,GAAM,IAAM,IAAM,IAAM,EAAK,EAAK,EAAK,EAAK,EAAK,IAAM,EAAK,EAAK,IAAM,IAAM,GAAK,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,KAI9W,OAAO,WCjCX,IAAMsC,EAAanC,KAAKoC,IAAI,EAAG,IAAM,EAwoBtBmR,yIAroBNC,gBACLD,EAAIE,OACFC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAnP,QACAoP,QACArP,QACAsP,QACAC,QACAC,QACAC,QACAzQ,QACA0Q,QACAC,UACAC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAC,QACAvP,QACAF,QACAD,QACAd,QACAyQ,QACAC,QACAzQ,QACA0Q,QACAC,SAGF,IAAIhtB,SACJ,IAAKA,KAAKkrB,EAAIE,MACRF,EAAIE,MAAMvpB,eAAe7B,KAC3BkrB,EAAIE,MAAMprB,IACRA,EAAEitB,WAAW,GACbjtB,EAAEitB,WAAW,GACbjtB,EAAEitB,WAAW,GACbjtB,EAAEitB,WAAW,KAKnB,IAAIC,EAAY,IAAI1V,YAClB,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAClB,IAAM,IAAM,IAAM,IAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,GAAM,IAAM,IAAM,IAClB,IAAM,GAAM,GAAM,IAClB,IAAM,IAAM,IAAM,IAAM,IAGtB2V,EAAY,IAAI3V,YAClB,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAClB,IAAM,IAAM,IAAM,IAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,GAAM,IAAM,IAAM,IAClB,IAAM,GAAM,GAAM,IAClB,IAAM,IAAM,IAAM,IAAM,IAG1B0T,EAAIkC,YACF7S,MAAS2S,EACT5S,MAAS6S,GAGX,IAAI1B,EAAO,IAAIjU,YACb,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,GAClB,IAAM,IAAM,IAAM,GAClB,EACA,EAAM,EAAM,IAGVgV,EAAO,IAAIhV,YACb,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,IAGpB0T,EAAImC,KAAOnC,EAAIoC,KAAOpC,EAAIqC,KAAOf,EAEjCtB,EAAIsC,KAAO,IAAIhW,YACb,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,IAEpB0T,EAAIuC,KAAO,IAAIjW,YACb,EACA,EAAM,EAAM,EACZ,EAAM,EACN,EAAM,EACN,EAAM,EACN,EAAM,IAER0T,EAAIwC,KAAO,IAAIlW,YACb,EACA,EAAM,EAAM,EACZ,EAAM,EACN,EAAM,IAGR0T,EAAIyC,KAAO,IAAInW,YACb,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,IAEpB,IAAIoW,EAAa,IAAIpW,YAAY,IAAK,IAAK,IAAK,MAC5CqW,EAAY,IAAIrW,YAAY,GAAI,IAAK,GAAI,KACzCsW,EAAe,IAAItW,YAAY,EAAG,EAAG,EAAG,IAE5C0T,EAAI6C,KAAO7C,EAAI8C,IAAI9C,EAAIE,MAAMO,KAAMiC,EAAYE,EAAcF,EAAYC,GACzE3C,EAAI+C,KAAO/C,EAAI8C,IAAI9C,EAAIE,MAAMI,KAAMN,EAAI8C,IAAI9C,EAAIE,MAAMK,KAAMA,OAGtDuC,aAAKjrB,GAQV,IAPA,IACEmrB,EAAUvqB,MAAM/B,UAAUgC,MAAMzD,KAAKoD,UAAW,GAChD+S,EAAO,EACPtW,EAAIkuB,EAAQ5qB,OACZJ,EAAMlD,EACN+S,SAEK/S,KACLsW,GAAQ4X,EAAQluB,GAAG6P,WAUrB,KAPAkD,EAAS,IAAIyE,WAAWlB,IACjB,GAAMA,GAAQ,GAAM,IAC3BvD,EAAO,GAAMuD,GAAQ,GAAM,IAC3BvD,EAAO,GAAMuD,GAAQ,EAAK,IAC1BvD,EAAO,GAAY,IAAPuD,EACZvD,EAAOwM,IAAIxc,EAAM,GAEZ/C,EAAI,EAAGsW,EAAO,EAAGtW,EAAIkD,EAAKlD,IAE7B+S,EAAOwM,IAAI2O,EAAQluB,GAAIsW,GACvBA,GAAQ4X,EAAQluB,GAAG6P,WAErB,OAAOkD,KAGFyJ,cAAMzZ,GACX,OAAOmoB,EAAI8C,IAAI9C,EAAIE,MAAM5O,KAAM0O,EAAIkC,WAAWrqB,OAGzC6oB,cAAMzgB,GACX,OAAO+f,EAAI8C,IAAI9C,EAAIE,MAAMQ,KAAMzgB,MAG1BoR,cAAMX,EAAW7C,GACtBA,GAAY6C,EACZ,IAAMuS,EAAoBxW,KAAK+F,MAAM3E,GAAYe,EAAa,IACxDsU,EAAoBzW,KAAK+F,MAAM3E,GAAYe,EAAa,IAC9D,OAAOoR,EAAI8C,IAAI9C,EAAIE,MAAM7O,KAAM,IAAI/E,YACjC,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAC1C,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EACzCoE,GAAa,GAAM,IACnBA,GAAa,GAAM,IACnBA,GAAa,EAAK,IACP,IAAZA,EACCuS,GAAqB,GACrBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACCC,GAAqB,GACrBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,GAAM,IACN,EAAM,QAIHvC,cAAM5X,GACX,OAAOiX,EAAI8C,IAAI9C,EAAIE,MAAMS,KAAMX,EAAI3O,KAAKtI,EAAM2H,UAAW3H,EAAM8E,UAAWmS,EAAI1O,KAAKvI,EAAMlR,MAAOmoB,EAAIa,KAAK9X,OAGpG6X,cAAM3S,GACX,OAAO+R,EAAI8C,IAAI9C,EAAIE,MAAMU,KAAM,IAAItU,YACjC,EACA,EAAM,EAAM,EACX2B,GAAkB,GAClBA,GAAkB,GAAM,IACxBA,GAAkB,EAAK,IACP,IAAjBA,QAIG4S,cAAM9X,GACX,MAAmB,UAAfA,EAAMlR,KACDmoB,EAAI8C,IAAI9C,EAAIE,MAAMW,KAAMb,EAAI8C,IAAI9C,EAAIE,MAAM4B,KAAM9B,EAAIwC,MAAOxC,EAAI+C,KAAM/C,EAAIqB,KAAKtY,IAE9EiX,EAAI8C,IAAI9C,EAAIE,MAAMW,KAAMb,EAAI8C,IAAI9C,EAAIE,MAAM2B,KAAM7B,EAAIuC,MAAOvC,EAAI+C,KAAM/C,EAAIqB,KAAKtY,OAIlF+X,cAAMqC,EAAI9Q,EAAqBtJ,GACpC,OAAOiX,EAAI8C,IAAI9C,EAAIE,MAAMY,KAAMd,EAAIY,KAAKuC,GAAKnD,EAAIhO,KAAKjJ,EAAOsJ,OAKxDhC,cAAMlB,GAKX,IAJA,IACEra,EAAIqa,EAAO/W,OACXgrB,KAEKtuB,KACLsuB,EAAMtuB,GAAKkrB,EAAI9O,KAAK/B,EAAOra,IAG7B,OAAOkrB,EAAI8C,IAAInqB,MAAM,MAAOqnB,EAAIE,MAAM7P,KAAM2P,EAAIkB,KAAK/R,EAAO,GAAGuB,UAAWvB,EAAO,GAAGtB,WAAWsC,OAAOiT,GAAOjT,OAAO6P,EAAIiB,KAAK9R,QAGxH8R,cAAM9R,GAKX,IAJA,IACEra,EAAIqa,EAAO/W,OACXgrB,KAEKtuB,KACLsuB,EAAMtuB,GAAKkrB,EAAI4B,KAAKzS,EAAOra,IAG7B,OAAOkrB,EAAI8C,IAAInqB,MAAM,MAAOqnB,EAAIE,MAAMe,MAAM9Q,OAAOiT,OAG9ClC,cAAMxQ,EAAW7C,GACtBA,GAAY6C,EACZ,IAAMuS,EAAoBxW,KAAK+F,MAAM3E,GAAYe,EAAa,IACxDsU,EAAoBzW,KAAK+F,MAAM3E,GAAYe,EAAa,IAE5DyP,EAAQ,IAAI/R,YACV,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAC1C,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EACzCoE,GAAa,GAAM,IACnBA,GAAa,GAAM,IACnBA,GAAa,EAAK,IACP,IAAZA,EACCuS,GAAqB,GACrBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACCC,GAAqB,GACrBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,EAAM,EAAM,EAAM,EAClB,EAAM,EACN,EAAM,EACN,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,GAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,IAAM,IAAM,IAAM,MAEtB,OAAOlD,EAAI8C,IAAI9C,EAAIE,MAAMgB,KAAM7C,MAG1B+C,cAAMrY,GACX,IACE8B,EAAU9B,EAAM8B,YAChBwT,EAAQ,IAAI/R,WAAW,EAAIzB,EAAQzS,QACnCirB,SACAvuB,SAGF,IAAKA,EAAI,EAAGA,EAAI+V,EAAQzS,OAAQtD,IAC9BuuB,EAAQxY,EAAQ/V,GAAGuuB,MACnBhF,EAAMvpB,EAAI,GAAMuuB,EAAMC,WAAa,EAChCD,EAAME,cAAgB,EACtBF,EAAMG,cAGX,OAAOxD,EAAI8C,IAAI9C,EAAIE,MAAMkB,KAAM/C,MAG1BgD,cAAMtY,GACX,OAAOiX,EAAI8C,IAAI9C,EAAIE,MAAMmB,KAAMrB,EAAIwB,KAAKzY,GAAQiX,EAAI8C,IAAI9C,EAAIE,MAAMwB,KAAM1B,EAAImC,MAAOnC,EAAI8C,IAAI9C,EAAIE,MAAMqB,KAAMvB,EAAIoC,MAAOpC,EAAI8C,IAAI9C,EAAIE,MAAMuB,KAAMzB,EAAIsC,MAAOtC,EAAI8C,IAAI9C,EAAIE,MAAMoB,KAAMtB,EAAIqC,UAGhLlC,cAAMpX,GACX,IAAIsU,KAAUqB,KAAU5pB,SAAGmL,SAAMjI,SAGjC,IAAKlD,EAAI,EAAGA,EAAIiU,EAAMsU,IAAIjlB,OAAQtD,IAEhCkD,GADAiI,EAAO8I,EAAMsU,IAAIvoB,IACN6P,WACX0Y,EAAItkB,KAAMf,IAAQ,EAAK,KACvBqlB,EAAItkB,KAAY,IAANf,GAGVqlB,EAAMA,EAAIlN,OAAO1X,MAAM/B,UAAUgC,MAAMzD,KAAKgL,IAI9C,IAAKnL,EAAI,EAAGA,EAAIiU,EAAM2V,IAAItmB,OAAQtD,IAEhCkD,GADAiI,EAAO8I,EAAM2V,IAAI5pB,IACN6P,WACX+Z,EAAI3lB,KAAMf,IAAQ,EAAK,KACvB0mB,EAAI3lB,KAAY,IAANf,GAEV0mB,EAAMA,EAAIvO,OAAO1X,MAAM/B,UAAUgC,MAAMzD,KAAKgL,IAG9C,IAAIwjB,EAAOzD,EAAI8C,IAAI9C,EAAIE,MAAME,KAAM,IAAI9T,YACnC,EACA+Q,EAAI,GACJA,EAAI,GACJA,EAAI,GACJ,IACA,IAAOtU,EAAMsU,IAAIjlB,QACjB+X,OAAOkN,GAAKlN,QACZpH,EAAM2V,IAAItmB,SACT+X,OAAOuO,KACVjI,EAAQ1N,EAAM0N,MACdE,EAAS5N,EAAM4N,OACf+M,EAAW3a,EAAMyN,WAAW,GAC5BmN,EAAW5a,EAAMyN,WAAW,GAE9B,OAAOwJ,EAAI8C,IAAI9C,EAAIE,MAAMC,KAAM,IAAI7T,YACjC,EAAM,EAAM,EACZ,EAAM,EAAM,EACZ,EAAM,EACN,EAAM,EACN,EAAM,EACN,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EACjBmK,GAAS,EAAK,IACP,IAARA,EACCE,GAAU,EAAK,IACP,IAATA,EACA,EAAM,GAAM,EAAM,EAClB,EAAM,GAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EACN,GACA,IAAM,GAAM,IAAM,IAClB,IAAM,IAAM,IAAM,IAClB,IAAM,IAAM,IAAM,GAClB,IAAM,IAAM,IAAM,GAClB,IAAM,IAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EACZ,EAAM,GACN,GAAM,KACR8M,EACAzD,EAAI8C,IAAI9C,EAAIE,MAAMG,KAAM,IAAI/T,YAC1B,EAAM,GAAM,IAAM,IAClB,EAAM,GAAM,IAAM,IAClB,EAAM,GAAM,IAAM,OACpB0T,EAAI8C,IAAI9C,EAAIE,MAAMiB,KAAM,IAAI7U,YACzBoX,GAAY,GACZA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,EACCC,GAAY,GACZA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,SAIGnD,cAAMzX,GACX,IAAI6a,EAAY7a,EAAMrC,OAAOtO,OAC7B,OAAO,IAAIkU,YACT,EACA,EAAM,EAAM,EAEZ,EACA,GAAOsX,EACP,EAAM,EACN,EAEA,EACA,GAAOA,EACP,GACA,GACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAElB,GACAzT,QAAQyT,IAAYzT,OAAOpH,EAAMrC,QAAQyJ,QAAQ,EAAM,EAAM,QAG1D4Q,cAAMhY,GACX,IAAIE,EAAaF,EAAME,WACvB,OAAO+W,EAAI8C,IAAI9C,EAAIE,MAAMa,KAAM,IAAIzU,YACjC,EAAM,EAAM,EACZ,EAAM,EAAM,EACZ,EAAM,EACN,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAMvD,EAAMc,aACZ,EAAM,GACN,EAAM,EAAM,EAAM,EACjBZ,GAAc,EAAK,IACP,IAAbA,EACA,EAAM,IACR+W,EAAI8C,IAAI9C,EAAIE,MAAMM,KAAMR,EAAIQ,KAAKzX,QAG5B8S,aAAK9S,GACV,IAAIE,EAAaF,EAAME,WACvB,OAAO+W,EAAI8C,IAAI9C,EAAIE,MAAM,QAAS,IAAI5T,YACpC,EAAM,EAAM,EACZ,EAAM,EAAM,EACZ,EAAM,EACN,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAMvD,EAAMc,aACZ,EAAM,GACN,EAAM,EAAM,EAAM,EACjBZ,GAAc,EAAK,IACP,IAAbA,EACA,EAAM,QAGHuY,cAAMzY,GACX,MAAmB,UAAfA,EAAMlR,KACHkR,EAAMmF,OAAyB,QAAhBnF,EAAMe,MAInBkW,EAAI8C,IAAI9C,EAAIE,MAAMsB,KAAMxB,EAAIyC,KAAMzC,EAAIe,KAAKhY,IAHzCiX,EAAI8C,IAAI9C,EAAIE,MAAMsB,KAAMxB,EAAIyC,KAAMzC,EAAInE,IAAI9S,IAK5CiX,EAAI8C,IAAI9C,EAAIE,MAAMsB,KAAMxB,EAAIyC,KAAMzC,EAAIG,KAAKpX,OAI/CoI,cAAMpI,GACX,IAAIiF,EAAKjF,EAAMiF,GACbH,EAAW9E,EAAM8E,SAAW9E,EAAM2H,UAClC+F,EAAQ1N,EAAM0N,MACdE,EAAS5N,EAAM4N,OACfsM,EAAoBxW,KAAK+F,MAAM3E,GAAYe,EAAa,IACxDsU,EAAoBzW,KAAK+F,MAAM3E,GAAYe,EAAa,IAC1D,OAAOoR,EAAI8C,IAAI9C,EAAIE,MAAM/O,KAAM,IAAI7E,YACjC,EACA,EAAM,EAAM,EACZ,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAC1C,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EACzC0B,GAAM,GAAM,IACZA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,EACA,EAAM,EAAM,EAAM,EACjBiV,GAAqB,GACrBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACCC,GAAqB,GACrBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EACN,EAAM,EACN,EAAM,EACN,EAAM,EACN,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,GAAM,EAAM,EAAM,EACjBzM,GAAS,EAAK,IACP,IAARA,EACA,EAAM,EACLE,GAAU,EAAK,IACP,IAATA,EACA,EAAM,QAIH3E,cAAMjJ,EAAOsJ,GAClB,IAAIwR,EAAwB7D,EAAIoB,KAAKrY,GACnCiF,EAAKjF,EAAMiF,GACX8V,EAA+BrX,KAAK+F,MAAMH,GAAuBzD,EAAa,IAC9EmV,EAA+BtX,KAAK+F,MAAMH,GAAuBzD,EAAa,IAChF,OAAOoR,EAAI8C,IAAI9C,EAAIE,MAAMlO,KACvBgO,EAAI8C,IAAI9C,EAAIE,MAAMjO,KAAM,IAAI3F,YAC1B,EACA,EAAM,EAAM,EACX0B,GAAM,GACNA,GAAM,GAAM,IACZA,GAAM,EAAK,IACN,IAALA,KAEHgS,EAAI8C,IAAI9C,EAAIE,MAAM/N,KAAM,IAAI7F,YAC1B,EACA,EAAM,EAAM,EACXwX,GAAgC,GAChCA,GAAgC,GAAM,IACtCA,GAAgC,EAAK,IACN,IAA/BA,EACAC,GAAgC,GAChCA,GAAgC,GAAM,IACtCA,GAAgC,EAAK,IACN,IAA/BA,KAEH/D,EAAI2B,KAAK5Y,EACP8a,EAAsBzrB,OACV,GACA,GACA,EACA,GACA,EACA,GACdyrB,MAQG3S,cAAMnI,GAEX,OADAA,EAAM8E,SAAW9E,EAAM8E,UAAY,WAC5BmS,EAAI8C,IAAI9C,EAAIE,MAAMhP,KAAM8O,EAAI7O,KAAKpI,GAAQiX,EAAIW,KAAK5X,OAGpD6Y,cAAM7Y,GACX,IAAIiF,EAAKjF,EAAMiF,GACf,OAAOgS,EAAI8C,IAAI9C,EAAIE,MAAM0B,KAAM,IAAItV,YACjC,EACA,EAAM,EAAM,EACX0B,GAAM,GACNA,GAAM,GAAM,IACZA,GAAM,EAAK,IACN,IAALA,EACD,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,EAClB,EAAM,EAAM,EAAM,QAIf2T,cAAM5Y,EAAO1G,GAClB,IAAIwI,EAAU9B,EAAM8B,YAClB7S,EAAM6S,EAAQzS,OACd4rB,EAAW,GAAM,GAAKhsB,EACtBkV,EAAQ,IAAIZ,WAAW0X,GACvBlvB,SAAGgW,SAAQ+C,SAAUzC,SAAMiY,SAAOY,SAcpC,IAbA5hB,GAAU,EAAI2hB,EACd9W,EAAMmH,KACJ,EACA,EAAM,GAAM,EACXrc,IAAQ,GAAM,IACdA,IAAQ,GAAM,IACdA,IAAQ,EAAK,IACR,IAANA,EACCqK,IAAW,GAAM,IACjBA,IAAW,GAAM,IACjBA,IAAW,EAAK,IACR,IAATA,GACC,GACEvN,EAAI,EAAGA,EAAIkD,EAAKlD,IAEnB+Y,GADA/C,EAASD,EAAQ/V,IACC+Y,SAClBzC,EAAON,EAAOM,KACdiY,EAAQvY,EAAOuY,MACfY,EAAMnZ,EAAOmZ,IACb/W,EAAMmH,KACHxG,IAAa,GAAM,IACnBA,IAAa,GAAM,IACnBA,IAAa,EAAK,IACR,IAAXA,EACCzC,IAAS,GAAM,IACfA,IAAS,GAAM,IACfA,IAAS,EAAK,IACR,IAAPA,EACCiY,EAAMa,WAAa,EAAKb,EAAMC,UAC9BD,EAAME,cAAgB,EACpBF,EAAMG,eAAiB,EACvBH,EAAMc,cAAgB,EACvBd,EAAMe,UACW,MAAnBf,EAAMgB,WACa,GAAnBhB,EAAMgB,WACLJ,IAAQ,GAAM,IACdA,IAAQ,GAAM,IACdA,IAAQ,EAAK,IACR,IAANA,GACC,GAAK,GAAKnvB,GAEf,OAAOkrB,EAAI8C,IAAI9C,EAAIE,MAAMyB,KAAMzU,MAG1BS,qBAAawB,GACb6Q,EAAIE,OACPF,EAAIC,OAGN,IAAIqE,EAAQtE,EAAI3P,KAAKlB,GAAStH,SAI9B,OAHAA,EAAS,IAAIyE,WAAW0T,EAAI6C,KAAKle,WAAa2f,EAAM3f,aAC7C0P,IAAI2L,EAAI6C,MACfhb,EAAOwM,IAAIiQ,EAAOtE,EAAI6C,KAAKle,YACpBkD,QC3nBX,IA2xBe0c,aAxxBb,SAAAA,EAAa9d,EAAUC,EAAQkS,EAAe4L,gGAAQC,CAAA1tB,KAAAwtB,GACpDxtB,KAAK0P,SAAWA,EAChB1P,KAAK2P,OAASA,EACd3P,KAAK6hB,cAAgBA,EACrB,IAAMtP,EAAYC,UAAUD,UAC5BvS,KAAK2tB,SAAWF,GAAUA,EAAO5a,QAAQ,UAAY,GAAKN,IAAcA,EAAUqb,MAAM,SACxF5tB,KAAK6tB,aAAc,qBAGrB7f,iCAGAqJ,wBAAgByW,GACd9tB,KAAKolB,SAAWplB,KAAKqlB,SAAWyI,eAGlCnX,4BACE3W,KAAK6tB,aAAc,eAGrBjW,eAAOyL,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,GAM1E,GAJK1X,KAAK6tB,aACR7tB,KAAK+tB,WAAW1K,EAAY4B,EAAYzN,GAGtCxX,KAAK6tB,YAAa,CACpB,IAAMG,EAAiB3K,EAAWvP,QAAQzS,OACpC4sB,EAAiBhJ,EAAWnR,QAAQzS,OACtC6sB,EAAkB1W,EAClB2W,EAAkB3W,EACtB,GAAIwW,GAAkBC,EAAgB,CAKpC,IAAIG,GAAsB/K,EAAWvP,QAAQ,GAAGD,IAAMoR,EAAWnR,QAAQ,GAAGD,KAAOoR,EAAW7N,eAC9F8W,GAAmBxY,KAAK6F,IAAI,EAAG6S,GAC/BD,GAAmBzY,KAAK6F,IAAI,GAAI6S,GAKlC,GAAIJ,EAAgB,CAEb3K,EAAW1J,YACdnK,EAAOhB,KAAK,4CACZxO,KAAK+tB,WAAW1K,EAAY4B,EAAYzN,IAE1C,IAAIqM,EAAY7jB,KAAKquB,WAAWhL,EAAY6K,EAAiBzW,EAAYC,GAEzE,GAAIuW,EAAgB,CAClB,IAAIK,SACAzK,IACFyK,EAAmBzK,EAAU0K,OAAS1K,EAAU2K,UAI7CvJ,EAAWtL,YACdnK,EAAOhB,KAAK,4CACZxO,KAAK+tB,WAAW1K,EAAY4B,EAAYzN,IAE1CxX,KAAKyuB,WAAWxJ,EAAYkJ,EAAiB1W,EAAY6W,EAAkB5W,SAI7E,GAAIuW,EAAgB,CAClB,IAAIS,EAAY1uB,KAAKyuB,WAAWxJ,EAAYkJ,EAAiB1W,EAAY,EAAGC,GACxEgX,GAAarL,EAAWtQ,OAC1B/S,KAAK2uB,gBAAgBtL,EAAY6K,EAAiBzW,EAAYiX,IAMlEpL,EAASxP,QAAQzS,QACnBrB,KAAK4uB,SAAStL,EAAU9L,GAItB0N,EAAUpR,QAAQzS,QACpBrB,KAAK6uB,UAAU3J,EAAW1N,GAI5BxX,KAAK0P,SAASsB,QAAQC,EAAMnL,0BAG9BioB,oBAAY1K,EAAY4B,EAAYzN,GAClC,IAAI9H,EAAW1P,KAAK0P,SAClBof,EAAezL,EAAWvP,QAC1Bib,EAAe9J,EAAWnR,QAC1B+N,EAAgB7hB,KAAK6hB,cACrB7K,EAAY,YACZoB,KACAlP,GAASkP,OAAQA,GACjB4W,OAAmC7uB,IAAlBH,KAAKolB,SACtBnN,SAASgX,SAmCX,GAjCID,IACF/W,EAAUgX,EAAUC,KAGlB7L,EAAW1T,QAAUmf,EAAaztB,SAKpCgiB,EAAW1J,UAAY0J,EAAWnR,WAClC1C,EAAOjB,IAAP,yBAAoC8U,EAAWnR,YAC1CmR,EAAWlM,QACV0K,EAAcgD,MAChB7N,EAAY,aACZqM,EAAWtQ,MAAQ,IACV8O,EAAciD,MACvBzB,EAAWtQ,MAAQ,QAGvBqF,EAAOC,OACLrB,UAAWA,EACXjE,MAAOsQ,EAAWtQ,MAClB6D,aAAcyM,EAAWlM,OAAS0K,EAAcgD,KAAO,IAAItP,WAAe0T,EAAIrS,aAAayM,IAC3F8L,UACErc,aAAcuQ,EAAWvQ,eAGzBkc,IAEF/W,EAAUgX,EAAUH,EAAa,GAAG3b,IAAMkQ,EAAWjM,eAAiBI,IAItEyN,EAAWqB,KAAOrB,EAAW0C,KAAOoH,EAAa1tB,OAAQ,CAG3D,IAAM+V,EAAiB6N,EAAW7N,eAClC6N,EAAWtL,UAAYvC,EACvBgB,EAAOE,OACLtB,UAAW,YACXjE,MAAOkS,EAAWlS,MAClB6D,YAAaqS,EAAIrS,aAAaqO,IAC9BkK,UACEzP,MAAOuF,EAAWvF,MAClBE,OAAQqF,EAAWrF,SAGnBoP,IACF/W,EAAUvC,KAAKgD,IAAIT,EAAS8W,EAAa,GAAG5b,IAAMiE,EAAiBI,GACnEyX,EAAUvZ,KAAKgD,IAAIuW,EAASF,EAAa,GAAGlb,IAAMuD,EAAiBI,GACnExX,KAAK0P,SAASsB,QAAQC,EAAM7L,gBAAkB6S,QAASA,KAIvDxZ,OAAO2wB,KAAKhX,GAAQ/W,QACtBqO,EAASsB,QAAQC,EAAMvL,0BAA2BwD,GAClDlJ,KAAK6tB,aAAc,EACfmB,IACFhvB,KAAKolB,SAAWnN,EAChBjY,KAAKqlB,SAAW4J,IAGlBvf,EAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWE,YAAawK,QAASpK,EAAakB,mBAAoBmJ,OAAO,EAAOC,OAAQ,8CAIlIqd,oBAAYzc,EAAOwF,EAAYC,EAAY6W,EAAkB5W,GAC3D,IAGQqS,EAGNsF,EAASC,EANPhkB,EAAS,EACXikB,EAAYvd,EAAM2H,UAClB6V,SACA7F,SACA8F,SAAUC,SAGVC,EAAe3d,EAAM8B,QACrB8b,KACAxJ,EAAYuJ,EAAatuB,OACzBwuB,EAAe7vB,KAAK8vB,cACpBb,EAAUjvB,KAAKqlB,SAgBb0K,EAAa/vB,KAAK+vB,WAEhBpC,EAAW3tB,KAAK2tB,SAEtB,GAAkB,IAAdvH,EAAJ,CAKIuH,IAMFlW,GAAekY,EAAatuB,QAAU0uB,IACrBrY,GAAsBhC,KAAKkT,IAAIpR,EAAauY,EAAaR,GAAa,IACvE7Z,KAAKkT,IAAK+G,EAAa,GAAGxc,IAAM4c,EAAad,GAAYM,EAAY,IAIlF9X,IAEHsY,EAAavY,EAAa+X,GAK5BI,EAAa1gB,QAAQ,SAAU8E,GAC7BA,EAAOZ,IAAM0c,EAAa9b,EAAOZ,IAAM8b,EAASc,GAChDhc,EAAOF,IAAMgc,EAAa9b,EAAOF,IAAMob,EAASc,KAIlDJ,EAAaK,KAAK,SAAUC,EAAGhJ,GAC7B,IAAMiJ,EAAWD,EAAEpc,IAAMoT,EAAEpT,IACrBsc,EAAWF,EAAE9c,IAAM8T,EAAE9T,IAC3B,OAAO+c,GAAaC,GAAaF,EAAEhZ,GAAKgQ,EAAEhQ,KAI5C,IAAImZ,EAAcT,EAAaU,OAAO,SAACvkB,EAAMwkB,GAAP,OAAgB5a,KAAK6F,IAAI7F,KAAKgD,IAAI5M,EAAMwkB,EAAKnd,IAAMmd,EAAKzc,MAAO,OAAQ,GAC7G,GAAIuc,EAAc,EAAG,CACnB5gB,EAAOhB,KAAP,wDAAoEkH,KAAKC,MAAMya,EAAc,IAA7F,8BACA,IAAK,IAAIryB,EAAI,EAAGA,EAAI4xB,EAAatuB,OAAQtD,IACvC4xB,EAAa5xB,GAAG8V,KAAOuc,EAK3B,IAAIrc,EAAS4b,EAAa,GAC1BD,EAAWha,KAAK6F,IAAIxH,EAAOF,IAAK,GAChC4b,EAAW/Z,KAAK6F,IAAIxH,EAAOZ,IAAK,GAGhC,IAAIod,EAAQ7a,KAAKC,OAAO+Z,EAAWK,GAAc,IAE7CtY,GACE8Y,IACEA,EAAQ,EACV/gB,EAAOjB,IAAP,OAAkBgiB,EAAlB,kDACSA,GAAS,GAClB/gB,EAAOjB,IAAP,QAAoBgiB,EAApB,8CAIFb,EAAWK,EACXJ,EAAa,GAAG9b,IAAM6b,EAEtBD,EAAW/Z,KAAK6F,IAAIkU,EAAWc,EAAOR,GACtCJ,EAAa,GAAGxc,IAAMsc,EACtBjgB,EAAOjB,IAAP,2BAAsCmH,KAAKC,MAAM8Z,EAAW,IAA5D,IAAmE/Z,KAAKC,MAAM+Z,EAAW,IAAzF,UAAsGa,EAAtG,QAGMb,EAGV3b,EAAS4b,EAAaA,EAAatuB,OAAS,GAC5CiuB,EAAU5Z,KAAK6F,IAAIxH,EAAOF,IAAK,GAC/Bwb,EAAU3Z,KAAK6F,IAAIxH,EAAOZ,IAAK,EAAGmc,GAK9B3B,IACF6B,EAAoB9Z,KAAKC,OAAO2Z,EAAUI,IAAaC,EAAatuB,OAAS,KAI/E,IADA,IAAImvB,EAAS,EAAGC,EAAU,EACjB1yB,EAAI,EAAGA,EAAIqoB,EAAWroB,IAAK,CAGlC,IADA,IAAIgW,EAAS4b,EAAa5xB,GAAI0jB,EAAQ1N,EAAO0N,MAAOiP,EAAUjP,EAAMpgB,OAAQsvB,EAAY,EAC/EhS,EAAI,EAAGA,EAAI+R,EAAS/R,IAC3BgS,GAAalP,EAAM9C,GAAGzV,KAAK7H,OAG7BovB,GAAWE,EACXH,GAAUE,EACV3c,EAAO1S,OAASsvB,EAKd5c,EAAOF,IAFL8Z,EAEW+B,EAAW3xB,EAAIyxB,EAGf9Z,KAAK6F,IAAIxH,EAAOF,IAAK6b,GAGpC3b,EAAOZ,IAAMuC,KAAK6F,IAAIxH,EAAOZ,IAAKY,EAAOF,KAK3C,IAAI+c,EAAWH,EAAW,EAAID,EAAU,EACxC,IACE7G,EAAO,IAAIpU,WAAWqb,GACtB,MAAOpvB,GAEP,YADAxB,KAAK0P,SAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWI,UAAWsK,QAASpK,EAAamB,kBAAmBkJ,OAAO,EAAOmW,MAAOsJ,EAAUxf,qCAAsCwf,IAGjL,IAAI1mB,EAAO,IAAIC,SAASwf,EAAKjc,QAC7BxD,EAAK2mB,UAAU,EAAGD,GAClBjH,EAAKrM,IAAI2L,EAAIE,MAAMQ,KAAM,GAEzB,IAAK,IAAI5rB,EAAI,EAAGA,EAAIqoB,EAAWroB,IAAK,CAMlC,IALA,IAAIglB,EAAY4M,EAAa5xB,GAC3B+yB,EAAiB/N,EAAUtB,MAC3BsP,EAAkB,EAClBC,SAEOrS,EAAI,EAAG+R,EAAUI,EAAezvB,OAAQsd,EAAI+R,EAAS/R,IAAK,CACjE,IAAIhL,EAAOmd,EAAenS,GACxBsS,EAAWtd,EAAKzK,KAChBgoB,EAAcvd,EAAKzK,KAAK0E,WAC1B1D,EAAK2mB,UAAUvlB,EAAQ4lB,GACvB5lB,GAAU,EACVqe,EAAKrM,IAAI2T,EAAU3lB,GACnBA,GAAU4lB,EACVH,GAAmB,EAAIG,EAGzB,GAAKvD,EAkCHqD,EAAwBtb,KAAK6F,IAAI,EAAGiU,EAAoB9Z,KAAKC,OAAOoN,EAAU5P,IAAM4P,EAAUlP,KAAO2b,QAlCxF,CAEb,GAAIzxB,EAAIqoB,EAAY,EAClBoJ,EAAoBG,EAAa5xB,EAAI,GAAG8V,IAAMkP,EAAUlP,QACnD,CACL,IAAIlE,EAAS3P,KAAK2P,OAChBwhB,EAAoBpO,EAAUlP,IAAM8b,EAAa5xB,EAAI,EAAIA,EAAI,EAAIA,GAAG8V,IACtE,GAAIlE,EAAOyhB,uBAAwB,CAMjC,IAAIC,EAAgB1hB,EAAO0hB,cACzBC,EAAe5b,KAAK+F,MAAM4V,EAAgB9B,GAC1CgC,IAAmBjD,EAAmBmB,EAAWnB,EAAmBiB,EAAYvvB,KAAKwxB,cAAgBzO,EAAU5P,IAC7Goe,GAAkBD,IAGpB9B,EAAoB+B,GAAkBJ,GACd,IACtB3B,EAAoB2B,GAGtB3hB,EAAOjB,IAAP,uBAAkCgjB,GAAkB,GAApD,2CAAiG/B,EAAoB,GAArH,kCAEAA,EAAoB2B,OAGtB3B,EAAoB2B,EAGxBH,EAAwBtb,KAAKC,MAAMoN,EAAU5P,IAAM4P,EAAUlP,KAM/D+b,EAAc5tB,MACZqS,KAAM0c,EAENja,SAAU0Y,EACVtC,IAAK8D,EACL1E,OACEa,UAAW,EACXX,aAAc,EACdC,cAAe,EACfa,WAAY,EACZf,UAAWxJ,EAAUzjB,IAAM,EAAI,EAC/B+tB,UAAWtK,EAAUzjB,IAAM,EAAI,KAKrCU,KAAK+vB,WAAaT,EAAUE,EAC5B,IAAIjN,GAAUvQ,EAAMuQ,QAIpB,GAHAvQ,EAAM/Q,IAAM,EACZ+Q,EAAMwe,OAAS,EACfxe,EAAMuQ,QAAU,EACZqN,EAAcvuB,QAAUmR,UAAUD,UAAUE,cAAcI,QAAQ,WAAa,EAAG,CACpF,IAAIyZ,GAAQsD,EAAc,GAAGtD,MAG7BA,GAAMC,UAAY,EAClBD,GAAMe,UAAY,EAEpBrb,EAAM8B,QAAU8b,EAChB7F,EAAOd,EAAIc,KAAK/X,EAAMkF,iBAAkBwY,EAAU1d,GAClDA,EAAM8B,WAEN,IAAI5K,IACFuoB,MAAO1H,EACP2H,MAAO/H,EACP6E,SAAUiB,EAAWF,EACrBhB,QAASc,EAAUG,GAAqBD,EACxC5T,SAAU+T,EAAWH,EACrBoC,OAAQ3xB,KAAK+vB,WAAaR,EAC1BzuB,KAAM,QACN8wB,UAAU,EACVC,UAAU,EACVC,GAAIlC,EAAcvuB,OAClBkhB,QAASA,IAGX,OADAviB,KAAK0P,SAASsB,QAAQC,EAAMpL,kBAAmBqD,IACxCA,iBAGTmlB,oBAAYrc,EAAOwF,EAAYC,EAAYC,GACzC,IAAMN,EAAiBpF,EAAMoF,eAC3B2a,EAAe/f,EAAM2H,UACrBqY,EAAc5a,EAAiB2a,EAE/BE,GADoBjgB,EAAMmF,MAAQ,KAAO,MACC6a,EAC1CnC,EAAe7vB,KAAK8vB,cACpBb,EAAUjvB,KAAKqlB,SACf6M,GAAWlgB,EAAMmF,OAASnX,KAAK6hB,cAAcgD,KAE3CvZ,SACF6mB,SACAC,SACAzI,SAAMI,SACN0F,SAAUJ,SACVM,EAAe3d,EAAM8B,QACrB8b,KACA4B,EAAexxB,KAAKwxB,aA4BtB,GAlBA/Z,GAAekY,EAAatuB,QAAUmwB,IACrB9Z,GAAsBhC,KAAKkT,IAAIpR,EAAaga,EAAepa,GAAkB,IAC9E1B,KAAKkT,IAAK+G,EAAa,GAAGxc,IAAMqe,EAAevC,GAAY,GAAKgD,GAIhFtC,EAAa1gB,QAAQ,SAAU8E,GAC7BA,EAAOZ,IAAMY,EAAOF,IAAMgc,EAAa9b,EAAOZ,IAAM8b,EAASzX,EAAaJ,KAWhD,KAL5BuY,EAAeA,EAAa0C,OAAO,SAAUte,GAC3C,OAAOA,EAAOZ,KAAO,KAIN9R,OAAjB,CAoBA,GAhBKoW,IAMD+Z,EALG9Z,EAKYF,EAAaJ,EAHbuY,EAAa,GAAGxc,KAa/BnB,EAAMmF,MAER,IADA,IAAMmb,EAAsBtyB,KAAK2P,OAAO2iB,oBAC/Bv0B,EAAI,EAAGw0B,EAAUf,EAAczzB,EAAI4xB,EAAatuB,QAAS,CAEhE,IAA8BkvB,EAA1Bxc,EAAS4b,EAAa5xB,GAE1BwyB,EADUxc,EAAOZ,IACHof,EAEd,IAAMzb,EAAWpB,KAAKkT,IAAI,IAAO2H,EAAQnZ,GAGzC,GAAImZ,IAAU+B,EAAsBL,EAClCziB,EAAOhB,KAAP,6BAAyC+jB,EAAUnb,GAAgBob,QAAQ,GAA3E,YAAyF9c,KAAKC,MAAMmB,GAApG,gBACA6Y,EAAahtB,OAAO5E,EAAG,GACvBiU,EAAM/Q,KAAO8S,EAAOJ,KAAKtS,YAQtB,GAAIkvB,GAAS+B,EAAsBL,GAAuBnb,EAhgBrC,KAggB6Eyb,EAAS,CAC9G,IAAIE,EAAU/c,KAAKC,MAAM4a,EAAQ0B,GACjCziB,EAAOhB,KAAP,aAAyBikB,EAAzB,mBAAmDF,EAAUnb,GAAgBob,QAAQ,GAArF,YAAmG9c,KAAKC,MAAM,IAAO4a,EAAQnZ,GAA7H,YACA,IAAK,IAAIuH,EAAI,EAAGA,EAAI8T,EAAS9T,IAAK,CAChC,IAAI+T,EAAWhd,KAAK6F,IAAIgX,EAAS,IACjCH,EAAYrJ,EAAIC,eAAehX,EAAMU,eAAiBV,EAAMe,MAAOf,EAAMc,iBAEvEtD,EAAOjB,IAAI,qFACX6jB,EAAYre,EAAOJ,KAAKC,YAE1B+b,EAAahtB,OAAO5E,EAAG,GAAK4V,KAAMye,EAAWjf,IAAKuf,EAAU7e,IAAK6e,IACjE1gB,EAAM/Q,KAAOmxB,EAAU/wB,OACvBkxB,GAAWN,EACXl0B,IAIFgW,EAAOZ,IAAMY,EAAOF,IAAM0e,EAC1BA,GAAWN,EACXl0B,SAGI2X,KAAKkT,IAAI2H,GAGbxc,EAAOZ,IAAMY,EAAOF,IAAM0e,EAC1BA,GAAWN,EACXl0B,IAKN,IAAK,IAAI4gB,EAAI,EAAGyH,EAAYuJ,EAAatuB,OAAQsd,EAAIyH,EAAWzH,IAAK,CACnE,IAAIgU,EAAchD,EAAahR,GAC3BhL,EAAOgf,EAAYhf,KACnBR,EAAMwf,EAAYxf,IAGtB,QAAgBhT,IAAZkvB,EACF8C,EAAUrb,SAAWpB,KAAKC,OAAOxC,EAAMkc,GAAW2C,OAC7C,CACL,IAAIzB,EAAQ7a,KAAKC,MAAM,KAAQxC,EAAMqe,GAAgBpa,GACnDwb,EAAmB,EAGrB,GAAInb,GAAczF,EAAMmF,OAElBoZ,EAAO,CACT,GAAIA,EAAQ,GAAKA,EAhjBK,IAijBpBqC,EAAmBld,KAAKC,OAAOxC,EAAMqe,GAAgBS,GACrDziB,EAAOjB,IAAOgiB,EAAd,oDACIqC,EAAmB,KACrBR,EAAYrJ,EAAIC,eAAehX,EAAMU,eAAiBV,EAAMe,MAAOf,EAAMc,iBAEvEsf,EAAYze,EAAKC,YAGnB5B,EAAM/Q,KAAO2xB,EAAmBR,EAAU/wB,aAGvC,GAAIkvB,GAAS,GAAI,CAEtB/gB,EAAOjB,IAAP,uDAAkEijB,EAAepa,GAAgBob,QAAQ,GAAzG,MAAiHrf,EAAMiE,GAAgBob,QAAQ,GAA/I,MAAwJjC,EAAxJ,MACAve,EAAM/Q,KAAO0S,EAAK/F,WAClB,SAGFuF,EAAMqe,EAKV,GADA/B,EAAWtc,IACPnB,EAAM/Q,IAAM,GAkBd,OAfA,IAAI2vB,EAAWsB,EAAUlgB,EAAM/Q,IAAM+Q,EAAM/Q,IAAM,EACjDqK,EAAS4mB,EAAU,EAAI,EACvB,IACEvI,EAAO,IAAIpU,WAAWqb,GACtB,MAAOpvB,GAEP,YADAxB,KAAK0P,SAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWI,UAAWsK,QAASpK,EAAamB,kBAAmBkJ,OAAO,EAAOmW,MAAOsJ,EAAUxf,qCAAsCwf,IAG5KsB,IACU,IAAI/nB,SAASwf,EAAKjc,QAC1BmjB,UAAU,EAAGD,GAClBjH,EAAKrM,IAAI2L,EAAIE,MAAMQ,KAAM,IAM7B,IAAK,IAAI5rB,EAAI,EAAGA,EAAI60B,EAAkB70B,KACpCq0B,EAAYrJ,EAAIC,eAAehX,EAAMU,eAAiBV,EAAMe,MAAOf,EAAMc,iBAEvEtD,EAAOjB,IAAI,qFACX6jB,EAAYze,EAAKC,YAEnB+V,EAAKrM,IAAI8U,EAAW9mB,GACpBA,GAAU8mB,EAAUxkB,WACpBukB,GACE9d,KAAM+d,EAAUxkB,WAChBsf,IAAK,EACLpW,SAAU,KACVwV,OACEa,UAAW,EACXX,aAAc,EACdC,cAAe,EACfa,WAAY,EACZf,UAAW,IAGfqD,EAAc5tB,KAAKmwB,GAGvBxI,EAAKrM,IAAI3J,EAAMrI,GACf,IAAIunB,EAAUlf,EAAK/F,WACnBtC,GAAUunB,EAEVV,GACE9d,KAAMwe,EACN3F,IAAK,EACLpW,SAAU,EACVwV,OACEa,UAAW,EACXX,aAAc,EACdC,cAAe,EACfa,WAAY,EACZf,UAAW,IAGfqD,EAAc5tB,KAAKmwB,GACnB9C,EAAUlc,EAEZ,IAAI2f,EAAqB,EACrB1M,EAAYwJ,EAAcvuB,OAM9B,GAJI+kB,GAAa,IACf0M,EAAqBlD,EAAcxJ,EAAY,GAAGtP,SAClDqb,EAAUrb,SAAWgc,GAEnB1M,EAAW,CAEbpmB,KAAKwxB,aAAeA,EAAenC,EAAU2C,EAAcc,EAE3D9gB,EAAM/Q,IAAM,EACZ+Q,EAAM8B,QAAU8b,EAEd7F,EADEmI,EACK,IAAI3c,WAEJ0T,EAAIc,KAAK/X,EAAMkF,iBAAkBuY,EAAWuC,EAAahgB,GAGlEA,EAAM8B,WACN,IAAM2E,EAAQgX,EAAWrY,EACnBpC,EAAMwc,EAAepa,EACrByM,GACJ4N,MAAO1H,EACP2H,MAAO/H,EACP6E,SAAU/V,EACV8V,OAAQvZ,EACR2G,SAAUlD,EACVkZ,OAAQ3c,EACRlU,KAAM,QACN8wB,UAAU,EACVC,UAAU,EACVC,GAAI1L,GAGN,OADApmB,KAAK0P,SAASsB,QAAQC,EAAMpL,kBAAmBge,GACxCA,EAET,OAAO,mBAGT8K,yBAAiB3c,EAAOwF,EAAYC,EAAYiX,GAC9C,IAAItX,EAAiBpF,EAAMoF,eAEzB4a,EAAc5a,GADCpF,EAAME,WAAaF,EAAME,WAAakF,GAErDoa,EAAexxB,KAAKwxB,aAGpB7V,QAA6Bxb,IAAjBqxB,EAA6BA,EAAe9C,EAAU/S,SAAWvE,GAAkBpX,KAAKqlB,SACpGsM,EAASjD,EAAUiD,OAASva,EAAiBpX,KAAKqlB,SAGlD/R,EADiB,KACD0e,EAGhB5L,EAAY1Q,KAAKiK,MAAMgS,EAAShW,GAAYrI,GAG5Cyf,EAAchK,EAAIC,eAAehX,EAAMU,eAAiBV,EAAMe,MAAOf,EAAMc,cAI7E,GAFAtD,EAAOhB,KAAK,qBAEPukB,EAAL,CAMA,IADA,IAAIjf,KACK/V,EAAI,EAAGA,EAAIqoB,EAAWroB,IAAK,CAClC,IAAIyV,EAAQmI,EAAW5d,EAAIuV,EAC3BQ,EAAQ9R,MAAO2R,KAAMof,EAAa5f,IAAKK,EAAOK,IAAKL,IACnDxB,EAAM/Q,KAAO8xB,EAAY1xB,OAE3B2Q,EAAM8B,QAAUA,EAEhB9T,KAAKquB,WAAWrc,EAAOwF,EAAYC,QAZjCjI,EAAOrN,MAAM,4GAejBysB,kBAAU5c,EAAOwF,GACf,IAAInW,EAAS2Q,EAAM8B,QAAQzS,OAAQ0S,SAC7BqD,EAAiBpF,EAAMoF,eACvBa,EAAUjY,KAAKolB,SACf6J,EAAUjvB,KAAKqlB,SAErB,GAAIhkB,EAAQ,CACV,IAAK,IAAI0U,EAAQ,EAAGA,EAAQ1U,EAAQ0U,KAClChC,EAAS/B,EAAM8B,QAAQiC,IAGhB5C,KAAQY,EAAOZ,IAAM8E,GAAWb,EACvCrD,EAAOF,KAAQE,EAAOF,IAAMob,GAAW7X,EAEzCpX,KAAK0P,SAASsB,QAAQC,EAAMrL,uBAC1BkO,QAAS9B,EAAM8B,UAInB9B,EAAM8B,WACN0D,EAAaA,eAGfqX,mBAAW7c,EAAOwF,GAChBxF,EAAM8B,QAAQkc,KAAK,SAAUC,EAAGhJ,GAC9B,OAAQgJ,EAAE9c,IAAM8T,EAAE9T,MAGpB,IAAI9R,EAAS2Q,EAAM8B,QAAQzS,OAAQ0S,SAC7BqD,EAAiBpF,EAAMoF,eACvBa,EAAUjY,KAAKolB,SAErB,GAAI/jB,EAAQ,CACV,IAAK,IAAI0U,EAAQ,EAAGA,EAAQ1U,EAAQ0U,KAClChC,EAAS/B,EAAM8B,QAAQiC,IAGhB5C,KAAQY,EAAOZ,IAAM8E,GAAWb,EAEzCpX,KAAK0P,SAASsB,QAAQC,EAAMtL,uBAC1BmO,QAAS9B,EAAM8B,UAInB9B,EAAM8B,WACN0D,EAAaA,eAGfsY,uBAAe9wB,EAAOg0B,GACpB,IAAI1nB,SACJ,QAAkBnL,IAAd6yB,EACF,OAAOh0B,EAaT,IAREsM,EAFE0nB,EAAYh0B,GAEJ,WAGD,WAKJ0W,KAAKkT,IAAI5pB,EAAQg0B,GAAa,YACnCh0B,GAASsM,EAGX,OAAOtM,YCvvBIi0B,aAvCb,SAAAA,EAAavjB,gGAAUwjB,CAAAlzB,KAAAizB,GACrBjzB,KAAK0P,SAAWA,qBAGlB1B,iCAGAqJ,wCAGAV,0CAGAiB,eAAOyL,EAAY4B,EAAY3B,EAAU4B,EAAW1N,EAAYC,EAAYC,EAAoByb,GAC9F,IAAIzjB,EAAW1P,KAAK0P,SAChB0jB,EAAa,GACb/P,IACF+P,GAAc,SAGZnO,IACFmO,GAAc,SAGhB1jB,EAASsB,QAAQC,EAAMpL,mBACrB4rB,MAAO0B,EACP3E,SAAUhX,EACVmE,SAAUnE,EACV1W,KAAMsyB,EACNxB,WAAYvO,EACZwO,WAAY5M,EACZ6M,GAAI,EACJvP,QAAS,IAGX7S,EAASsB,QAAQC,EAAMnL,mBCrB3B,IACMutB,EADSplB,IACYolB,YAoGZC,aAjGb,SAAAA,EAAa5jB,EAAUmS,EAAelS,EAAQ8d,gGAAQ8F,CAAAvzB,KAAAszB,GACpDtzB,KAAK0P,SAAWA,EAChB1P,KAAK6hB,cAAgBA,EACrB7hB,KAAK2P,OAASA,EACd3P,KAAKytB,OAASA,qBAGhBzf,mBACE,IAAIwlB,EAAUxzB,KAAKwzB,QACfA,GACFA,EAAQxlB,uBAIZhM,cAAMkH,EAAM6W,EAAanJ,EAAa3E,EAAY4E,EAAYW,EAAYic,EAAeC,EAAajc,EAAYX,EAAUY,EAAoBic,GAC9I,GAAKzqB,EAAK0E,WAAa,GAAsB,MAAfmS,GAA4C,MAAnBA,EAAYzgB,KAAwC,YAAvBygB,EAAYkC,OAAuB,CACrH,IAAI/B,EAAYlgB,KAAKkgB,UACJ,MAAbA,IACFA,EAAYlgB,KAAKkgB,UAAY,IAAIzQ,EAAUzP,KAAK0P,SAAU1P,KAAK2P,SAGjE,IAAIgR,EAAY3gB,KAEZ4zB,SACJ,IACEA,EAAYP,EAAYQ,MACxB,MAAOzyB,GACPwyB,EAAYE,KAAKD,MAEnB3T,EAAUjX,QAAQC,EAAM6W,EAAYzgB,IAAIoO,OAAQqS,EAAYjX,GAAG4E,OAAQ,SAAUkT,GAC/E,IAAImT,SACJ,IACEA,EAAUV,EAAYQ,MACtB,MAAOzyB,GACP2yB,EAAUD,KAAKD,MAEjBlT,EAAUjR,SAASsB,QAAQC,EAAMxL,gBAAkBuuB,OAASC,OAAQL,EAAWM,SAAUH,KACzFpT,EAAUwT,cAAc,IAAI5e,WAAWqL,GAAgBb,EAAa,IAAIxK,WAAWqB,GAAc3E,EAAY4E,EAAYW,EAAYic,EAAeC,EAAajc,EAAYX,EAAUY,EAAoBic,UAG7M3zB,KAAKm0B,cAAc,IAAI5e,WAAWrM,GAAO6W,EAAa,IAAIxK,WAAWqB,GAAc3E,EAAY4E,EAAYW,EAAYic,EAAeC,EAAajc,EAAYX,EAAUY,EAAoBic,gBAIjMQ,uBAAejrB,EAAM6W,EAAanJ,EAAa3E,EAAY4E,EAAYW,EAAYic,EAAeC,EAAajc,EAAYX,EAAUY,EAAoBic,GACvJ,IAAIH,EAAUxzB,KAAKwzB,QACnB,IAAKA,IAIDC,GAAiBC,KAAiB1zB,KAAK4R,MAAM1I,GAAQ,CAavD,IAZA,IAAMwG,EAAW1P,KAAK0P,SAChBmS,EAAgB7hB,KAAK6hB,cACrBlS,EAAS3P,KAAK2P,OAEdykB,IACFC,MAAOzS,EAAWhK,MAAO4V,IACzB6G,MAAOtc,EAAYH,MAAOqb,IAC1BoB,MAAO7d,EAAYoB,MAAO4V,IAC1B6G,MAAOxL,EAAYjR,MAAO4V,IAIrBzvB,EAAI,EAAGkD,EAAMmzB,EAAU/yB,OAAQtD,EAAIkD,EAAKlD,IAAK,CACpD,IAAMu2B,EAAMF,EAAUr2B,GAChB6T,EAAQ0iB,EAAID,MAAMziB,MACxB,GAAIA,EAAM1I,GAAO,CACf,IAAMuN,EAAUzW,KAAKyW,QAAU,IAAI6d,EAAI1c,MAAMlI,EAAUC,EAAQkS,EAAe7hB,KAAKytB,QACnF+F,EAAU,IAAIc,EAAID,MAAM3kB,EAAU+G,EAAS9G,EAAQkS,GACnD7hB,KAAK4R,MAAQA,EACb,OAGJ,IAAK4hB,EAEH,YADA9jB,EAASsB,QAAQC,EAAM9K,OAASrF,KAAM0F,EAAWE,YAAawK,QAASpK,EAAakB,mBAAoBmJ,OAAO,EAAMC,OAAQ,yCAG/HpR,KAAKwzB,QAAUA,EAEjB,IAAM/c,EAAUzW,KAAKyW,SAEjBgd,GAAiBC,KACnBF,EAAQ7c,iBAAiBC,EAAa3E,EAAY4E,EAAYC,GAC9DL,EAAQE,oBAEN8c,IACFD,EAAQnc,eAAesc,GACvBld,EAAQY,eAAesc,IAEa,mBAA3BH,EAAQxR,gBACjBwR,EAAQxR,eAAejC,GAGzByT,EAAQjc,OAAOrO,EAAMsO,EAAYC,EAAYC,yBC1ClC6c,EAAA,QAjEf,SAAApmB,GAEA,IAAAuB,EAAA,IAAqB8kB,EAAAvE,EACrBvgB,EAAAsB,QAAA,SAAAyjB,KAAAvrB,GACAwG,EAAA7O,KAAA4zB,OAAAvrB,IAGAwG,EAAAglB,IAAA,SAAAD,KAAAvrB,GACAwG,EAAAlN,eAAAiyB,KAAAvrB,IAGA,IAAAyrB,EAAA,SAAAC,EAAA1rB,GACAiF,EAAA0mB,aAAsBJ,MAAAG,EAAA1rB,UAGtBiF,EAAA2mB,iBAAA,mBAAAF,GACA,IAAA1rB,EAAA0rB,EAAA1rB,KAEA,OAAAA,EAAA6rB,KACA,WACA,IAAAplB,EAAAqlB,KAAAC,MAAA/rB,EAAAyG,QACAxB,EAAAqlB,QAAA,IAAyB0B,EAAaxlB,EAAAxG,EAAA2Y,cAAAlS,EAAAzG,EAAAukB,QACtC,KjBmBwB,SAAU5e,GAChC,IAAoB,IAAhBA,GAA+C,iBAAvB,IAAOA,EAAP,YAAAsmB,EAAOtmB,IAA0B,CAC3DD,EAAsBC,EAGpB,QACA,MACA,OACA,OACA,SAIF,IACEH,EAAeH,MACf,MAAO2B,GACPxB,EAAiBL,QAGnBK,EAAiBL,EiBrCb+mB,EAAU,IAAAzlB,EAAArB,OACX,MAAA9M,GACPU,QAAAsM,KAAA,wCAGAmmB,EAAA,aACA,MACA,YACAxmB,EAAAqlB,QAAAxxB,KAAAkH,SAAA6W,YAAA7W,EAAA0N,YAAA1N,EAAA+I,WAAA/I,EAAA2N,WAAA3N,EAAAsO,WAAAtO,EAAAuqB,cAAAvqB,EAAAwqB,YAAAxqB,EAAAuO,WAAAvO,EAAA4N,SAAA5N,EAAAwO,mBAAAxO,EAAAyqB,mBAQAjkB,EAAAtN,GAAcizB,EAAK5vB,eAAAkvB,GACnBjlB,EAAAtN,GAAcizB,EAAK3vB,0BAAAivB,GACnBjlB,EAAAtN,GAAcizB,EAAKvvB,YAAA6uB,GACnBjlB,EAAAtN,GAAcizB,EAAKlvB,MAAAwuB,GACnBjlB,EAAAtN,GAAcizB,EAAKzvB,sBAAA+uB,GACnBjlB,EAAAtN,GAAcizB,EAAK1vB,sBAAAgvB,GACnBjlB,EAAAtN,GAAcizB,EAAKjwB,eAAAuvB,GAGnBjlB,EAAAtN,GAAcizB,EAAKxvB,kBAAA,SAAA+uB,EAAA1rB,GACnB,IAAAosB,KACAvkB,GAAmB0jB,MAAAG,EAAA1rB,QACnBA,EAAAuoB,QACA1gB,EAAA0gB,MAAAvoB,EAAAuoB,MAAA/jB,OACA4nB,EAAAtzB,KAAAkH,EAAAuoB,MAAA/jB,eACAxE,EAAAuoB,OAEAvoB,EAAAwoB,QACA3gB,EAAA2gB,MAAAxoB,EAAAwoB,MAAAhkB,OACA4nB,EAAAtzB,KAAAkH,EAAAwoB,MAAAhkB,eACAxE,EAAAwoB,OAEAvjB,EAAA0mB,YAAA9jB,EAAAukB","file":"47787d2ff658c642fb35.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","/**\n * @readonly\n * @enum {string}\n */\nconst HlsEvents = {\n  // fired before MediaSource is attaching to media element - data: { media }\n  MEDIA_ATTACHING: 'hlsMediaAttaching',\n  // fired when MediaSource has been succesfully attached to media element - data: { }\n  MEDIA_ATTACHED: 'hlsMediaAttached',\n  // fired before detaching MediaSource from media element - data: { }\n  MEDIA_DETACHING: 'hlsMediaDetaching',\n  // fired when MediaSource has been detached from media element - data: { }\n  MEDIA_DETACHED: 'hlsMediaDetached',\n  // fired when we buffer is going to be reset - data: { }\n  BUFFER_RESET: 'hlsBufferReset',\n  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  BUFFER_CODECS: 'hlsBufferCodecs',\n  // fired when sourcebuffers have been created - data: { tracks : tracks }\n  BUFFER_CREATED: 'hlsBufferCreated',\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  BUFFER_APPENDING: 'hlsBufferAppending',\n  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\n  BUFFER_APPENDED: 'hlsBufferAppended',\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\n  BUFFER_EOS: 'hlsBufferEos',\n  // fired when the media buffer should be flushed - data { startOffset, endOffset }\n  BUFFER_FLUSHING: 'hlsBufferFlushing',\n  // fired when the media buffer has been flushed - data: { }\n  BUFFER_FLUSHED: 'hlsBufferFlushed',\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  MANIFEST_LOADING: 'hlsManifestLoading',\n  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}\n  MANIFEST_LOADED: 'hlsManifestLoaded',\n  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n  MANIFEST_PARSED: 'hlsManifestParsed',\n  // fired when a level switch is requested - data: { level : id of new level }\n  LEVEL_SWITCHING: 'hlsLevelSwitching',\n  // fired when a level switch is effective - data: { level : id of new level }\n  LEVEL_SWITCHED: 'hlsLevelSwitched',\n  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\n  LEVEL_LOADING: 'hlsLevelLoading',\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }\n  LEVEL_LOADED: 'hlsLevelLoaded',\n  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\n  LEVEL_UPDATED: 'hlsLevelUpdated',\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',\n  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\n  LEVELS_UPDATED: 'hlsLevelsUpdated',\n  // fired to notify that levels have changed outside of a manifest parsing event - data: { levels }\n  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',\n  // fired when an audio track switching is requested - data: { id : audio track id }\n  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',\n  // fired when an audio track switch actually occurs - data: { id : audio track id }\n  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',\n  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\n  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',\n  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }\n  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',\n  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\n  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',\n  // fired to notify that subtitle tracks were cleared as a result of stopping the media\n  SUBTITLE_TRACKS_CLEARED: 'hlsSubtitleTracksCleared',\n  // fired when an subtitle track switch occurs - data: { id : subtitle track id }\n  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',\n  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\n  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',\n  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }\n  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\n  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',\n  // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\n  CUES_PARSED: 'hlsCuesParsed',\n  // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\n  NON_NATIVE_TEXT_TRACKS_FOUND: 'hlsNonNativeTextTracksFound',\n  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }\n  INIT_PTS_FOUND: 'hlsInitPtsFound',\n  // fired when a fragment loading starts - data: { frag : fragment object }\n  FRAG_LOADING: 'hlsFragLoading',\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }\n  FRAG_LOADED: 'hlsFragLoaded',\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n  FRAG_DECRYPTED: 'hlsFragDecrypted',\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\n  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',\n  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  FRAG_PARSING_DATA: 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n  FRAG_PARSED: 'hlsFragParsed',\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }\n  FRAG_BUFFERED: 'hlsFragBuffered',\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  FRAG_CHANGED: 'hlsFragChanged',\n  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }\n  FPS_DROP: 'hlsFpsDrop',\n  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }\n  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\n  ERROR: 'hlsError',\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\n  DESTROYING: 'hlsDestroying',\n  // fired when a decrypt key loading starts - data: { frag : fragment object }\n  KEY_LOADING: 'hlsKeyLoading',\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }\n  KEY_LOADED: 'hlsKeyLoaded',\n  // fired upon stream controller state transitions - data: { previousState, nextState }\n  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'\n};\n\nexport default HlsEvents;\n","export const ErrorTypes = {\n  // Identifier for a network error (loading error / timeout ...)\n  NETWORK_ERROR: 'networkError',\n  // Identifier for a media Error (video/parsing/mediasource error)\n  MEDIA_ERROR: 'mediaError',\n  // EME (encrypted media extensions) errors\n  KEY_SYSTEM_ERROR: 'keySystemError',\n  // Identifier for a mux Error (demuxing/remuxing)\n  MUX_ERROR: 'muxError',\n  // Identifier for all other errors\n  OTHER_ERROR: 'otherError'\n};\n\n/**\n * @enum {ErrorDetails}\n * @typedef {string} ErrorDetail\n */\nexport const ErrorDetails = {\n  KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',\n  KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',\n  KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',\n  KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_ERROR: 'manifestLoadError',\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_PARSING_ERROR: 'manifestParsingError',\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',\n  // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: error reason, level: index of the bad level }\n  LEVEL_EMPTY_ERROR: 'levelEmptyError',\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_ERROR: 'levelLoadError',\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  LEVEL_SWITCH_ERROR: 'levelSwitchError',\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  FRAG_LOAD_ERROR: 'fragLoadError',\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  FRAG_DECRYPT_ERROR: 'fragDecryptError',\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  FRAG_PARSING_ERROR: 'fragParsingError',\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  REMUX_ALLOC_ERROR: 'remuxAllocError',\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  KEY_LOAD_ERROR: 'keyLoadError',\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }\n  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',\n  // Identifier for a buffer append error - data: append error description\n  BUFFER_APPEND_ERROR: 'bufferAppendError',\n  // Identifier for a buffer appending error event - data: appending error description\n  BUFFER_APPENDING_ERROR: 'bufferAppendingError',\n  // Identifier for a buffer stalled error event\n  BUFFER_STALLED_ERROR: 'bufferStalledError',\n  // Identifier for a buffer full event\n  BUFFER_FULL_ERROR: 'bufferFullError',\n  // Identifier for a buffer seek over hole event\n  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  INTERNAL_EXCEPTION: 'internalException'\n};\n","export default class AESCrypto {\n  constructor (subtle, iv) {\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n\n  decrypt (data, key) {\n    return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);\n  }\n}\n","class FastAESKey {\n  constructor (subtle, key) {\n    this.subtle = subtle;\n    this.key = key;\n  }\n\n  expandKey () {\n    return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);\n  }\n}\n\nexport default FastAESKey;\n","// PKCS7\nexport function removePadding (buffer) {\n  const outputBytes = buffer.byteLength;\n  const paddingBytes = outputBytes && (new DataView(buffer)).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return buffer.slice(0, outputBytes - paddingBytes);\n  } else {\n    return buffer;\n  }\n}\n\nclass AESDecryptor {\n  constructor () {\n    // Static after running initTable\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n\n    // Changes during runtime\n    this.key = new Uint32Array(0);\n\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_ (arrayBuffer) {\n    let view = new DataView(arrayBuffer);\n    let newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n\n    return newArray;\n  }\n\n  initTable () {\n    let sBox = this.sBox;\n    let invSBox = this.invSBox;\n    let subMix = this.subMix;\n    let subMix0 = subMix[0];\n    let subMix1 = subMix[1];\n    let subMix2 = subMix[2];\n    let subMix3 = subMix[3];\n    let invSubMix = this.invSubMix;\n    let invSubMix0 = invSubMix[0];\n    let invSubMix1 = invSubMix[1];\n    let invSubMix2 = invSubMix[2];\n    let invSubMix3 = invSubMix[3];\n\n    let d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = (i << 1) ^ 0x11b;\n      }\n    }\n\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n      sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      let x2 = d[x];\n      let x4 = d[x2];\n      let x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n      subMix0[x] = (t << 24) | (t >>> 8);\n      subMix1[x] = (t << 16) | (t >>> 16);\n      subMix2[x] = (t << 8) | (t >>> 24);\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n      invSubMix0[sx] = (t << 24) | (t >>> 8);\n      invSubMix1[sx] = (t << 16) | (t >>> 16);\n      invSubMix2[sx] = (t << 8) | (t >>> 24);\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n\n  expandKey (keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    let key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n\n    while (offset < key.length && sameKey) {\n      sameKey = (key[offset] === this.key[offset]);\n      offset++;\n    }\n\n    if (sameKey) {\n      return;\n    }\n\n    this.key = key;\n    let keySize = this.keySize = key.length;\n\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n\n    let ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n\n    let keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    let invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    let sbox = this.sBox;\n    let rcon = this.rcon;\n\n    let invSubMix = this.invSubMix;\n    let invSubMix0 = invSubMix[0];\n    let invSubMix1 = invSubMix[1];\n    let invSubMix2 = invSubMix[2];\n    let invSubMix3 = invSubMix[3];\n\n    let prev;\n    let t;\n\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = (t << 8) | (t >>> 24);\n\n        // Sub word\n        t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 0xff] << 16) | (sbox[(t >>> 8) & 0xff] << 8) | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[(ksRow / keySize) | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 0xff] << 16) | (sbox[(t >>> 8) & 0xff] << 8) | sbox[t & 0xff];\n      }\n\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[(t >>> 16) & 0xff]] ^ invSubMix2[sbox[(t >>> 8) & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap (word) {\n    return (word << 24) | ((word & 0xff00) << 8) | ((word & 0xff0000) >> 8) | (word >>> 24);\n  }\n\n  decrypt (inputArrayBuffer, offset, aesIV, removePKCS7Padding) {\n    let nRounds = this.keySize + 6;\n    let invKeySchedule = this.invKeySchedule;\n    let invSBOX = this.invSBox;\n\n    let invSubMix = this.invSubMix;\n    let invSubMix0 = invSubMix[0];\n    let invSubMix1 = invSubMix[1];\n    let invSubMix2 = invSubMix[2];\n    let invSubMix3 = invSubMix[3];\n\n    let initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n\n    let inputInt32 = new Int32Array(inputArrayBuffer);\n    let outputInt32 = new Int32Array(inputInt32.length);\n\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n\n    let ksRow, i;\n    let swapWord = this.networkToHostOrderSwap;\n\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[(s1 >> 16) & 0xff] ^ invSubMix2[(s2 >> 8) & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[(s2 >> 16) & 0xff] ^ invSubMix2[(s3 >> 8) & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[(s3 >> 16) & 0xff] ^ invSubMix2[(s0 >> 8) & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[(s0 >> 16) & 0xff] ^ invSubMix2[(s1 >> 8) & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = ((invSBOX[s0 >>> 24] << 24) ^ (invSBOX[(s1 >> 16) & 0xff] << 16) ^ (invSBOX[(s2 >> 8) & 0xff] << 8) ^ invSBOX[s3 & 0xff]) ^ invKeySchedule[ksRow];\n      t1 = ((invSBOX[s1 >>> 24] << 24) ^ (invSBOX[(s2 >> 16) & 0xff] << 16) ^ (invSBOX[(s3 >> 8) & 0xff] << 8) ^ invSBOX[s0 & 0xff]) ^ invKeySchedule[ksRow + 1];\n      t2 = ((invSBOX[s2 >>> 24] << 24) ^ (invSBOX[(s3 >> 16) & 0xff] << 16) ^ (invSBOX[(s0 >> 8) & 0xff] << 8) ^ invSBOX[s1 & 0xff]) ^ invKeySchedule[ksRow + 2];\n      t3 = ((invSBOX[s3 >>> 24] << 24) ^ (invSBOX[(s0 >> 16) & 0xff] << 16) ^ (invSBOX[(s1 >> 8) & 0xff] << 8) ^ invSBOX[s2 & 0xff]) ^ invKeySchedule[ksRow + 3];\n      ksRow = ksRow + 3;\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n\n      offset = offset + 4;\n    }\n\n    return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;\n  }\n\n  destroy () {\n    this.key = undefined;\n    this.keySize = undefined;\n    this.ksRows = undefined;\n\n    this.sBox = undefined;\n    this.invSBox = undefined;\n    this.subMix = undefined;\n    this.invSubMix = undefined;\n    this.keySchedule = undefined;\n    this.invKeySchedule = undefined;\n\n    this.rcon = undefined;\n  }\n}\n\nexport default AESDecryptor;\n","export function getSelfScope () {\n  // see https://stackoverflow.com/a/11237259/589493\n  if (typeof window === 'undefined') {\n    /* eslint-disable-next-line no-undef */\n    return self;\n  } else {\n    return window;\n  }\n}\n","import { getSelfScope } from './get-self-scope';\n\nfunction noop () {}\n\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\n\nlet exportedLogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction formatMsg (type, msg) {\n  msg = '[' + type + '] > ' + msg;\n  return msg;\n}\n\nconst global = getSelfScope();\n\nfunction consolePrintFn (type) {\n  const func = global.console[type];\n  if (func) {\n    return function (...args) {\n      if (args[0]) {\n        args[0] = formatMsg(type, args[0]);\n      }\n\n      func.apply(global.console, args);\n    };\n  }\n  return noop;\n}\n\nfunction exportLoggerFunctions (debugConfig, ...functions) {\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\n\nexport var enableLogs = function (debugConfig) {\n  if (debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig,\n      // Remove out from list here to hard-disable a log-level\n      // 'trace',\n      'debug',\n      'log',\n      'info',\n      'warn',\n      'error'\n    );\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log();\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n};\n\nexport var logger = exportedLogger;\n","import AESCrypto from './aes-crypto';\nimport FastAESKey from './fast-aes-key';\nimport AESDecryptor from './aes-decryptor';\n\nimport { ErrorTypes, ErrorDetails } from '../errors';\nimport { logger } from '../utils/logger';\n\nimport Event from '../events';\n\nimport { getSelfScope } from '../utils/get-self-scope';\n\n// see https://stackoverflow.com/a/11237259/589493\nconst global = getSelfScope(); // safeguard for code that might run both on worker and main thread\n\nclass Decrypter {\n  constructor (observer, config, { removePKCS7Padding = true } = {}) {\n    this.logEnabled = true;\n    this.observer = observer;\n    this.config = config;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = global.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {}\n    }\n    this.disableWebCrypto = !this.subtle;\n  }\n\n  isSync () {\n    return (this.disableWebCrypto && this.config.enableSoftwareAES);\n  }\n\n  decrypt (data, key, iv, callback) {\n    if (this.disableWebCrypto && this.config.enableSoftwareAES) {\n      if (this.logEnabled) {\n        logger.log('JS AES decrypt');\n        this.logEnabled = false;\n      }\n      let decryptor = this.decryptor;\n      if (!decryptor) {\n        this.decryptor = decryptor = new AESDecryptor();\n      }\n\n      decryptor.expandKey(key);\n      callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));\n    } else {\n      if (this.logEnabled) {\n        logger.log('WebCrypto AES decrypt');\n        this.logEnabled = false;\n      }\n      const subtle = this.subtle;\n      if (this.key !== key) {\n        this.key = key;\n        this.fastAesKey = new FastAESKey(subtle, key);\n      }\n\n      this.fastAesKey.expandKey()\n        .then((aesKey) => {\n          // decrypt using web crypto\n          let crypto = new AESCrypto(subtle, iv);\n          crypto.decrypt(data, aesKey)\n            .catch((err) => {\n              this.onWebCryptoError(err, data, key, iv, callback);\n            })\n            .then((result) => {\n              callback(result);\n            });\n        })\n        .catch((err) => {\n          this.onWebCryptoError(err, data, key, iv, callback);\n        });\n    }\n  }\n\n  onWebCryptoError (err, data, key, iv, callback) {\n    if (this.config.enableSoftwareAES) {\n      logger.log('WebCrypto Error, disable WebCrypto API');\n      this.disableWebCrypto = true;\n      this.logEnabled = true;\n      this.decrypt(data, key, iv, callback);\n    } else {\n      logger.error(`decrypting error : ${err.message}`);\n      this.observer.trigger(Event.ERROR, { type: ErrorTypes.MEDIA_ERROR, details: ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });\n    }\n  }\n\n  destroy () {\n    let decryptor = this.decryptor;\n    if (decryptor) {\n      decryptor.destroy();\n      this.decryptor = undefined;\n    }\n  }\n}\n\nexport default Decrypter;\n","export const isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n","/**\n *  ADTS parser helper\n */\nimport { logger } from '../utils/logger';\nimport { ErrorTypes, ErrorDetails } from '../errors';\n\nimport Event from '../events';\n\nimport { getSelfScope } from '../utils/get-self-scope';\n\nexport function getAudioConfig (observer, data, offset, audioCodec) {\n  let adtsObjectType, // :int\n    adtsSampleingIndex, // :int\n    adtsExtensionSampleingIndex, // :int\n    adtsChanelConfig, // :int\n    config,\n    userAgent = navigator.userAgent.toLowerCase(),\n    manifestCodec = audioCodec,\n    adtsSampleingRates = [\n      96000, 88200,\n      64000, 48000,\n      44100, 32000,\n      24000, 22050,\n      16000, 12000,\n      11025, 8000,\n      7350];\n  // byte 2\n  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;\n  adtsSampleingIndex = ((data[offset + 2] & 0x3C) >>> 2);\n  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {\n    observer.trigger(Event.ERROR, { type: ErrorTypes.MEDIA_ERROR, details: ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: `invalid ADTS sampling index:${adtsSampleingIndex}` });\n    return;\n  }\n  adtsChanelConfig = ((data[offset + 2] & 0x01) << 2);\n  // byte 3\n  adtsChanelConfig |= ((data[offset + 3] & 0xC0) >>> 6);\n  logger.log(`manifest codec:${audioCodec},ADTS data:type:${adtsObjectType},sampleingIndex:${adtsSampleingIndex}[${adtsSampleingRates[adtsSampleingIndex]}Hz],channelConfig:${adtsChanelConfig}`);\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSampleingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4);\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSampleingIndex = adtsSampleingIndex;\n    }\n    // Android : always use AAC\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSampleingIndex = adtsSampleingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4);\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n    if ((audioCodec && ((audioCodec.indexOf('mp4a.40.29') !== -1) ||\n      (audioCodec.indexOf('mp4a.40.5') !== -1))) ||\n      (!audioCodec && adtsSampleingIndex >= 6)) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && ((adtsSampleingIndex >= 6 && adtsChanelConfig === 1) ||\n            /vivaldi/i.test(userAgent)) ||\n        (!audioCodec && adtsChanelConfig === 1)) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n      adtsExtensionSampleingIndex = adtsSampleingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  config[0] = adtsObjectType << 3;\n  // samplingFrequencyIndex\n  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;\n  config[1] |= (adtsSampleingIndex & 0x01) << 7;\n  // channelConfiguration\n  config[1] |= adtsChanelConfig << 3;\n  if (adtsObjectType === 5) {\n    // adtsExtensionSampleingIndex\n    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;\n    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: ('mp4a.40.' + adtsObjectType), manifestCodec: manifestCodec };\n}\n\nexport function isHeaderPattern (data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\n\nexport function getHeaderLength (data, offset) {\n  return (data[offset + 1] & 0x01 ? 7 : 9);\n}\n\nexport function getFullFrameLength (data, offset) {\n  return ((data[offset + 3] & 0x03) << 11) |\n    (data[offset + 4] << 3) |\n    ((data[offset + 5] & 0xE0) >>> 5);\n}\n\nexport function isHeader (data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function probe (data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // ADTS header Length\n    let headerLength = getHeaderLength(data, offset);\n    // ADTS frame Length\n    let frameLength = headerLength;\n    if (offset + 5 < data.length) {\n      frameLength = getFullFrameLength(data, offset);\n    }\n\n    let newOffset = offset + frameLength;\n    if (newOffset === data.length || (newOffset + 1 < data.length && isHeaderPattern(data, newOffset))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function initTrackConfig (track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    let config = getAudioConfig(observer, data, offset, audioCodec);\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    logger.log(`parsed codec:${track.codec},rate:${config.samplerate},nb channel:${config.channelCount}`);\n  }\n}\n\nexport function getFrameDuration (samplerate) {\n  return 1024 * 90000 / samplerate;\n}\n\nexport function parseFrameHeader (data, offset, pts, frameIndex, frameDuration) {\n  let headerLength, frameLength, stamp;\n  let length = data.length;\n\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  headerLength = getHeaderLength(data, offset);\n  // retrieve frame size\n  frameLength = getFullFrameLength(data, offset);\n  frameLength -= headerLength;\n\n  if ((frameLength > 0) && ((offset + headerLength + frameLength) <= length)) {\n    stamp = pts + frameIndex * frameDuration;\n    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n    return { headerLength, frameLength, stamp };\n  }\n\n  return undefined;\n}\n\nexport function appendFrame (track, data, offset, pts, frameIndex) {\n  let frameDuration = getFrameDuration(track.samplerate);\n  let header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);\n  if (header) {\n    let stamp = header.stamp;\n    let headerLength = header.headerLength;\n    let frameLength = header.frameLength;\n\n    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n    let aacSample = {\n      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n\n    track.samples.push(aacSample);\n    track.len += frameLength;\n\n    return { sample: aacSample, length: frameLength + headerLength };\n  }\n\n  return undefined;\n}\n","/**\n * ID3 parser\n */\nclass ID3 {\n  /**\n   * Returns true if an ID3 header can be found at offset in data\n   * @param {Uint8Array} data - The data to search in\n   * @param {number} offset - The offset at which to start searching\n   * @return {boolean} - True if an ID3 header is found\n   */\n  static isHeader (data, offset) {\n    /*\n    * http://id3.org/id3v2.3.0\n    * [0]     = 'I'\n    * [1]     = 'D'\n    * [2]     = '3'\n    * [3,4]   = {Version}\n    * [5]     = {Flags}\n    * [6-9]   = {ID3 Size}\n    *\n    * An ID3v2 tag can be detected with the following pattern:\n    *  $49 44 33 yy yy xx zz zz zz zz\n    * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n    */\n    if (offset + 10 <= data.length) {\n      // look for 'ID3' identifier\n      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n        // check version is within range\n        if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if an ID3 footer can be found at offset in data\n   * @param {Uint8Array} data - The data to search in\n   * @param {number} offset - The offset at which to start searching\n   * @return {boolean} - True if an ID3 footer is found\n   */\n  static isFooter (data, offset) {\n    /*\n    * The footer is a copy of the header, but with a different identifier\n    */\n    if (offset + 10 <= data.length) {\n      // look for '3DI' identifier\n      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n        // check version is within range\n        if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n   * @param {Uint8Array} data - The data to search in\n   * @param {number} offset - The offset at which to start searching\n   * @return {Uint8Array} - The block of data containing any ID3 tags found\n   */\n  static getID3Data (data, offset) {\n    const front = offset;\n    let length = 0;\n\n    while (ID3.isHeader(data, offset)) {\n      // ID3 header is 10 bytes\n      length += 10;\n\n      const size = ID3._readSize(data, offset + 6);\n      length += size;\n\n      if (ID3.isFooter(data, offset + 10)) {\n        // ID3 footer is 10 bytes\n        length += 10;\n      }\n\n      offset += length;\n    }\n\n    if (length > 0) {\n      return data.subarray(front, front + length);\n    }\n\n    return undefined;\n  }\n\n  static _readSize (data, offset) {\n    let size = 0;\n    size = ((data[offset] & 0x7f) << 21);\n    size |= ((data[offset + 1] & 0x7f) << 14);\n    size |= ((data[offset + 2] & 0x7f) << 7);\n    size |= (data[offset + 3] & 0x7f);\n    return size;\n  }\n\n  /**\n   * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n   * @param {Uint8Array} data - Block of data containing one or more ID3 tags\n   * @return {number} - The timestamp\n   */\n  static getTimeStamp (data) {\n    const frames = ID3.getID3Frames(data);\n    for (let i = 0; i < frames.length; i++) {\n      const frame = frames[i];\n      if (ID3.isTimeStampFrame(frame)) {\n        return ID3._readTimeStamp(frame);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n   * @param {ID3 frame} frame\n   */\n  static isTimeStampFrame (frame) {\n    return (frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp');\n  }\n\n  static _getFrameData (data) {\n    /*\n    Frame ID       $xx xx xx xx (four characters)\n    Size           $xx xx xx xx\n    Flags          $xx xx\n    */\n    const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    const size = ID3._readSize(data, 4);\n\n    // skip frame id, size, and flags\n    let offset = 10;\n\n    return { type, size, data: data.subarray(offset, offset + size) };\n  }\n\n  /**\n   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n   * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags\n   * @return {ID3 frame[]} - Array of ID3 frame objects\n   */\n  static getID3Frames (id3Data) {\n    let offset = 0;\n    const frames = [];\n\n    while (ID3.isHeader(id3Data, offset)) {\n      const size = ID3._readSize(id3Data, offset + 6);\n      // skip past ID3 header\n      offset += 10;\n      const end = offset + size;\n      // loop through frames in the ID3 tag\n      while (offset + 8 < end) {\n        const frameData = ID3._getFrameData(id3Data.subarray(offset));\n        const frame = ID3._decodeFrame(frameData);\n        if (frame) {\n          frames.push(frame);\n        }\n\n        // skip frame header and frame data\n        offset += frameData.size + 10;\n      }\n\n      if (ID3.isFooter(id3Data, offset)) {\n        offset += 10;\n      }\n    }\n\n    return frames;\n  }\n\n  static _decodeFrame (frame) {\n    if (frame.type === 'PRIV') {\n      return ID3._decodePrivFrame(frame);\n    } else if (frame.type[0] === 'T') {\n      return ID3._decodeTextFrame(frame);\n    } else if (frame.type[0] === 'W') {\n      return ID3._decodeURLFrame(frame);\n    }\n\n    return undefined;\n  }\n\n  static _readTimeStamp (timeStampFrame) {\n    if (timeStampFrame.data.byteLength === 8) {\n      const data = new Uint8Array(timeStampFrame.data);\n      // timestamp is 33 bit expressed as a big-endian eight-octet number,\n      // with the upper 31 bits set to zero.\n      const pts33Bit = data[3] & 0x1;\n      let timestamp = (data[4] << 23) +\n                      (data[5] << 15) +\n                      (data[6] << 7) +\n                       data[7];\n      timestamp /= 45;\n\n      if (pts33Bit) {\n        timestamp += 47721858.84;\n      } // 2^32 / 90\n\n      return Math.round(timestamp);\n    }\n\n    return undefined;\n  }\n\n  static _decodePrivFrame (frame) {\n    /*\n    Format: <text string>\\0<binary data>\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n\n    const owner = ID3._utf8ArrayToStr(frame.data, true);\n    const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n\n    return { key: frame.type, info: owner, data: privateData.buffer };\n  }\n\n  static _decodeTextFrame (frame) {\n    if (frame.size < 2) {\n      return undefined;\n    }\n\n    if (frame.type === 'TXXX') {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Description}\\0{Value}\n      */\n      let index = 1;\n      const description = ID3._utf8ArrayToStr(frame.data.subarray(index));\n\n      index += description.length + 1;\n      const value = ID3._utf8ArrayToStr(frame.data.subarray(index));\n\n      return { key: frame.type, info: description, data: value };\n    } else {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Value}\n      */\n      const text = ID3._utf8ArrayToStr(frame.data.subarray(1));\n      return { key: frame.type, data: text };\n    }\n  }\n\n  static _decodeURLFrame (frame) {\n    if (frame.type === 'WXXX') {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Description}\\0{URL}\n      */\n      if (frame.size < 2) {\n        return undefined;\n      }\n\n      let index = 1;\n      const description = ID3._utf8ArrayToStr(frame.data.subarray(index));\n\n      index += description.length + 1;\n      const value = ID3._utf8ArrayToStr(frame.data.subarray(index));\n\n      return { key: frame.type, info: description, data: value };\n    } else {\n      /*\n      Format:\n      [0-?] = {URL}\n      */\n      const url = ID3._utf8ArrayToStr(frame.data);\n      return { key: frame.type, data: url };\n    }\n  }\n\n  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n  /* utf.js - UTF-8 <=> UTF-16 convertion\n   *\n   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n   * Version: 1.0\n   * LastModified: Dec 25 1999\n   * This library is free.  You can redistribute it and/or modify it.\n   */\n  static _utf8ArrayToStr (array, exitOnNull = false) {\n    const len = array.length;\n    let c;\n    let char2;\n    let char3;\n    let out = '';\n    let i = 0;\n    while (i < len) {\n      c = array[i++];\n      if (c === 0x00 && exitOnNull) {\n        return out;\n      } else if (c === 0x00 || c === 0x03) {\n        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n        continue;\n      }\n      switch (c >> 4) {\n      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12: case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n        break;\n      default:\n      }\n    }\n    return out;\n  }\n}\n\nconst utf8ArrayToStr = ID3._utf8ArrayToStr;\n\nexport default ID3;\n\nexport { utf8ArrayToStr };\n","/**\n * AAC demuxer\n */\nimport * as ADTS from './adts';\nimport { logger } from '../utils/logger';\nimport ID3 from '../demux/id3';\n\nclass AACDemuxer {\n  constructor (observer, remuxer, config) {\n    this.observer = observer;\n    this.config = config;\n    this.remuxer = remuxer;\n  }\n\n  resetInitSegment (initSegment, audioCodec, videoCodec, duration) {\n    this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };\n  }\n\n  resetTimeStamp () {\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe (data) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = ID3.getID3Data(data, 0) || [];\n    let offset = id3Data.length;\n\n    for (let length = data.length; offset < length; offset++) {\n      if (ADTS.probe(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // feed incoming data to the front of the parsing pipeline\n  append (data, timeOffset, contiguous, accurateTimeOffset) {\n    let track = this._audioTrack;\n    let id3Data = ID3.getID3Data(data, 0) || [];\n    let timestamp = ID3.getTimeStamp(id3Data);\n    let pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;\n    let frameIndex = 0;\n    let stamp = pts;\n    let length = data.length;\n    let offset = id3Data.length;\n\n    let id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];\n\n    while (offset < length - 1) {\n      if (ADTS.isHeader(data, offset) && (offset + 5) < length) {\n        ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n        let frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          stamp = frame.sample.pts;\n          frameIndex++;\n        } else {\n          logger.log('Unable to parse AAC frame');\n          break;\n        }\n      } else if (ID3.isHeader(data, offset)) {\n        id3Data = ID3.getID3Data(data, offset);\n        id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });\n        offset += id3Data.length;\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n\n    this.remuxer.remux(track,\n      { samples: [] },\n      { samples: id3Samples, inputTimeScale: 90000 },\n      { samples: [] },\n      timeOffset,\n      contiguous,\n      accurateTimeOffset);\n  }\n\n  destroy () {\n  }\n}\n\nexport default AACDemuxer;\n","/**\n * MP4 demuxer\n */\nimport { logger } from '../utils/logger';\nimport Event from '../events';\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\n\nclass MP4Demuxer {\n  constructor (observer, remuxer) {\n    this.observer = observer;\n    this.remuxer = remuxer;\n  }\n\n  resetTimeStamp (initPTS) {\n    this.initPTS = initPTS;\n  }\n\n  resetInitSegment (initSegment, audioCodec, videoCodec, duration) {\n    // jshint unused:false\n    if (initSegment && initSegment.byteLength) {\n      const initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);\n\n      // default audio codec if nothing specified\n      // TODO : extract that from initsegment\n      if (audioCodec == null) {\n        audioCodec = 'mp4a.40.5';\n      }\n\n      if (videoCodec == null) {\n        videoCodec = 'avc1.42e01e';\n      }\n\n      const tracks = {};\n      if (initData.audio && initData.video) {\n        tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };\n      } else {\n        if (initData.audio) {\n          tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };\n        }\n\n        if (initData.video) {\n          tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };\n        }\n      }\n      this.observer.trigger(Event.FRAG_PARSING_INIT_SEGMENT, { tracks });\n    } else {\n      if (audioCodec) {\n        this.audioCodec = audioCodec;\n      }\n\n      if (videoCodec) {\n        this.videoCodec = videoCodec;\n      }\n    }\n  }\n\n  static probe (data) {\n    // ensure we find a moof box in the first 16 kB\n    return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;\n  }\n\n  static bin2str (buffer) {\n    return String.fromCharCode.apply(null, buffer);\n  }\n\n  static readUint16 (buffer, offset) {\n    if (buffer.data) {\n      offset += buffer.start;\n      buffer = buffer.data;\n    }\n\n    const val = buffer[offset] << 8 |\n                buffer[offset + 1];\n\n    return val < 0 ? 65536 + val : val;\n  }\n\n  static readUint32 (buffer, offset) {\n    if (buffer.data) {\n      offset += buffer.start;\n      buffer = buffer.data;\n    }\n\n    const val = buffer[offset] << 24 |\n                buffer[offset + 1] << 16 |\n                buffer[offset + 2] << 8 |\n                buffer[offset + 3];\n    return val < 0 ? 4294967296 + val : val;\n  }\n\n  static writeUint32 (buffer, offset, value) {\n    if (buffer.data) {\n      offset += buffer.start;\n      buffer = buffer.data;\n    }\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = (value >> 16) & 0xff;\n    buffer[offset + 2] = (value >> 8) & 0xff;\n    buffer[offset + 3] = value & 0xff;\n  }\n\n  // Find the data for a box specified by its path\n  static findBox (data, path) {\n    let results = [],\n      i, size, type, end, subresults, start, endbox;\n\n    if (data.data) {\n      start = data.start;\n      end = data.end;\n      data = data.data;\n    } else {\n      start = 0;\n      end = data.byteLength;\n    }\n\n    if (!path.length) {\n      // short-circuit the search for empty paths\n      return null;\n    }\n\n    for (i = start; i < end;) {\n      size = MP4Demuxer.readUint32(data, i);\n      type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));\n      endbox = size > 1 ? i + size : end;\n\n      if (type === path[0]) {\n        if (path.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push({ data: data, start: i + 8, end: endbox });\n        } else {\n          // recursively search for the next box along the path\n          subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));\n          if (subresults.length) {\n            results = results.concat(subresults);\n          }\n        }\n      }\n      i = endbox;\n    }\n\n    // we've finished searching all of data\n    return results;\n  }\n\n  static parseSegmentIndex (initSegment) {\n    const moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];\n    const moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data\n\n    let index = 0;\n    let sidx = MP4Demuxer.findBox(initSegment, ['sidx']);\n    let references;\n\n    if (!sidx || !sidx[0]) {\n      return null;\n    }\n\n    references = [];\n    sidx = sidx[0];\n\n    const version = sidx.data[0];\n\n    // set initial offset, we skip the reference ID (not needed)\n    index = version === 0 ? 8 : 16;\n\n    const timescale = MP4Demuxer.readUint32(sidx, index);\n    index += 4;\n\n    // TODO: parse earliestPresentationTime and firstOffset\n    // usually zero in our case\n    let earliestPresentationTime = 0;\n    let firstOffset = 0;\n\n    if (version === 0) {\n      index += 8;\n    } else {\n      index += 16;\n    }\n\n    // skip reserved\n    index += 2;\n\n    let startByte = sidx.end + firstOffset;\n\n    const referencesCount = MP4Demuxer.readUint16(sidx, index);\n    index += 2;\n\n    for (let i = 0; i < referencesCount; i++) {\n      let referenceIndex = index;\n\n      const referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);\n      referenceIndex += 4;\n\n      const referenceSize = referenceInfo & 0x7FFFFFFF;\n      const referenceType = (referenceInfo & 0x80000000) >>> 31;\n\n      if (referenceType === 1) {\n        console.warn('SIDX has hierarchical references (not supported)');\n        return;\n      }\n\n      const subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);\n      referenceIndex += 4;\n\n      references.push({\n        referenceSize,\n        subsegmentDuration, // unscaled\n        info: {\n          duration: subsegmentDuration / timescale,\n          start: startByte,\n          end: startByte + referenceSize - 1\n        }\n      });\n\n      startByte += referenceSize;\n\n      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n      // for |sapDelta|.\n      referenceIndex += 4;\n\n      // skip to next ref\n      index = referenceIndex;\n    }\n\n    return {\n      earliestPresentationTime,\n      timescale,\n      version,\n      referencesCount,\n      references,\n      moovEndOffset\n    };\n  }\n\n  /**\n   * Parses an MP4 initialization segment and extracts stream type and\n   * timescale values for any declared tracks. Timescale values indicate the\n   * number of clock ticks per second to assume for time-based values\n   * elsewhere in the MP4.\n   *\n   * To determine the start time of an MP4, you need two pieces of\n   * information: the timescale unit and the earliest base media decode\n   * time. Multiple timescales can be specified within an MP4 but the\n   * base media decode time is always expressed in the timescale from\n   * the media header box for the track:\n   * ```\n   * moov > trak > mdia > mdhd.timescale\n   * moov > trak > mdia > hdlr\n   * ```\n   * @param init {Uint8Array} the bytes of the init segment\n   * @return {object} a hash of track type to timescale values or null if\n   * the init segment is malformed.\n   */\n  static parseInitSegment (initSegment) {\n    let result = [];\n    let traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);\n\n    traks.forEach(trak => {\n      const tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];\n      if (tkhd) {\n        let version = tkhd.data[tkhd.start];\n        let index = version === 0 ? 12 : 20;\n        let trackId = MP4Demuxer.readUint32(tkhd, index);\n\n        const mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];\n        if (mdhd) {\n          version = mdhd.data[mdhd.start];\n          index = version === 0 ? 12 : 20;\n          const timescale = MP4Demuxer.readUint32(mdhd, index);\n\n          const hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];\n          if (hdlr) {\n            const hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));\n            let type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];\n            if (type) {\n              // extract codec info. TODO : parse codec details to be able to build MIME type\n              let codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);\n              if (codecBox.length) {\n                codecBox = codecBox[0];\n                let codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));\n                logger.log(`MP4Demuxer:${type}:${codecType} found`);\n              }\n              result[trackId] = { timescale: timescale, type: type };\n              result[type] = { timescale: timescale, id: trackId };\n            }\n          }\n        }\n      }\n    });\n    return result;\n  }\n\n  /**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\n  static getStartDTS (initData, fragment) {\n    let trafs, baseTimes, result;\n\n    // we need info from two childrend of each track fragment box\n    trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);\n\n    // determine the start times for each track\n    baseTimes = [].concat.apply([], trafs.map(function (traf) {\n      return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {\n        let id, scale, baseTime;\n\n        // get the track id from the tfhd\n        id = MP4Demuxer.readUint32(tfhd, 4);\n        // assume a 90kHz clock if no timescale was specified\n        scale = initData[id].timescale || 90e3;\n\n        // get the base media decode time from the tfdt\n        baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {\n          let version, result;\n\n          version = tfdt.data[tfdt.start];\n          result = MP4Demuxer.readUint32(tfdt, 4);\n          if (version === 1) {\n            result *= Math.pow(2, 32);\n\n            result += MP4Demuxer.readUint32(tfdt, 8);\n          }\n          return result;\n        })[0];\n        // convert base time to seconds\n        return baseTime / scale;\n      });\n    }));\n\n    // return the minimum\n    result = Math.min.apply(null, baseTimes);\n    return isFinite(result) ? result : 0;\n  }\n\n  static offsetStartDTS (initData, fragment, timeOffset) {\n    MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {\n      return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {\n      // get the track id from the tfhd\n        let id = MP4Demuxer.readUint32(tfhd, 4);\n        // assume a 90kHz clock if no timescale was specified\n        let timescale = initData[id].timescale || 90e3;\n\n        // get the base media decode time from the tfdt\n        MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {\n          let version = tfdt.data[tfdt.start];\n          let baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);\n          if (version === 0) {\n            MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);\n          } else {\n            baseMediaDecodeTime *= Math.pow(2, 32);\n            baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);\n            baseMediaDecodeTime -= timeOffset * timescale;\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n            const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n            const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n            MP4Demuxer.writeUint32(tfdt, 4, upper);\n            MP4Demuxer.writeUint32(tfdt, 8, lower);\n          }\n        });\n      });\n    });\n  }\n\n  // feed incoming data to the front of the parsing pipeline\n  append (data, timeOffset, contiguous, accurateTimeOffset) {\n    let initData = this.initData;\n    if (!initData) {\n      this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);\n      initData = this.initData;\n    }\n    let startDTS, initPTS = this.initPTS;\n    if (initPTS === undefined) {\n      let startDTS = MP4Demuxer.getStartDTS(initData, data);\n      this.initPTS = initPTS = startDTS - timeOffset;\n      this.observer.trigger(Event.INIT_PTS_FOUND, { initPTS: initPTS });\n    }\n    MP4Demuxer.offsetStartDTS(initData, data, initPTS);\n    startDTS = MP4Demuxer.getStartDTS(initData, data);\n    this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);\n  }\n\n  destroy () {}\n}\n\nexport default MP4Demuxer;\n","/**\n *  MPEG parser helper\n */\n\nconst MpegAudio = {\n\n  BitratesMap: [\n    32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,\n    32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,\n    32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320,\n    32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256,\n    8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n\n  SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],\n\n  SamplesCoefficients: [\n    // MPEG 2.5\n    [\n      0, // Reserved\n      72, // Layer3\n      144, // Layer2\n      12 // Layer1\n    ],\n    // Reserved\n    [\n      0, // Reserved\n      0, // Layer3\n      0, // Layer2\n      0 // Layer1\n    ],\n    // MPEG 2\n    [\n      0, // Reserved\n      72, // Layer3\n      144, // Layer2\n      12 // Layer1\n    ],\n    // MPEG 1\n    [\n      0, // Reserved\n      144, // Layer3\n      144, // Layer2\n      12 // Layer1\n    ]\n  ],\n\n  BytesInSlot: [\n    0, // Reserved\n    1, // Layer3\n    1, // Layer2\n    4 // Layer1\n  ],\n\n  appendFrame: function (track, data, offset, pts, frameIndex) {\n    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n    if (offset + 24 > data.length) {\n      return undefined;\n    }\n\n    let header = this.parseHeader(data, offset);\n    if (header && offset + header.frameLength <= data.length) {\n      let frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n      let stamp = pts + frameIndex * frameDuration;\n      let sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };\n\n      track.config = [];\n      track.channelCount = header.channelCount;\n      track.samplerate = header.sampleRate;\n      track.samples.push(sample);\n      track.len += header.frameLength;\n\n      return { sample, length: header.frameLength };\n    }\n\n    return undefined;\n  },\n\n  parseHeader: function (data, offset) {\n    let headerB = (data[offset + 1] >> 3) & 3;\n    let headerC = (data[offset + 1] >> 1) & 3;\n    let headerE = (data[offset + 2] >> 4) & 15;\n    let headerF = (data[offset + 2] >> 2) & 3;\n    let headerG = (data[offset + 2] >> 1) & 1;\n    if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {\n      let columnInBitrates = headerB === 3 ? (3 - headerC) : (headerC === 3 ? 3 : 4);\n      let bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;\n      let columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;\n      let sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];\n      let channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n      let sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];\n      let bytesInSlot = MpegAudio.BytesInSlot[headerC];\n      let samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n      let frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;\n\n      return { sampleRate, channelCount, frameLength, samplesPerFrame };\n    }\n\n    return undefined;\n  },\n\n  isHeaderPattern: function (data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n  },\n\n  isHeader: function (data, offset) {\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {\n      return true;\n    }\n\n    return false;\n  },\n\n  probe: function (data, offset) {\n    // same as isHeader but we also check that MPEG frame follows last MPEG frame\n    // or end of data is reached\n    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {\n      // MPEG header Length\n      let headerLength = 4;\n      // MPEG frame Length\n      let header = this.parseHeader(data, offset);\n      let frameLength = headerLength;\n      if (header && header.frameLength) {\n        frameLength = header.frameLength;\n      }\n\n      let newOffset = offset + frameLength;\n      if (newOffset === data.length || (newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset))) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\nexport default MpegAudio;\n","/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n*/\n\nimport { logger } from '../utils/logger';\n\nclass ExpGolomb {\n  constructor (data) {\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord () {\n    let\n      data = this.data,\n      bytesAvailable = this.bytesAvailable,\n      position = data.byteLength - bytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits (count) {\n    let skipBytes; // :int\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= (skipBytes >> 3);\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits (size) {\n    let\n      bits = Math.min(this.bitsAvailable, size), // :uint\n      valu = this.word >>> (32 - bits); // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ () {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG () {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG () {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG () {\n    let clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG () {\n    let valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean () {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte () {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort () {\n    return this.readBits(16);\n  }\n  // ():int\n  readUInt () {\n    return this.readBits(32);\n  }\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList (count) {\n    let\n      lastScale = 8,\n      nextScale = 8,\n      j,\n      deltaScale;\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS () {\n    let\n      frameCropLeftOffset = 0,\n      frameCropRightOffset = 0,\n      frameCropTopOffset = 0,\n      frameCropBottomOffset = 0,\n      profileIdc, profileCompat, levelIdc,\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\n      picHeightInMapUnitsMinus1,\n      frameMbsOnlyFlag,\n      scalingListCount,\n      i,\n      readUByte = this.readUByte.bind(this),\n      readBits = this.readBits.bind(this),\n      readUEG = this.readUEG.bind(this),\n      readBoolean = this.readBoolean.bind(this),\n      skipBits = this.skipBits.bind(this),\n      skipEG = this.skipEG.bind(this),\n      skipUEG = this.skipUEG.bind(this),\n      skipScalingList = this.skipScalingList.bind(this);\n\n    readUByte();\n    profileIdc = readUByte(); // profile_idc\n    profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    levelIdc = readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 ||\n        profileIdc === 110 ||\n        profileIdc === 122 ||\n        profileIdc === 244 ||\n        profileIdc === 44 ||\n        profileIdc === 83 ||\n        profileIdc === 86 ||\n        profileIdc === 118 ||\n        profileIdc === 128) {\n      let chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) { // seq_scaling_matrix_present_flag\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) { // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    let picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    picWidthInMbsMinus1 = readUEG();\n    picHeightInMapUnitsMinus1 = readUEG();\n    frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) { // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n        case 1: pixelRatio = [1, 1]; break;\n        case 2: pixelRatio = [12, 11]; break;\n        case 3: pixelRatio = [10, 11]; break;\n        case 4: pixelRatio = [16, 11]; break;\n        case 5: pixelRatio = [40, 33]; break;\n        case 6: pixelRatio = [24, 11]; break;\n        case 7: pixelRatio = [20, 11]; break;\n        case 8: pixelRatio = [32, 11]; break;\n        case 9: pixelRatio = [80, 33]; break;\n        case 10: pixelRatio = [18, 11]; break;\n        case 11: pixelRatio = [15, 11]; break;\n        case 12: pixelRatio = [64, 33]; break;\n        case 13: pixelRatio = [160, 99]; break;\n        case 14: pixelRatio = [4, 3]; break;\n        case 15: pixelRatio = [3, 2]; break;\n        case 16: pixelRatio = [2, 1]; break;\n        case 255: {\n          pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n          break;\n        }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2)),\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - ((frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)),\n      pixelRatio: pixelRatio\n    };\n  }\n\n  readSliceType () {\n    // skip NALu type\n    this.readUByte();\n    // discard first_mb_in_slice\n    this.readUEG();\n    // return slice_type\n    return this.readUEG();\n  }\n}\n\nexport default ExpGolomb;\n","/**\n * SAMPLE-AES decrypter\n*/\n\nimport Decrypter from '../crypt/decrypter';\n\nclass SampleAesDecrypter {\n  constructor (observer, config, decryptdata, discardEPB) {\n    this.decryptdata = decryptdata;\n    this.discardEPB = discardEPB;\n    this.decrypter = new Decrypter(observer, config, { removePKCS7Padding: false });\n  }\n\n  decryptBuffer (encryptedData, callback) {\n    this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample (samples, sampleIndex, callback, sync) {\n    let curUnit = samples[sampleIndex].unit;\n    let encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    let encryptedBuffer = encryptedData.buffer.slice(\n      encryptedData.byteOffset,\n      encryptedData.byteOffset + encryptedData.length);\n\n    let localthis = this;\n    this.decryptBuffer(encryptedBuffer, function (decryptedData) {\n      decryptedData = new Uint8Array(decryptedData);\n      curUnit.set(decryptedData, 16);\n\n      if (!sync) {\n        localthis.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n\n  decryptAacSamples (samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n\n      let sync = this.decrypter.isSync();\n\n      this.decryptAacSample(samples, sampleIndex, callback, sync);\n\n      if (!sync) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData (decodedData) {\n    let encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    let encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n\n    return encryptedData;\n  }\n\n  getAvcDecryptedUnit (decodedData, decryptedData) {\n    decryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n\n    return decodedData;\n  }\n\n  decryptAvcSample (samples, sampleIndex, unitIndex, callback, curUnit, sync) {\n    let decodedData = this.discardEPB(curUnit.data);\n    let encryptedData = this.getAvcEncryptedData(decodedData);\n    let localthis = this;\n\n    this.decryptBuffer(encryptedData.buffer, function (decryptedData) {\n      curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);\n\n      if (!sync) {\n        localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n\n  decryptAvcSamples (samples, sampleIndex, unitIndex, callback) {\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      let curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n\n        let curUnit = curUnits[unitIndex];\n        if (curUnit.length <= 48 || (curUnit.type !== 1 && curUnit.type !== 5)) {\n          continue;\n        }\n\n        let sync = this.decrypter.isSync();\n\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);\n\n        if (!sync) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nexport default SampleAesDecrypter;\n","/**\n * highly optimized TS demuxer:\n * parse PAT, PMT\n * extract PES packet from audio and video PIDs\n * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n * trigger the remuxer upon parsing completion\n * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n * it also controls the remuxing process :\n * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n*/\n\nimport * as ADTS from './adts';\nimport MpegAudio from './mpegaudio';\nimport Event from '../events';\nimport ExpGolomb from './exp-golomb';\nimport SampleAesDecrypter from './sample-aes';\n// import Hex from '../utils/hex';\nimport { logger } from '../utils/logger';\nimport { ErrorTypes, ErrorDetails } from '../errors';\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\n\nclass TSDemuxer {\n  constructor (observer, remuxer, config, typeSupported) {\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.remuxer = remuxer;\n    this.sampleAes = null;\n  }\n\n  setDecryptData (decryptdata) {\n    if ((decryptdata != null) && (decryptdata.key != null) && (decryptdata.method === 'SAMPLE-AES')) {\n      this.sampleAes = new SampleAesDecrypter(this.observer, this.config, decryptdata, this.discardEPB);\n    } else {\n      this.sampleAes = null;\n    }\n  }\n\n  static probe (data) {\n    const syncOffset = TSDemuxer._syncOffset(data);\n    if (syncOffset < 0) {\n      return false;\n    } else {\n      if (syncOffset) {\n        logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}, junk ahead ?`);\n      }\n\n      return true;\n    }\n  }\n\n  static _syncOffset (data) {\n    // scan 1000 first bytes\n    const scanwindow = Math.min(1000, data.length - 3 * 188);\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n      if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {\n        return i;\n      } else {\n        i++;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   *\n   * @param {string} type 'audio' | 'video' | 'id3' | 'text'\n   * @param {number} duration\n   * @return {object} TSDemuxer's internal track model\n   */\n  static createTrack (type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      len: 0,\n      dropped: type === 'video' ? 0 : undefined,\n      isAAC: type === 'audio' ? true : undefined,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   *\n   * @override Implements generic demuxing/remuxing interface (see DemuxerInline)\n   * @param {object} initSegment\n   * @param {string} audioCodec\n   * @param {string} videoCodec\n   * @param {number} duration (in TS timescale = 90kHz)\n   */\n  resetInitSegment (initSegment, audioCodec, videoCodec, duration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n\n    this._avcTrack = TSDemuxer.createTrack('video', duration);\n    this._audioTrack = TSDemuxer.createTrack('audio', duration);\n    this._id3Track = TSDemuxer.createTrack('id3', duration);\n    this._txtTrack = TSDemuxer.createTrack('text', duration);\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.aacLastPTS = null;\n    this.avcSample = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = duration;\n  }\n\n  /**\n   *\n   * @override\n   */\n  resetTimeStamp () {}\n\n  // feed incoming data to the front of the parsing pipeline\n  append (data, timeOffset, contiguous, accurateTimeOffset) {\n    let start, len = data.length, stt, pid, atf, offset, pes,\n      unknownPIDs = false;\n    this.contiguous = contiguous;\n    let pmtParsed = this.pmtParsed,\n      avcTrack = this._avcTrack,\n      audioTrack = this._audioTrack,\n      id3Track = this._id3Track,\n      avcId = avcTrack.pid,\n      audioId = audioTrack.pid,\n      id3Id = id3Track.pid,\n      pmtId = this._pmtId,\n      avcData = avcTrack.pesData,\n      audioData = audioTrack.pesData,\n      id3Data = id3Track.pesData,\n      parsePAT = this._parsePAT,\n      parsePMT = this._parsePMT,\n      parsePES = this._parsePES,\n      parseAVCPES = this._parseAVCPES.bind(this),\n      parseAACPES = this._parseAACPES.bind(this),\n      parseMPEGPES = this._parseMPEGPES.bind(this),\n      parseID3PES = this._parseID3PES.bind(this);\n\n    const syncOffset = TSDemuxer._syncOffset(data);\n\n    // don't parse last TS packet if incomplete\n    len -= (len + syncOffset) % 188;\n\n    // loop through TS packets\n    for (start = syncOffset; start < len; start += 188) {\n      if (data[start] === 0x47) {\n        stt = !!(data[start + 1] & 0x40);\n        // pid is a 13-bit field starting at the last bit of TS[1]\n        pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n        atf = (data[start + 3] & 0x30) >> 4;\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === (start + 188)) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n        case avcId:\n          if (stt) {\n            if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {\n              parseAVCPES(pes, false);\n            }\n\n            avcData = { data: [], size: 0 };\n          }\n          if (avcData) {\n            avcData.data.push(data.subarray(offset, start + 188));\n            avcData.size += start + 188 - offset;\n          }\n          break;\n        case audioId:\n          if (stt) {\n            if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {\n              if (audioTrack.isAAC) {\n                parseAACPES(pes);\n              } else {\n                parseMPEGPES(pes);\n              }\n            }\n            audioData = { data: [], size: 0 };\n          }\n          if (audioData) {\n            audioData.data.push(data.subarray(offset, start + 188));\n            audioData.size += start + 188 - offset;\n          }\n          break;\n        case id3Id:\n          if (stt) {\n            if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {\n              parseID3PES(pes);\n            }\n\n            id3Data = { data: [], size: 0 };\n          }\n          if (id3Data) {\n            id3Data.data.push(data.subarray(offset, start + 188));\n            id3Data.size += start + 188 - offset;\n          }\n          break;\n        case 0:\n          if (stt) {\n            offset += data[offset] + 1;\n          }\n\n          pmtId = this._pmtId = parsePAT(data, offset);\n          break;\n        case pmtId:\n          if (stt) {\n            offset += data[offset] + 1;\n          }\n\n          let parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);\n\n          // only update track id if track PID found while parsing PMT\n          // this is to avoid resetting the PID to -1 in case\n          // track PID transiently disappears from the stream\n          // this could happen in case of transient missing audio samples for example\n          // NOTE this is only the PID of the track as found in TS,\n          // but we are not using this for MP4 track IDs.\n          avcId = parsedPIDs.avc;\n          if (avcId > 0) {\n            avcTrack.pid = avcId;\n          }\n\n          audioId = parsedPIDs.audio;\n          if (audioId > 0) {\n            audioTrack.pid = audioId;\n            audioTrack.isAAC = parsedPIDs.isAAC;\n          }\n          id3Id = parsedPIDs.id3;\n          if (id3Id > 0) {\n            id3Track.pid = id3Id;\n          }\n\n          if (unknownPIDs && !pmtParsed) {\n            logger.log('reparse from beginning');\n            unknownPIDs = false;\n            // we set it to -188, the += 188 in the for loop will reset start to 0\n            start = syncOffset - 188;\n          }\n          pmtParsed = this.pmtParsed = true;\n          break;\n        case 17:\n        case 0x1fff:\n          break;\n        default:\n          unknownPIDs = true;\n          break;\n        }\n      } else {\n        this.observer.trigger(Event.ERROR, { type: ErrorTypes.MEDIA_ERROR, details: ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });\n      }\n    }\n    // try to parse last PES packets\n    if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {\n      parseAVCPES(pes, true);\n      avcTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      avcTrack.pesData = avcData;\n    }\n\n    if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {\n      if (audioTrack.isAAC) {\n        parseAACPES(pes);\n      } else {\n        parseMPEGPES(pes);\n      }\n\n      audioTrack.pesData = null;\n    } else {\n      if (audioData && audioData.size) {\n        logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n\n    if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {\n      parseID3PES(pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n\n    if (this.sampleAes == null) {\n      this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);\n    } else {\n      this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }\n\n  decryptAndRemux (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n    if (audioTrack.samples && audioTrack.isAAC) {\n      let localthis = this;\n      this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n        localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n      });\n    } else {\n      this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }\n\n  decryptAndRemuxAvc (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n    if (videoTrack.samples) {\n      let localthis = this;\n      this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n        localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n      });\n    } else {\n      this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);\n    }\n  }\n\n  destroy () {\n    this._initPTS = this._initDTS = undefined;\n    this._duration = 0;\n  }\n\n  _parsePAT (data, offset) {\n    // skip the PSI header and parse the first PMT entry\n    return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];\n    // logger.log('PMT PID:'  + this._pmtId);\n  }\n\n  _parsePMT (data, offset, mpegSupported, isSampleAes) {\n    let sectionLength, tableEnd, programInfoLength, pid, result = { audio: -1, avc: -1, id3: -1, isAAC: true };\n    sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n    tableEnd = offset + 3 + sectionLength - 4;\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n    // advance the offset to the first entry in the mapping table\n    offset += 12 + programInfoLength;\n    while (offset < tableEnd) {\n      pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];\n      switch (data[offset]) {\n      case 0xcf: // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logger.log('unkown stream type:' + data[offset]);\n          break;\n        }\n        /* falls through */\n\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n      case 0x0f:\n        // logger.log('AAC PID:'  + pid);\n        if (result.audio === -1) {\n          result.audio = pid;\n        }\n\n        break;\n\n        // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3 === -1) {\n          result.id3 = pid;\n        }\n\n        break;\n\n      case 0xdb: // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logger.log('unkown stream type:' + data[offset]);\n          break;\n        }\n        /* falls through */\n\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n      case 0x1b:\n        // logger.log('AVC PID:'  + pid);\n        if (result.avc === -1) {\n          result.avc = pid;\n        }\n\n        break;\n\n        // ISO/IEC 11172-3 (MPEG-1 audio)\n        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!mpegSupported) {\n          logger.log('MPEG audio found, not supported in this browser for now');\n        } else if (result.audio === -1) {\n          result.audio = pid;\n          result.isAAC = false;\n        }\n        break;\n\n      case 0x24:\n        logger.warn('HEVC stream type found, not supported for now');\n        break;\n\n      default:\n        logger.log('unkown stream type:' + data[offset]);\n        break;\n      }\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;\n    }\n    return result;\n  }\n\n  _parsePES (stream) {\n    let i = 0, frag, pesFlags, pesPrefix, pesLen, pesHdrLen, pesData, pesPts, pesDts, payloadStartOffset, data = stream.data;\n    // safety check\n    if (!stream || stream.size === 0) {\n      return null;\n    }\n\n    // we might need up to 19 bytes to read PES header\n    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n    // usually only one merge is needed (and this is rare ...)\n    while (data[0].length < 19 && data.length > 1) {\n      let newData = new Uint8Array(data[0].length + data[1].length);\n      newData.set(data[0]);\n      newData.set(data[1], data[0].length);\n      data[0] = newData;\n      data.splice(1, 1);\n    }\n    // retrieve PTS/DTS from first fragment\n    frag = data[0];\n    pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n    if (pesPrefix === 1) {\n      pesLen = (frag[4] << 8) + frag[5];\n      // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n      // minus 6 : PES header size\n      if (pesLen && pesLen > stream.size - 6) {\n        return null;\n      }\n\n      pesFlags = frag[7];\n      if (pesFlags & 0xC0) {\n        /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n            as Bitwise operators treat their operands as a sequence of 32 bits */\n        pesPts = (frag[9] & 0x0E) * 536870912 +// 1 << 29\n          (frag[10] & 0xFF) * 4194304 +// 1 << 22\n          (frag[11] & 0xFE) * 16384 +// 1 << 14\n          (frag[12] & 0xFF) * 128 +// 1 << 7\n          (frag[13] & 0xFE) / 2;\n        // check if greater than 2^32 -1\n        if (pesPts > 4294967295) {\n          // decrement 2^33\n          pesPts -= 8589934592;\n        }\n        if (pesFlags & 0x40) {\n          pesDts = (frag[14] & 0x0E) * 536870912 +// 1 << 29\n            (frag[15] & 0xFF) * 4194304 +// 1 << 22\n            (frag[16] & 0xFE) * 16384 +// 1 << 14\n            (frag[17] & 0xFF) * 128 +// 1 << 7\n            (frag[18] & 0xFE) / 2;\n          // check if greater than 2^32 -1\n          if (pesDts > 4294967295) {\n            // decrement 2^33\n            pesDts -= 8589934592;\n          }\n          if (pesPts - pesDts > 60 * 90000) {\n            logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n            pesPts = pesDts;\n          }\n        } else {\n          pesDts = pesPts;\n        }\n      }\n      pesHdrLen = frag[8];\n      // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n      payloadStartOffset = pesHdrLen + 9;\n\n      stream.size -= payloadStartOffset;\n      // reassemble PES packet\n      pesData = new Uint8Array(stream.size);\n      for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n        frag = data[j];\n        let len = frag.byteLength;\n        if (payloadStartOffset) {\n          if (payloadStartOffset > len) {\n            // trim full frag if PES header bigger than frag\n            payloadStartOffset -= len;\n            continue;\n          } else {\n            // trim partial frag if PES header smaller than frag\n            frag = frag.subarray(payloadStartOffset);\n            len -= payloadStartOffset;\n            payloadStartOffset = 0;\n          }\n        }\n        pesData.set(frag, i);\n        i += len;\n      }\n      if (pesLen) {\n        // payload size : remove PES header + PES extension\n        pesLen -= pesHdrLen + 3;\n      }\n      return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };\n    } else {\n      return null;\n    }\n  }\n\n  pushAccesUnit (avcSample, avcTrack) {\n    if (avcSample.units.length && avcSample.frame) {\n      const samples = avcTrack.samples;\n      const nbSamples = samples.length;\n      // only push AVC sample if starting with a keyframe is not mandatory OR\n      //    if keyframe already found in this fragment OR\n      //       keyframe found in last fragment (track.sps) AND\n      //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous\n      if (!this.config.forceKeyFrameOnDiscontinuity ||\n          avcSample.key === true ||\n          (avcTrack.sps && (nbSamples || this.contiguous))) {\n        avcSample.id = nbSamples;\n        samples.push(avcSample);\n      } else {\n        // dropped samples, track it\n        avcTrack.dropped++;\n      }\n    }\n    if (avcSample.debug.length) {\n      logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n    }\n  }\n\n  _parseAVCPES (pes, last) {\n    // logger.log('parse new PES');\n    let track = this._avcTrack,\n      units = this._parseAVCNALu(pes.data),\n      debug = false,\n      expGolombDecoder,\n      avcSample = this.avcSample,\n      push,\n      spsfound = false,\n      i,\n      pushAccesUnit = this.pushAccesUnit.bind(this),\n      createAVCSample = function (key, pts, dts, debug) {\n        return { key: key, pts: pts, dts: dts, units: [], debug: debug };\n      };\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (avcSample && units.length && !track.audFound) {\n      pushAccesUnit(avcSample, track);\n      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n    }\n\n    units.forEach(unit => {\n      switch (unit.type) {\n      // NDR\n      case 1:\n        push = true;\n        if (!avcSample) {\n          avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n        }\n\n        if (debug) {\n          avcSample.debug += 'NDR ';\n        }\n\n        avcSample.frame = true;\n        let data = unit.data;\n        // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n        if (spsfound && data.length > 4) {\n          // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n          let sliceType = new ExpGolomb(data).readSliceType();\n          // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n          // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n          // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n          // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n          // if (sliceType === 2 || sliceType === 7) {\n          if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n            avcSample.key = true;\n          }\n        }\n        break;\n        // IDR\n      case 5:\n        push = true;\n        // handle PES not starting with AUD\n        if (!avcSample) {\n          avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n        }\n\n        if (debug) {\n          avcSample.debug += 'IDR ';\n        }\n\n        avcSample.key = true;\n        avcSample.frame = true;\n        break;\n        // SEI\n      case 6:\n        push = true;\n        if (debug && avcSample) {\n          avcSample.debug += 'SEI ';\n        }\n\n        expGolombDecoder = new ExpGolomb(this.discardEPB(unit.data));\n\n        // skip frameType\n        expGolombDecoder.readUByte();\n\n        var payloadType = 0;\n        var payloadSize = 0;\n        var endOfCaptions = false;\n        var b = 0;\n\n        while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {\n          payloadType = 0;\n          do {\n            b = expGolombDecoder.readUByte();\n            payloadType += b;\n          } while (b === 0xFF);\n\n          // Parse payload size.\n          payloadSize = 0;\n          do {\n            b = expGolombDecoder.readUByte();\n            payloadSize += b;\n          } while (b === 0xFF);\n\n          // TODO: there can be more than one payload in an SEI packet...\n          // TODO: need to read type and size in a while loop to get them all\n          if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {\n            endOfCaptions = true;\n\n            let countryCode = expGolombDecoder.readUByte();\n\n            if (countryCode === 181) {\n              let providerCode = expGolombDecoder.readUShort();\n\n              if (providerCode === 49) {\n                let userStructure = expGolombDecoder.readUInt();\n\n                if (userStructure === 0x47413934) {\n                  let userDataType = expGolombDecoder.readUByte();\n\n                  // Raw CEA-608 bytes wrapped in CEA-708 packet\n                  if (userDataType === 3) {\n                    let firstByte = expGolombDecoder.readUByte();\n                    let secondByte = expGolombDecoder.readUByte();\n\n                    let totalCCs = 31 & firstByte;\n                    let byteArray = [firstByte, secondByte];\n\n                    for (i = 0; i < totalCCs; i++) {\n                      // 3 bytes per CC\n                      byteArray.push(expGolombDecoder.readUByte());\n                      byteArray.push(expGolombDecoder.readUByte());\n                      byteArray.push(expGolombDecoder.readUByte());\n                    }\n\n                    this._insertSampleInOrder(this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });\n                  }\n                }\n              }\n            }\n          } else if (payloadSize < expGolombDecoder.bytesAvailable) {\n            for (i = 0; i < payloadSize; i++) {\n              expGolombDecoder.readUByte();\n            }\n          }\n        }\n        break;\n        // SPS\n      case 7:\n        push = true;\n        spsfound = true;\n        if (debug && avcSample) {\n          avcSample.debug += 'SPS ';\n        }\n\n        if (!track.sps) {\n          expGolombDecoder = new ExpGolomb(unit.data);\n          let config = expGolombDecoder.readSPS();\n          track.width = config.width;\n          track.height = config.height;\n          track.pixelRatio = config.pixelRatio;\n          track.sps = [unit.data];\n          track.duration = this._duration;\n          let codecarray = unit.data.subarray(1, 4);\n          let codecstring = 'avc1.';\n          for (i = 0; i < 3; i++) {\n            let h = codecarray[i].toString(16);\n            if (h.length < 2) {\n              h = '0' + h;\n            }\n\n            codecstring += h;\n          }\n          track.codec = codecstring;\n        }\n        break;\n        // PPS\n      case 8:\n        push = true;\n        if (debug && avcSample) {\n          avcSample.debug += 'PPS ';\n        }\n\n        if (!track.pps) {\n          track.pps = [unit.data];\n        }\n\n        break;\n        // AUD\n      case 9:\n        push = false;\n        track.audFound = true;\n        if (avcSample) {\n          pushAccesUnit(avcSample, track);\n        }\n\n        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n        break;\n        // Filler Data\n      case 12:\n        push = false;\n        break;\n      default:\n        push = false;\n        if (avcSample) {\n          avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n        }\n\n        break;\n      }\n      if (avcSample && push) {\n        let units = avcSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (last && avcSample) {\n      pushAccesUnit(avcSample, track);\n      this.avcSample = null;\n    }\n  }\n\n  _insertSampleInOrder (arr, data) {\n    let len = arr.length;\n    if (len > 0) {\n      if (data.pts >= arr[len - 1].pts) {\n        arr.push(data);\n      } else {\n        for (let pos = len - 1; pos >= 0; pos--) {\n          if (data.pts < arr[pos].pts) {\n            arr.splice(pos, 0, data);\n            break;\n          }\n        }\n      }\n    } else {\n      arr.push(data);\n    }\n  }\n\n  _getLastNalUnit () {\n    let avcSample = this.avcSample, lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!avcSample || avcSample.units.length === 0) {\n      let track = this._avcTrack, samples = track.samples;\n      avcSample = samples[samples.length - 1];\n    }\n    if (avcSample) {\n      let units = avcSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n\n  _parseAVCNALu (array) {\n    let i = 0, len = array.byteLength, value, overflow, track = this._avcTrack, state = track.naluState || 0, lastState = state;\n    let units = [], unit, unitType, lastUnitStart = -1, lastUnitType;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n    // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        if (lastUnitStart >= 0) {\n          unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          let lastUnit = this._getLastNalUnit();\n          if (lastUnit) {\n            if (lastState && (i <= 4 - lastState)) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n            overflow = i - state - 1;\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              let tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n              tmp.set(lastUnit.data, 0);\n              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n              lastUnit.data = tmp;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = array[i] & 0x1f;\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      let lastUnit = this._getLastNalUnit();\n      if (lastUnit) {\n        let tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);\n        tmp.set(lastUnit.data, 0);\n        tmp.set(array, lastUnit.data.byteLength);\n        lastUnit.data = tmp;\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n\n  /**\n   * remove Emulation Prevention bytes from a RBSP\n   */\n  discardEPB (data) {\n    let length = data.byteLength,\n      EPBPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 &&\n          data[i + 1] === 0 &&\n          data[i + 2] === 0x03) {\n        EPBPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (EPBPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - EPBPositions.length;\n    newData = new Uint8Array(newLength);\n    let sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === EPBPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        EPBPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n    return newData;\n  }\n\n  _parseAACPES (pes) {\n    let track = this._audioTrack,\n      data = pes.data,\n      pts = pes.pts,\n      startOffset = 0,\n      aacOverFlow = this.aacOverFlow,\n      aacLastPTS = this.aacLastPTS,\n      frameDuration, frameIndex, offset, stamp, len;\n    if (aacOverFlow) {\n      let tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);\n      tmp.set(aacOverFlow, 0);\n      tmp.set(data, aacOverFlow.byteLength);\n      // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);\n      data = tmp;\n    }\n    // look for ADTS header (0xFFFx)\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (ADTS.isHeader(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset) {\n      let reason, fatal;\n      if (offset < len - 1) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n        fatal = false;\n      } else {\n        reason = 'no ADTS header found in AAC PES';\n        fatal = true;\n      }\n      logger.warn(`parsing error:${reason}`);\n      this.observer.trigger(Event.ERROR, { type: ErrorTypes.MEDIA_ERROR, details: ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });\n      if (fatal) {\n        return;\n      }\n    }\n\n    ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    frameIndex = 0;\n    frameDuration = ADTS.getFrameDuration(track.samplerate);\n\n    // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n    // first sample PTS should be equal to last sample PTS + frameDuration\n    if (aacOverFlow && aacLastPTS) {\n      let newPTS = aacLastPTS + frameDuration;\n      if (Math.abs(newPTS - pts) > 1) {\n        logger.log(`AAC: align PTS for overlapping frames by ${Math.round((newPTS - pts) / 90)}`);\n        pts = newPTS;\n      }\n    }\n\n    // scan for aac samples\n    while (offset < len) {\n      if (ADTS.isHeader(data, offset) && (offset + 5) < len) {\n        let frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          // logger.log(`${Math.round(frame.sample.pts)} : AAC`);\n          offset += frame.length;\n          stamp = frame.sample.pts;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse AAC frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n\n    if (offset < len) {\n      aacOverFlow = data.subarray(offset, len);\n      // logger.log(`AAC: overflow detected:${len-offset}`);\n    } else {\n      aacOverFlow = null;\n    }\n\n    this.aacOverFlow = aacOverFlow;\n    this.aacLastPTS = stamp;\n  }\n\n  _parseMPEGPES (pes) {\n    let data = pes.data;\n    let length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    let pts = pes.pts;\n\n    while (offset < length) {\n      if (MpegAudio.isHeader(data, offset)) {\n        let frame = MpegAudio.appendFrame(this._audioTrack, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n\n  _parseID3PES (pes) {\n    this._id3Track.samples.push(pes);\n  }\n}\n\nexport default TSDemuxer;\n","/**\n * MP3 demuxer\n */\nimport ID3 from '../demux/id3';\nimport { logger } from '../utils/logger';\nimport MpegAudio from './mpegaudio';\n\nclass MP3Demuxer {\n  constructor (observer, remuxer, config) {\n    this.observer = observer;\n    this.config = config;\n    this.remuxer = remuxer;\n  }\n\n  resetInitSegment (initSegment, audioCodec, videoCodec, duration) {\n    this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };\n  }\n\n  resetTimeStamp () {\n  }\n\n  static probe (data) {\n    // check if data contains ID3 timestamp and MPEG sync word\n    let offset, length;\n    let id3Data = ID3.getID3Data(data, 0);\n    if (id3Data && ID3.getTimeStamp(id3Data) !== undefined) {\n      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n      // More info http://www.mp3-tech.org/programmer/frame_header.html\n      for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {\n        if (MpegAudio.probe(data, offset)) {\n          logger.log('MPEG Audio sync word found !');\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // feed incoming data to the front of the parsing pipeline\n  append (data, timeOffset, contiguous, accurateTimeOffset) {\n    let id3Data = ID3.getID3Data(data, 0);\n    let timestamp = ID3.getTimeStamp(id3Data);\n    let pts = timestamp ? 90 * timestamp : timeOffset * 90000;\n    let offset = id3Data.length;\n    let length = data.length;\n    let frameIndex = 0, stamp = 0;\n    let track = this._audioTrack;\n\n    let id3Samples = [{ pts: pts, dts: pts, data: id3Data }];\n\n    while (offset < length) {\n      if (MpegAudio.isHeader(data, offset)) {\n        let frame = MpegAudio.appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          stamp = frame.sample.pts;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else if (ID3.isHeader(data, offset)) {\n        id3Data = ID3.getID3Data(data, offset);\n        id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });\n        offset += id3Data.length;\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n\n    this.remuxer.remux(track,\n      { samples: [] },\n      { samples: id3Samples, inputTimeScale: 90000 },\n      { samples: [] },\n      timeOffset,\n      contiguous,\n      accurateTimeOffset);\n  }\n\n  destroy () {\n  }\n}\n\nexport default MP3Demuxer;\n","/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame (codec, channelCount) {\n    switch (codec) {\n    case 'mp4a.40.2':\n      if (channelCount === 1) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n      } else if (channelCount === 2) {\n        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n      } else if (channelCount === 3) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n      } else if (channelCount === 4) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n      } else if (channelCount === 5) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n      } else if (channelCount === 6) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n      }\n\n      break;\n    // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n    default:\n      if (channelCount === 1) {\n        // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      } else if (channelCount === 2) {\n        // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      } else if (channelCount === 3) {\n        // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      }\n      break;\n    }\n    return null;\n  }\n}\n\nexport default AAC;\n","/**\n * Generate MP4 Box\n*/\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\n\nclass MP4 {\n  static init () {\n    MP4.types = {\n      avc1: [], // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [\n          i.charCodeAt(0),\n          i.charCodeAt(1),\n          i.charCodeAt(2),\n          i.charCodeAt(3)\n        ];\n      }\n    }\n\n    let videoHdlr = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65,\n      0x6f, 0x48, 0x61, 0x6e,\n      0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n\n    let audioHdlr = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e,\n      0x64, 0x48, 0x61, 0x6e,\n      0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n\n    MP4.HDLR_TYPES = {\n      'video': videoHdlr,\n      'audio': audioHdlr\n    };\n\n    let dref = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // entry_count\n      0x00, 0x00, 0x00, 0x0c, // entry_size\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\n      0x00, // version 0\n      0x00, 0x00, 0x01 // entry_flags\n    ]);\n\n    let stco = new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n    MP4.STSZ = new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x01, // flags\n      0x00, 0x00, // graphicsmode\n      0x00, 0x00,\n      0x00, 0x00,\n      0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, // balance\n      0x00, 0x00 // reserved\n    ]);\n\n    MP4.STSD = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01]);// entry_count\n\n    let majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    let avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    let minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n\n  static box (type) {\n    let\n      payload = Array.prototype.slice.call(arguments, 1),\n      size = 8,\n      i = payload.length,\n      len = i,\n      result;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    result = new Uint8Array(size);\n    result[0] = (size >> 24) & 0xff;\n    result[1] = (size >> 16) & 0xff;\n    result[2] = (size >> 8) & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n\n  static hdlr (type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n\n  static mdat (data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n\n  static mdhd (timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([\n      0x01, // version 1\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n      (timescale >> 24) & 0xFF,\n      (timescale >> 16) & 0xFF,\n      (timescale >> 8) & 0xFF,\n      timescale & 0xFF, // timescale\n      (upperWordDuration >> 24),\n      (upperWordDuration >> 16) & 0xFF,\n      (upperWordDuration >> 8) & 0xFF,\n      upperWordDuration & 0xFF,\n      (lowerWordDuration >> 24),\n      (lowerWordDuration >> 16) & 0xFF,\n      (lowerWordDuration >> 8) & 0xFF,\n      lowerWordDuration & 0xFF,\n      0x55, 0xc4, // 'und' language (undetermined)\n      0x00, 0x00\n    ]));\n  }\n\n  static mdia (track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  }\n\n  static mfhd (sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([\n      0x00,\n      0x00, 0x00, 0x00, // flags\n      (sequenceNumber >> 24),\n      (sequenceNumber >> 16) & 0xFF,\n      (sequenceNumber >> 8) & 0xFF,\n      sequenceNumber & 0xFF // sequence_number\n    ]));\n  }\n\n  static minf (track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n\n  static moof (sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  /**\n * @param tracks... (optional) {array} the tracks associated with this movie\n */\n  static moov (tracks) {\n    let\n      i = tracks.length,\n      boxes = [];\n\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n\n  static mvex (tracks) {\n    let\n      i = tracks.length,\n      boxes = [];\n\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n  }\n\n  static mvhd (timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    let\n      bytes = new Uint8Array([\n        0x01, // version 1\n        0x00, 0x00, 0x00, // flags\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n        (timescale >> 24) & 0xFF,\n        (timescale >> 16) & 0xFF,\n        (timescale >> 8) & 0xFF,\n        timescale & 0xFF, // timescale\n        (upperWordDuration >> 24),\n        (upperWordDuration >> 16) & 0xFF,\n        (upperWordDuration >> 8) & 0xFF,\n        upperWordDuration & 0xFF,\n        (lowerWordDuration >> 24),\n        (lowerWordDuration >> 16) & 0xFF,\n        (lowerWordDuration >> 8) & 0xFF,\n        lowerWordDuration & 0xFF,\n        0x00, 0x01, 0x00, 0x00, // 1.0 rate\n        0x01, 0x00, // 1.0 volume\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x01, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, // pre_defined\n        0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n\n  static sdtp (track) {\n    let\n      samples = track.samples || [],\n      bytes = new Uint8Array(4 + samples.length),\n      flags,\n      i;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = (flags.dependsOn << 4) |\n        (flags.isDependedOn << 2) |\n        (flags.hasRedundancy);\n    }\n\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n\n  static stbl (track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n\n  static avc1 (track) {\n    let sps = [], pps = [], i, data, len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push((len >>> 8) & 0xFF);\n      sps.push((len & 0xFF));\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push((len >>> 8) & 0xFF);\n      pps.push((len & 0xFF));\n\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n\n    let avcc = MP4.box(MP4.types.avcC, new Uint8Array([\n        0x01, // version\n        sps[3], // profile\n        sps[4], // profile compat\n        sps[5], // level\n        0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n        0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n      ].concat(sps).concat([\n        track.pps.length // numOfPictureParameterSets\n      ]).concat(pps))), // \"PPS\"\n      width = track.width,\n      height = track.height,\n      hSpacing = track.pixelRatio[0],\n      vSpacing = track.pixelRatio[1];\n\n    return MP4.box(MP4.types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (width >> 8) & 0xFF,\n      width & 0xff, // width\n      (height >> 8) & 0xFF,\n      height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x12,\n      0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74,\n      0x69, 0x6F, 0x6E, 0x2F,\n      0x68, 0x6C, 0x73, 0x2E,\n      0x6A, 0x73, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]), // pre_defined = -1\n    avcc,\n    MP4.box(MP4.types.btrt, new Uint8Array([\n      0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([\n      (hSpacing >> 24), // hSpacing\n      (hSpacing >> 16) & 0xFF,\n      (hSpacing >> 8) & 0xFF,\n      hSpacing & 0xFF,\n      (vSpacing >> 24), // vSpacing\n      (vSpacing >> 16) & 0xFF,\n      (vSpacing >> 8) & 0xFF,\n      vSpacing & 0xFF]))\n    );\n  }\n\n  static esds (track) {\n    let configlen = track.config.length;\n    return new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n\n      0x03, // descriptor_type\n      0x17 + configlen, // length\n      0x00, 0x01, // es_id\n      0x00, // stream_priority\n\n      0x04, // descriptor_type\n      0x0f + configlen, // length\n      0x40, // codec : mpeg4_audio\n      0x15, // stream_type\n      0x00, 0x00, 0x00, // buffer_size\n      0x00, 0x00, 0x00, 0x00, // maxBitrate\n      0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n      0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  }\n\n  static mp4a (track) {\n    let samplerate = track.samplerate;\n    return MP4.box(MP4.types.mp4a, new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      (samplerate >> 8) & 0xFF,\n      samplerate & 0xff, //\n      0x00, 0x00]),\n    MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n\n  static mp3 (track) {\n    let samplerate = track.samplerate;\n    return MP4.box(MP4.types['.mp3'], new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      (samplerate >> 8) & 0xFF,\n      samplerate & 0xff, //\n      0x00, 0x00]));\n  }\n\n  static stsd (track) {\n    if (track.type === 'audio') {\n      if (!track.isAAC && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  }\n\n  static tkhd (track) {\n    let id = track.id,\n      duration = track.duration * track.timescale,\n      width = track.width,\n      height = track.height,\n      upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),\n      lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([\n      0x01, // version 1\n      0x00, 0x00, 0x07, // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n      (id >> 24) & 0xFF,\n      (id >> 16) & 0xFF,\n      (id >> 8) & 0xFF,\n      id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (upperWordDuration >> 24),\n      (upperWordDuration >> 16) & 0xFF,\n      (upperWordDuration >> 8) & 0xFF,\n      upperWordDuration & 0xFF,\n      (lowerWordDuration >> 24),\n      (lowerWordDuration >> 16) & 0xFF,\n      (lowerWordDuration >> 8) & 0xFF,\n      lowerWordDuration & 0xFF,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // alternate_group\n      0x00, 0x00, // non-audio track volume\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      (width >> 8) & 0xFF,\n      width & 0xFF,\n      0x00, 0x00, // width\n      (height >> 8) & 0xFF,\n      height & 0xFF,\n      0x00, 0x00 // height\n    ]));\n  }\n\n  static traf (track, baseMediaDecodeTime) {\n    let sampleDependencyTable = MP4.sdtp(track),\n      id = track.id,\n      upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),\n      lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf,\n      MP4.box(MP4.types.tfhd, new Uint8Array([\n        0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        (id >> 24),\n        (id >> 16) & 0XFF,\n        (id >> 8) & 0XFF,\n        (id & 0xFF) // track_ID\n      ])),\n      MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x01, // version 1\n        0x00, 0x00, 0x00, // flags\n        (upperWordBaseMediaDecodeTime >> 24),\n        (upperWordBaseMediaDecodeTime >> 16) & 0XFF,\n        (upperWordBaseMediaDecodeTime >> 8) & 0XFF,\n        (upperWordBaseMediaDecodeTime & 0xFF),\n        (lowerWordBaseMediaDecodeTime >> 24),\n        (lowerWordBaseMediaDecodeTime >> 16) & 0XFF,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0XFF,\n        (lowerWordBaseMediaDecodeTime & 0xFF)\n      ])),\n      MP4.trun(track,\n        sampleDependencyTable.length +\n                    16 + // tfhd\n                    20 + // tfdt\n                    8 + // traf header\n                    16 + // mfhd\n                    8 + // moof header\n                    8), // mdat header\n      sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n  static trak (track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n\n  static trex (track) {\n    let id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0XFF,\n      (id >> 8) & 0XFF,\n      (id & 0xFF), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n\n  static trun (track, offset) {\n    let samples = track.samples || [],\n      len = samples.length,\n      arraylen = 12 + (16 * len),\n      array = new Uint8Array(arraylen),\n      i, sample, duration, size, flags, cts;\n    offset += 8 + arraylen;\n    array.set([\n      0x00, // version 0\n      0x00, 0x0f, 0x01, // flags\n      (len >>> 24) & 0xFF,\n      (len >>> 16) & 0xFF,\n      (len >>> 8) & 0xFF,\n      len & 0xFF, // sample_count\n      (offset >>> 24) & 0xFF,\n      (offset >>> 16) & 0xFF,\n      (offset >>> 8) & 0xFF,\n      offset & 0xFF // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([\n        (duration >>> 24) & 0xFF,\n        (duration >>> 16) & 0xFF,\n        (duration >>> 8) & 0xFF,\n        duration & 0xFF, // sample_duration\n        (size >>> 24) & 0xFF,\n        (size >>> 16) & 0xFF,\n        (size >>> 8) & 0xFF,\n        size & 0xFF, // sample_size\n        (flags.isLeading << 2) | flags.dependsOn,\n        (flags.isDependedOn << 6) |\n          (flags.hasRedundancy << 4) |\n          (flags.paddingValue << 1) |\n          flags.isNonSync,\n        flags.degradPrio & 0xF0 << 8,\n        flags.degradPrio & 0x0F, // sample_flags\n        (cts >>> 24) & 0xFF,\n        (cts >>> 16) & 0xFF,\n        (cts >>> 8) & 0xFF,\n        cts & 0xFF // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n\n  static initSegment (tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n\n    let movie = MP4.moov(tracks), result;\n    result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  }\n}\n\nexport default MP4;\n","/**\n * fMP4 remuxer\n*/\n\nimport AAC from './aac-helper';\nimport MP4 from './mp4-generator';\n\nimport Event from '../events';\nimport { ErrorTypes, ErrorDetails } from '../errors';\n\nimport { logger } from '../utils/logger';\n\n// 10 seconds\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000;\n\nclass MP4Remuxer {\n  constructor (observer, config, typeSupported, vendor) {\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    const userAgent = navigator.userAgent;\n    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');\n    this.ISGenerated = false;\n  }\n\n  destroy () {\n  }\n\n  resetTimeStamp (defaultTimeStamp) {\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n\n  resetInitSegment () {\n    this.ISGenerated = false;\n  }\n\n  remux (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n    // generate Init Segment if needed\n    if (!this.ISGenerated) {\n      this.generateIS(audioTrack, videoTrack, timeOffset);\n    }\n\n    if (this.ISGenerated) {\n      const nbAudioSamples = audioTrack.samples.length;\n      const nbVideoSamples = videoTrack.samples.length;\n      let audioTimeOffset = timeOffset;\n      let videoTimeOffset = timeOffset;\n      if (nbAudioSamples && nbVideoSamples) {\n        // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n        // if first audio DTS is not aligned with first video DTS then we need to take that into account\n        // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n        // drift between audio and video streams\n        let audiovideoDeltaDts = (audioTrack.samples[0].dts - videoTrack.samples[0].dts) / videoTrack.inputTimeScale;\n        audioTimeOffset += Math.max(0, audiovideoDeltaDts);\n        videoTimeOffset += Math.max(0, -audiovideoDeltaDts);\n      }\n      // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is\n      // calculated in remuxAudio.\n      // logger.log('nb AAC samples:' + audioTrack.samples.length);\n      if (nbAudioSamples) {\n        // if initSegment was generated without video samples, regenerate it again\n        if (!audioTrack.timescale) {\n          logger.warn('regenerate InitSegment as audio detected');\n          this.generateIS(audioTrack, videoTrack, timeOffset);\n        }\n        let audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);\n        // logger.log('nb AVC samples:' + videoTrack.samples.length);\n        if (nbVideoSamples) {\n          let audioTrackLength;\n          if (audioData) {\n            audioTrackLength = audioData.endPTS - audioData.startPTS;\n          }\n\n          // if initSegment was generated without video samples, regenerate it again\n          if (!videoTrack.timescale) {\n            logger.warn('regenerate InitSegment as video detected');\n            this.generateIS(audioTrack, videoTrack, timeOffset);\n          }\n          this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);\n        }\n      } else {\n        // logger.log('nb AVC samples:' + videoTrack.samples.length);\n        if (nbVideoSamples) {\n          let videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);\n          if (videoData && audioTrack.codec) {\n            this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);\n          }\n        }\n      }\n    }\n    // logger.log('nb ID3 samples:' + audioTrack.samples.length);\n    if (id3Track.samples.length) {\n      this.remuxID3(id3Track, timeOffset);\n    }\n\n    // logger.log('nb ID3 samples:' + audioTrack.samples.length);\n    if (textTrack.samples.length) {\n      this.remuxText(textTrack, timeOffset);\n    }\n\n    // notify end of parsing\n    this.observer.trigger(Event.FRAG_PARSED);\n  }\n\n  generateIS (audioTrack, videoTrack, timeOffset) {\n    let observer = this.observer,\n      audioSamples = audioTrack.samples,\n      videoSamples = videoTrack.samples,\n      typeSupported = this.typeSupported,\n      container = 'audio/mp4',\n      tracks = {},\n      data = { tracks: tracks },\n      computePTSDTS = (this._initPTS === undefined),\n      initPTS, initDTS;\n\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      logger.log(`audio sampling rate : ${audioTrack.samplerate}`);\n      if (!audioTrack.isAAC) {\n        if (typeSupported.mpeg) { // Chrome and Safari\n          container = 'audio/mpeg';\n          audioTrack.codec = '';\n        } else if (typeSupported.mp3) { // Firefox\n          audioTrack.codec = 'mp3';\n        }\n      }\n      tracks.audio = {\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        // remember first PTS of this demuxing context. for audio, PTS = DTS\n        initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;\n      }\n    }\n\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      const inputTimeScale = videoTrack.inputTimeScale;\n      videoTrack.timescale = inputTimeScale;\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);\n        initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);\n        this.observer.trigger(Event.INIT_PTS_FOUND, { initPTS: initPTS });\n      }\n    }\n\n    if (Object.keys(tracks).length) {\n      observer.trigger(Event.FRAG_PARSING_INIT_SEGMENT, data);\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = initPTS;\n        this._initDTS = initDTS;\n      }\n    } else {\n      observer.trigger(Event.ERROR, { type: ErrorTypes.MEDIA_ERROR, details: ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });\n    }\n  }\n\n  remuxVideo (track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {\n    let offset = 8,\n      timeScale = track.timescale,\n      mp4SampleDuration,\n      mdat, moof,\n      firstPTS, firstDTS,\n      nextDTS,\n      lastPTS, lastDTS,\n      inputSamples = track.samples,\n      outputSamples = [],\n      nbSamples = inputSamples.length,\n      ptsNormalize = this._PTSNormalize,\n      initDTS = this._initDTS;\n\n    // for (let i = 0; i < track.samples.length; i++) {\n    //   let avcSample = track.samples[i];\n    //   let units = avcSample.units;\n    //   let unitsString = '';\n    //   for (let j = 0; j < units.length ; j++) {\n    //     unitsString += units[j].type + ',';\n    //     if (units[j].data.length < 500) {\n    //       unitsString += Hex.hexDump(units[j].data);\n    //     }\n    //   }\n    //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);\n    // }\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    let nextAvcDts = this.nextAvcDts;\n\n    const isSafari = this.isSafari;\n\n    if (nbSamples === 0) {\n      return;\n    }\n\n    // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive\n    if (isSafari) {\n      // also consider consecutive fragments as being contiguous (even if a level switch occurs),\n      // for sake of clarity:\n      // consecutive fragments are frags with\n      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n      //  - less than 200 ms PTS gaps (timeScale/5)\n      contiguous |= (inputSamples.length && nextAvcDts &&\n                     ((accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1) ||\n                      Math.abs((inputSamples[0].pts - nextAvcDts - initDTS)) < timeScale / 5)\n      );\n    }\n\n    if (!contiguous) {\n      // if not contiguous, let's use target timeOffset\n      nextAvcDts = timeOffset * timeScale;\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    inputSamples.forEach(function (sample) {\n      sample.pts = ptsNormalize(sample.pts - initDTS, nextAvcDts);\n      sample.dts = ptsNormalize(sample.dts - initDTS, nextAvcDts);\n    });\n\n    // sort video samples by DTS then PTS then demux id order\n    inputSamples.sort(function (a, b) {\n      const deltadts = a.dts - b.dts;\n      const deltapts = a.pts - b.pts;\n      return deltadts || (deltapts || (a.id - b.id));\n    });\n\n    // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)\n    let PTSDTSshift = inputSamples.reduce((prev, curr) => Math.max(Math.min(prev, curr.pts - curr.dts), -18000), 0);\n    if (PTSDTSshift < 0) {\n      logger.warn(`PTS < DTS detected in video samples, shifting DTS by ${Math.round(PTSDTSshift / 90)} ms to overcome this issue`);\n      for (let i = 0; i < inputSamples.length; i++) {\n        inputSamples[i].dts += PTSDTSshift;\n      }\n    }\n\n    // compute first DTS and last DTS, normalize them against reference value\n    let sample = inputSamples[0];\n    firstDTS = Math.max(sample.dts, 0);\n    firstPTS = Math.max(sample.pts, 0);\n\n    // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)\n    let delta = Math.round((firstDTS - nextAvcDts) / 90);\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      if (delta) {\n        if (delta > 1) {\n          logger.log(`AVC:${delta} ms hole between fragments detected,filling it`);\n        } else if (delta < -1) {\n          logger.log(`AVC:${(-delta)} ms overlapping between fragments detected`);\n        }\n\n        // remove hole/gap : set DTS to next expected DTS\n        firstDTS = nextAvcDts;\n        inputSamples[0].dts = firstDTS;\n        // offset PTS as well, ensure that PTS is smaller or equal than new DTS\n        firstPTS = Math.max(firstPTS - delta, nextAvcDts);\n        inputSamples[0].pts = firstPTS;\n        logger.log(`Video/PTS/DTS adjusted: ${Math.round(firstPTS / 90)}/${Math.round(firstDTS / 90)},delta:${delta} ms`);\n      }\n    }\n    nextDTS = firstDTS;\n\n    // compute lastPTS/lastDTS\n    sample = inputSamples[inputSamples.length - 1];\n    lastDTS = Math.max(sample.dts, 0);\n    lastPTS = Math.max(sample.pts, 0, lastDTS);\n\n    // on Safari let's signal the same sample duration for all samples\n    // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    if (isSafari) {\n      mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));\n    }\n\n    let nbNalu = 0, naluLen = 0;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      let sample = inputSamples[i], units = sample.units, nbUnits = units.length, sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // normalize PTS/DTS\n      if (isSafari) {\n        // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples\n        sample.dts = firstDTS + i * mp4SampleDuration;\n      } else {\n        // ensure sample monotonic DTS\n        sample.dts = Math.max(sample.dts, firstDTS);\n      }\n      // ensure that computed value is greater or equal than sample DTS\n      sample.pts = Math.max(sample.pts, sample.dts);\n    }\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    let mdatSize = naluLen + (4 * nbNalu) + 8;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.trigger(Event.ERROR, { type: ErrorTypes.MUX_ERROR, details: ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: `fail allocating video mdat ${mdatSize}` });\n      return;\n    }\n    let view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n\n    for (let i = 0; i < nbSamples; i++) {\n      let avcSample = inputSamples[i],\n        avcSampleUnits = avcSample.units,\n        mp4SampleLength = 0,\n        compositionTimeOffset;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {\n        let unit = avcSampleUnits[j],\n          unitData = unit.data,\n          unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      if (!isSafari) {\n        // expected sample duration is the Decoding Timestamp diff of consecutive samples\n        if (i < nbSamples - 1) {\n          mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;\n        } else {\n          let config = this.config,\n            lastFrameDuration = avcSample.dts - inputSamples[i > 0 ? i - 1 : i].dts;\n          if (config.stretchShortVideoTrack) {\n            // In some cases, a segment's audio track duration may exceed the video track duration.\n            // Since we've already remuxed audio, and we know how long the audio track is, we look to\n            // see if the delta to the next segment is longer than maxBufferHole.\n            // If so, playback would potentially get stuck, so we artificially inflate\n            // the duration of the last frame to minimize any potential gap between segments.\n            let maxBufferHole = config.maxBufferHole,\n              gapTolerance = Math.floor(maxBufferHole * timeScale),\n              deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n            if (deltaToFrameEnd > gapTolerance) {\n              // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n              // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n              if (mp4SampleDuration < 0) {\n                mp4SampleDuration = lastFrameDuration;\n              }\n\n              logger.log(`It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        }\n        compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      } else {\n        compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));\n      }\n\n      // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');\n      outputSamples.push({\n        size: mp4SampleLength,\n        // constant duration\n        duration: mp4SampleDuration,\n        cts: compositionTimeOffset,\n        flags: {\n          isLeading: 0,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradPrio: 0,\n          dependsOn: avcSample.key ? 2 : 1,\n          isNonSync: avcSample.key ? 0 : 1\n        }\n      });\n    }\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    this.nextAvcDts = lastDTS + mp4SampleDuration;\n    let dropped = track.dropped;\n    track.len = 0;\n    track.nbNalu = 0;\n    track.dropped = 0;\n    if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {\n      let flags = outputSamples[0].flags;\n      // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue\n      // https://code.google.com/p/chromium/issues/detail?id=229412\n      flags.dependsOn = 2;\n      flags.isNonSync = 0;\n    }\n    track.samples = outputSamples;\n    moof = MP4.moof(track.sequenceNumber++, firstDTS, track);\n    track.samples = [];\n\n    let data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: firstPTS / timeScale,\n      endPTS: (lastPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: this.nextAvcDts / timeScale,\n      type: 'video',\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: dropped\n    };\n    this.observer.trigger(Event.FRAG_PARSING_DATA, data);\n    return data;\n  }\n\n  remuxAudio (track, timeOffset, contiguous, accurateTimeOffset) {\n    const inputTimeScale = track.inputTimeScale,\n      mp4timeScale = track.timescale,\n      scaleFactor = inputTimeScale / mp4timeScale,\n      mp4SampleDuration = track.isAAC ? 1024 : 1152,\n      inputSampleDuration = mp4SampleDuration * scaleFactor,\n      ptsNormalize = this._PTSNormalize,\n      initDTS = this._initDTS,\n      rawMPEG = !track.isAAC && this.typeSupported.mpeg;\n\n    let offset,\n      mp4Sample,\n      fillFrame,\n      mdat, moof,\n      firstPTS, lastPTS,\n      inputSamples = track.samples,\n      outputSamples = [],\n      nextAudioPts = this.nextAudioPts;\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    contiguous |= (inputSamples.length && nextAudioPts &&\n                   ((accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1) ||\n                    Math.abs((inputSamples[0].pts - nextAudioPts - initDTS)) < 20 * inputSampleDuration)\n    );\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = sample.dts = ptsNormalize(sample.pts - initDTS, timeOffset * inputTimeScale);\n    });\n\n    // filter out sample with negative PTS that are not playable anyway\n    // if we don't remove these negative samples, they will shift all audio samples forward.\n    // leading to audio overlap between current / next fragment\n    inputSamples = inputSamples.filter(function (sample) {\n      return sample.pts >= 0;\n    });\n\n    // in case all samples have negative PTS, and have been filtered out, return now\n    if (inputSamples.length === 0) {\n      return;\n    }\n\n    if (!contiguous) {\n      if (!accurateTimeOffset) {\n        // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      } else {\n        // if timeOffset is accurate, let's use it as predicted next audio PTS\n        nextAudioPts = timeOffset * inputTimeScale;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.isAAC) {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {\n        // First, let's see how far off this frame is from where we expect it to be\n        var sample = inputSamples[i], delta;\n        let pts = sample.pts;\n        delta = pts - nextPts;\n\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // If we're overlapping by more than a duration, drop this sample\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration) {\n          logger.warn(`Dropping 1 audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(duration)} ms overlap.`);\n          inputSamples.splice(i, 1);\n          track.len -= sample.unit.length;\n          // Don't touch nextPtsNorm or i\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {\n          let missing = Math.round(delta / inputSampleDuration);\n          logger.warn(`Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            let newStamp = Math.max(nextPts, 0);\n            fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });\n            track.len += fillFrame.length;\n            nextPts += inputSampleDuration;\n            i++;\n          }\n\n          // Adjust sample to next expected pts\n          sample.pts = sample.dts = nextPts;\n          nextPts += inputSampleDuration;\n          i++;\n        } else {\n        // Otherwise, just adjust pts\n          if (Math.abs(delta) > (0.1 * inputSampleDuration)) {\n            // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);\n          }\n          sample.pts = sample.dts = nextPts;\n          nextPts += inputSampleDuration;\n          i++;\n        }\n      }\n    }\n\n    for (let j = 0, nbSamples = inputSamples.length; j < nbSamples; j++) {\n      let audioSample = inputSamples[j];\n      let unit = audioSample.unit;\n      let pts = audioSample.pts;\n      // logger.log(`Audio/PTS:${Math.round(pts/90)}`);\n      // if not first sample\n      if (lastPTS !== undefined) {\n        mp4Sample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        let delta = Math.round(1000 * (pts - nextAudioPts) / inputTimeScale),\n          numMissingFrames = 0;\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        if (contiguous && track.isAAC) {\n          // log delta\n          if (delta) {\n            if (delta > 0 && delta < MAX_SILENT_FRAME_DURATION) {\n              numMissingFrames = Math.round((pts - nextAudioPts) / inputSampleDuration);\n              logger.log(`${delta} ms hole between AAC samples detected,filling it`);\n              if (numMissingFrames > 0) {\n                fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                if (!fillFrame) {\n                  fillFrame = unit.subarray();\n                }\n\n                track.len += numMissingFrames * fillFrame.length;\n              }\n              // if we have frame overlap, overlapping for more than half a frame duraion\n            } else if (delta < -12) {\n              // drop overlapping audio frames... browser will deal with it\n              logger.log(`drop overlapping AAC sample, expected/parsed/delta:${(nextAudioPts / inputTimeScale).toFixed(3)}s/${(pts / inputTimeScale).toFixed(3)}s/${(-delta)}ms`);\n              track.len -= unit.byteLength;\n              continue;\n            }\n            // set PTS/DTS to expected PTS/DTS\n            pts = nextAudioPts;\n          }\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (track.len > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          let mdatSize = rawMPEG ? track.len : track.len + 8;\n          offset = rawMPEG ? 0 : 8;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.trigger(Event.ERROR, { type: ErrorTypes.MUX_ERROR, details: ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: `fail allocating audio mdat ${mdatSize}` });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n        for (let i = 0; i < numMissingFrames; i++) {\n          fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n          if (!fillFrame) {\n            logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');\n            fillFrame = unit.subarray();\n          }\n          mdat.set(fillFrame, offset);\n          offset += fillFrame.byteLength;\n          mp4Sample = {\n            size: fillFrame.byteLength,\n            cts: 0,\n            duration: 1024,\n            flags: {\n              isLeading: 0,\n              isDependedOn: 0,\n              hasRedundancy: 0,\n              degradPrio: 0,\n              dependsOn: 1\n            }\n          };\n          outputSamples.push(mp4Sample);\n        }\n      }\n      mdat.set(unit, offset);\n      let unitLen = unit.byteLength;\n      offset += unitLen;\n      // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');\n      mp4Sample = {\n        size: unitLen,\n        cts: 0,\n        duration: 0,\n        flags: {\n          isLeading: 0,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradPrio: 0,\n          dependsOn: 1\n        }\n      };\n      outputSamples.push(mp4Sample);\n      lastPTS = pts;\n    }\n    let lastSampleDuration = 0;\n    let nbSamples = outputSamples.length;\n    // set last sample duration as being identical to previous sample\n    if (nbSamples >= 2) {\n      lastSampleDuration = outputSamples[nbSamples - 2].duration;\n      mp4Sample.duration = lastSampleDuration;\n    }\n    if (nbSamples) {\n      // next audio sample PTS should be equal to last sample PTS + duration\n      this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;\n      // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));\n      track.len = 0;\n      track.samples = outputSamples;\n      if (rawMPEG) {\n        moof = new Uint8Array();\n      } else {\n        moof = MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);\n      }\n\n      track.samples = [];\n      const start = firstPTS / inputTimeScale;\n      const end = nextAudioPts / inputTimeScale;\n      const audioData = {\n        data1: moof,\n        data2: mdat,\n        startPTS: start,\n        endPTS: end,\n        startDTS: start,\n        endDTS: end,\n        type: 'audio',\n        hasAudio: true,\n        hasVideo: false,\n        nb: nbSamples\n      };\n      this.observer.trigger(Event.FRAG_PARSING_DATA, audioData);\n      return audioData;\n    }\n    return null;\n  }\n\n  remuxEmptyAudio (track, timeOffset, contiguous, videoData) {\n    let inputTimeScale = track.inputTimeScale,\n      mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,\n      scaleFactor = inputTimeScale / mp4timeScale,\n      nextAudioPts = this.nextAudioPts,\n\n      // sync with video's timestamp\n      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,\n      endDTS = videoData.endDTS * inputTimeScale + this._initDTS,\n      // one sample's duration value\n      sampleDuration = 1024,\n      frameDuration = scaleFactor * sampleDuration,\n\n      // samples count of this segment's duration\n      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),\n\n      // silent frame\n      silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n    logger.warn('remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');\n      return;\n    }\n\n    let samples = [];\n    for (let i = 0; i < nbSamples; i++) {\n      let stamp = startDTS + i * frameDuration;\n      samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n      track.len += silentFrame.length;\n    }\n    track.samples = samples;\n\n    this.remuxAudio(track, timeOffset, contiguous);\n  }\n\n  remuxID3 (track, timeOffset) {\n    let length = track.samples.length, sample;\n    const inputTimeScale = track.inputTimeScale;\n    const initPTS = this._initPTS;\n    const initDTS = this._initDTS;\n    // consume samples\n    if (length) {\n      for (let index = 0; index < length; index++) {\n        sample = track.samples[index];\n        // setting id3 pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = ((sample.pts - initPTS) / inputTimeScale);\n        sample.dts = ((sample.dts - initDTS) / inputTimeScale);\n      }\n      this.observer.trigger(Event.FRAG_PARSING_METADATA, {\n        samples: track.samples\n      });\n    }\n\n    track.samples = [];\n    timeOffset = timeOffset;\n  }\n\n  remuxText (track, timeOffset) {\n    track.samples.sort(function (a, b) {\n      return (a.pts - b.pts);\n    });\n\n    let length = track.samples.length, sample;\n    const inputTimeScale = track.inputTimeScale;\n    const initPTS = this._initPTS;\n    // consume samples\n    if (length) {\n      for (let index = 0; index < length; index++) {\n        sample = track.samples[index];\n        // setting text pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = ((sample.pts - initPTS) / inputTimeScale);\n      }\n      this.observer.trigger(Event.FRAG_PARSING_USERDATA, {\n        samples: track.samples\n      });\n    }\n\n    track.samples = [];\n    timeOffset = timeOffset;\n  }\n\n  _PTSNormalize (value, reference) {\n    let offset;\n    if (reference === undefined) {\n      return value;\n    }\n\n    if (reference < value) {\n      // - 2^33\n      offset = -8589934592;\n    } else {\n      // + 2^33\n      offset = 8589934592;\n    }\n    /* PTS is 33bit (from 0 to 2^33 -1)\n      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n      PTS looping occured. fill the gap */\n    while (Math.abs(value - reference) > 4294967296) {\n      value += offset;\n    }\n\n    return value;\n  }\n}\n\nexport default MP4Remuxer;\n","/**\n * passthrough remuxer\n*/\nimport Event from '../events';\n\nclass PassThroughRemuxer {\n  constructor (observer) {\n    this.observer = observer;\n  }\n\n  destroy () {\n  }\n\n  resetTimeStamp () {\n  }\n\n  resetInitSegment () {\n  }\n\n  remux (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {\n    let observer = this.observer;\n    let streamType = '';\n    if (audioTrack) {\n      streamType += 'audio';\n    }\n\n    if (videoTrack) {\n      streamType += 'video';\n    }\n\n    observer.trigger(Event.FRAG_PARSING_DATA, {\n      data1: rawData,\n      startPTS: timeOffset,\n      startDTS: timeOffset,\n      type: streamType,\n      hasAudio: !!audioTrack,\n      hasVideo: !!videoTrack,\n      nb: 1,\n      dropped: 0\n    });\n    // notify end of parsing\n    observer.trigger(Event.FRAG_PARSED);\n  }\n}\n\nexport default PassThroughRemuxer;\n","/**\n *\n * inline demuxer: probe fragments and instantiate\n * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)\n *\n */\n\nimport Event from '../events';\nimport { ErrorTypes, ErrorDetails } from '../errors';\nimport Decrypter from '../crypt/decrypter';\nimport AACDemuxer from '../demux/aacdemuxer';\nimport MP4Demuxer from '../demux/mp4demuxer';\nimport TSDemuxer from '../demux/tsdemuxer';\nimport MP3Demuxer from '../demux/mp3demuxer';\nimport MP4Remuxer from '../remux/mp4-remuxer';\nimport PassThroughRemuxer from '../remux/passthrough-remuxer';\n\nimport { getSelfScope } from '../utils/get-self-scope';\n\n// see https://stackoverflow.com/a/11237259/589493\nconst global = getSelfScope(); // safeguard for code that might run both on worker and main thread\nconst performance = global.performance;\n\nclass DemuxerInline {\n  constructor (observer, typeSupported, config, vendor) {\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n  }\n\n  destroy () {\n    let demuxer = this.demuxer;\n    if (demuxer) {\n      demuxer.destroy();\n    }\n  }\n\n  push (data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {\n    if ((data.byteLength > 0) && (decryptdata != null) && (decryptdata.key != null) && (decryptdata.method === 'AES-128')) {\n      let decrypter = this.decrypter;\n      if (decrypter == null) {\n        decrypter = this.decrypter = new Decrypter(this.observer, this.config);\n      }\n\n      let localthis = this;\n      // performance.now() not available on WebWorker, at least on Safari Desktop\n      let startTime;\n      try {\n        startTime = performance.now();\n      } catch (error) {\n        startTime = Date.now();\n      }\n      decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {\n        let endTime;\n        try {\n          endTime = performance.now();\n        } catch (error) {\n          endTime = Date.now();\n        }\n        localthis.observer.trigger(Event.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });\n        localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n      });\n    } else {\n      this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);\n    }\n  }\n\n  pushDecrypted (data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {\n    let demuxer = this.demuxer;\n    if (!demuxer ||\n      // in case of continuity change, or track switch\n      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n      // so let's check that current demuxer is still valid\n      ((discontinuity || trackSwitch) && !this.probe(data))) {\n      const observer = this.observer;\n      const typeSupported = this.typeSupported;\n      const config = this.config;\n      // probing order is TS/AAC/MP3/MP4\n      const muxConfig = [\n        { demux: TSDemuxer, remux: MP4Remuxer },\n        { demux: MP4Demuxer, remux: PassThroughRemuxer },\n        { demux: AACDemuxer, remux: MP4Remuxer },\n        { demux: MP3Demuxer, remux: MP4Remuxer }\n      ];\n\n      // probe for content type\n      for (let i = 0, len = muxConfig.length; i < len; i++) {\n        const mux = muxConfig[i];\n        const probe = mux.demux.probe;\n        if (probe(data)) {\n          const remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);\n          demuxer = new mux.demux(observer, remuxer, config, typeSupported);\n          this.probe = probe;\n          break;\n        }\n      }\n      if (!demuxer) {\n        observer.trigger(Event.ERROR, { type: ErrorTypes.MEDIA_ERROR, details: ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });\n        return;\n      }\n      this.demuxer = demuxer;\n    }\n    const remuxer = this.remuxer;\n\n    if (discontinuity || trackSwitch) {\n      demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);\n      remuxer.resetInitSegment();\n    }\n    if (discontinuity) {\n      demuxer.resetTimeStamp(defaultInitPTS);\n      remuxer.resetTimeStamp(defaultInitPTS);\n    }\n    if (typeof demuxer.setDecryptData === 'function') {\n      demuxer.setDecryptData(decryptdata);\n    }\n\n    demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);\n  }\n}\n\nexport default DemuxerInline;\n","/* demuxer web worker.\n *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.\n *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.\n */\n\nimport DemuxerInline from '../demux/demuxer-inline';\nimport Event from '../events';\nimport { enableLogs } from '../utils/logger';\nimport EventEmitter from 'events';\n\nlet DemuxerWorker = function (self) {\n  // observer setup\n  let observer = new EventEmitter();\n  observer.trigger = function trigger (event, ...data) {\n    observer.emit(event, event, ...data);\n  };\n\n  observer.off = function off (event, ...data) {\n    observer.removeListener(event, ...data);\n  };\n\n  let forwardMessage = function (ev, data) {\n    self.postMessage({ event: ev, data: data });\n  };\n\n  self.addEventListener('message', function (ev) {\n    let data = ev.data;\n    // console.log('demuxer cmd:' + data.cmd);\n    switch (data.cmd) {\n    case 'init':\n      let config = JSON.parse(data.config);\n      self.demuxer = new DemuxerInline(observer, data.typeSupported, config, data.vendor);\n      try {\n        enableLogs(config.debug === true);\n      } catch (err) {\n        console.warn('demuxerWorker: unable to enable logs');\n      }\n      // signal end of worker init\n      forwardMessage('init', null);\n      break;\n    case 'demux':\n      self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);\n      break;\n    default:\n      break;\n    }\n  });\n\n  // forward events to main thread\n  observer.on(Event.FRAG_DECRYPTED, forwardMessage);\n  observer.on(Event.FRAG_PARSING_INIT_SEGMENT, forwardMessage);\n  observer.on(Event.FRAG_PARSED, forwardMessage);\n  observer.on(Event.ERROR, forwardMessage);\n  observer.on(Event.FRAG_PARSING_METADATA, forwardMessage);\n  observer.on(Event.FRAG_PARSING_USERDATA, forwardMessage);\n  observer.on(Event.INIT_PTS_FOUND, forwardMessage);\n\n  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)\n  observer.on(Event.FRAG_PARSING_DATA, function (ev, data) {\n    let transferable = [];\n    let message = { event: ev, data: data };\n    if (data.data1) {\n      message.data1 = data.data1.buffer;\n      transferable.push(data.data1.buffer);\n      delete data.data1;\n    }\n    if (data.data2) {\n      message.data2 = data.data2.buffer;\n      transferable.push(data.data2.buffer);\n      delete data.data2;\n    }\n    self.postMessage(message, transferable);\n  });\n};\n\nexport default DemuxerWorker;\n"],"sourceRoot":""}